<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pythtb &#8212; PythTB 1.8.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css?v=7f9a90b1" />
    
    <script src="../_static/documentation_options.js?v=371fd5e7"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PythTB 1.8.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pythtb</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pythtb</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_function</span>

<span class="c1"># PythTB python tight binding module.</span>
<span class="c1"># September 20th, 2022</span>
<span class="n">__version__</span><span class="o">=</span><span class="s1">&#39;1.8.0&#39;</span>

<span class="c1"># Copyright 2010, 2012, 2016, 2017, 2022 by Sinisa Coh and David Vanderbilt</span>
<span class="c1">#</span>
<span class="c1"># This file is part of PythTB.  PythTB is free software: you can</span>
<span class="c1"># redistribute it and/or modify it under the terms of the GNU General</span>
<span class="c1"># Public License as published by the Free Software Foundation, either</span>
<span class="c1"># version 3 of the License, or (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># PythTB is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="c1"># or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public</span>
<span class="c1"># License for more details.</span>
<span class="c1">#</span>
<span class="c1"># A copy of the GNU General Public License should be available</span>
<span class="c1"># alongside this source in a file named gpl-3.0.txt.  If not,</span>
<span class="c1"># see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1"># PythTB is availabe at http://www.physics.rutgers.edu/pythtb/</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span> <span class="c1"># numerics for matrices</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span> <span class="c1"># for exiting</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span> <span class="c1"># for deepcopying</span>

<div class="viewcode-block" id="tb_model">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">tb_model</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the main class of the PythTB package which contains all</span>
<span class="sd">    information for the tight-binding model.</span>

<span class="sd">    :param dim_k: Dimensionality of reciprocal space, i.e., specifies how</span>
<span class="sd">      many directions are considered to be periodic.</span>

<span class="sd">    :param dim_r: Dimensionality of real space, i.e., specifies how many</span>
<span class="sd">      real space lattice vectors there are and how many coordinates are</span>
<span class="sd">      needed to specify the orbital coordinates.</span>

<span class="sd">    .. note::</span>

<span class="sd">      Parameter *dim_r* can be larger than *dim_k*! For example,</span>
<span class="sd">      a polymer is a three-dimensional molecule (one needs three</span>
<span class="sd">      coordinates to specify orbital positions), but it is periodic</span>
<span class="sd">      along only one direction. For a polymer, therefore, we should</span>
<span class="sd">      have *dim_k* equal to 1 and *dim_r* equal to 3. See similar example</span>
<span class="sd">      here: :ref:`trestle-example`.</span>

<span class="sd">    :param lat: Array containing lattice vectors in Cartesian</span>
<span class="sd">      coordinates (in arbitrary units). In example the below, the first</span>
<span class="sd">      lattice vector has coordinates [1.0,0.5] while the second</span>
<span class="sd">      one has coordinates [0.0,2.0].  By default, lattice vectors</span>
<span class="sd">      are an identity matrix.</span>

<span class="sd">    :param orb: Array containing reduced coordinates of all</span>
<span class="sd">      tight-binding orbitals. In the example below, the first</span>
<span class="sd">      orbital is defined with reduced coordinates [0.2,0.3]. Its</span>
<span class="sd">      Cartesian coordinates are therefore 0.2 times the first</span>
<span class="sd">      lattice vector plus 0.3 times the second lattice vector.</span>
<span class="sd">      If *orb* is an integer code will assume that there are these many</span>
<span class="sd">      orbitals all at the origin of the unit cell.  By default</span>
<span class="sd">      the code will assume a single orbital at the origin.</span>

<span class="sd">    :param per: This is an optional parameter giving a list of lattice</span>
<span class="sd">      vectors which are considered to be periodic. In the example below,</span>
<span class="sd">      only the vector [0.0,2.0] is considered to be periodic (since</span>
<span class="sd">      per=[1]). By default, all lattice vectors are assumed to be</span>
<span class="sd">      periodic. If dim_k is smaller than dim_r, then by default the first</span>
<span class="sd">      dim_k vectors are considered to be periodic.</span>

<span class="sd">    :param nspin: Number of explicit spin components assumed for each</span>
<span class="sd">      orbital in *orb*. Allowed values of *nspin* are *1* and *2*. If</span>
<span class="sd">      *nspin* is 1 then the model is spinless, if *nspin* is 2 then it</span>
<span class="sd">      is explicitly a spinfull model and each orbital is assumed to</span>
<span class="sd">      have two spin components. Default value of this parameter is</span>
<span class="sd">      *1*.  Of course one can make spinfull calculation even with</span>
<span class="sd">      *nspin* set to 1, but then the user must keep track of which</span>
<span class="sd">      orbital corresponds to which spin component.</span>

<span class="sd">    Example usage::</span>

<span class="sd">       # Creates model that is two-dimensional in real space but only</span>
<span class="sd">       # one-dimensional in reciprocal space. Second lattice vector is</span>
<span class="sd">       # chosen to be periodic (since per=[1]). Three orbital</span>
<span class="sd">       # coordinates are specified.       </span>
<span class="sd">       tb = tb_model(1, 2,</span>
<span class="sd">                   lat=[[1.0, 0.5], [0.0, 2.0]],</span>
<span class="sd">                   orb=[[0.2, 0.3], [0.1, 0.1], [0.2, 0.2]],</span>
<span class="sd">                   per=[1])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dim_k</span><span class="p">,</span><span class="n">dim_r</span><span class="p">,</span><span class="n">lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">orb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">per</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">nspin</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="c1"># initialize _dim_k = dimensionality of k-space (integer)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">dim_k</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument dim_k not an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_k</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dim_k</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument dim_k out of range. Must be between 0 and 4.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">=</span><span class="n">dim_k</span>

        <span class="c1"># initialize _dim_r = dimensionality of r-space (integer)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">dim_r</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument dim_r not an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_r</span> <span class="o">&lt;</span> <span class="n">dim_k</span> <span class="ow">or</span> <span class="n">dim_r</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument dim_r out of range. Must be dim_r&gt;=dim_k and dim_r&lt;=4.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="o">=</span><span class="n">dim_r</span>

        <span class="c1"># initialize _lat = lattice vectors, array of dim_r*dim_r</span>
        <span class="c1">#   format is _lat(lat_vec_index,cartesian_index)</span>
        <span class="c1"># special option: &#39;unit&#39; implies unit matrix, also default value</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">lat</span> <span class="o">==</span> <span class="s1">&#39;unit&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim_r</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Lattice vectors not specified! I will use identity matrix.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="n">dim_r</span><span class="p">,</span><span class="n">dim_r</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong lat array dimensions&quot;</span><span class="p">)</span>
        <span class="c1"># check that volume is not zero and that have right handed system</span>
        <span class="k">if</span> <span class="n">dim_r</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1.0E-6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Lattice vectors length/area/volume too close to zero, or zero.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Lattice vectors need to form right handed system.&quot;</span><span class="p">)</span>

        <span class="c1"># initialize _norb = number of basis orbitals per cell</span>
        <span class="c1">#   and       _orb = orbital locations, in reduced coordinates</span>
        <span class="c1">#   format is _orb(orb_index,lat_vec_index)</span>
        <span class="c1"># special option: &#39;bravais&#39; implies one atom at origin</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">orb</span> <span class="o">==</span> <span class="s1">&#39;bravais&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">orb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">dim_r</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Orbital positions not specified. I will assume a single orbital at the origin.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">orb</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">=</span><span class="n">orb</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">orb</span><span class="p">,</span><span class="n">dim_r</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Orbital positions not specified. I will assume &quot;</span><span class="p">,</span><span class="n">orb</span><span class="p">,</span><span class="s2">&quot; orbitals at the origin&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orb</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">!=</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong orb array rank&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># number of orbitals</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="n">dim_r</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong orb array dimensions&quot;</span><span class="p">)</span>

        <span class="c1"># choose which self._dim_k out of self._dim_r dimensions are</span>
        <span class="c1"># to be considered periodic.        </span>
        <span class="k">if</span> <span class="n">per</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># by default first _dim_k dimensions are periodic</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">per</span><span class="p">)</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong choice of periodic/infinite direction!&quot;</span><span class="p">)</span>
            <span class="c1"># store which directions are the periodic ones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="o">=</span><span class="n">per</span>

        <span class="c1"># remember number of spin components</span>
        <span class="k">if</span> <span class="n">nspin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong value of nspin, must be 1 or 2!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">=</span><span class="n">nspin</span>

        <span class="c1"># by default, assume model did not come from w90 object and that</span>
        <span class="c1"># position operator is diagonal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">=</span><span class="kc">True</span>

        <span class="c1"># compute number of electronic states at each k-point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nsta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        
        <span class="c1"># Initialize onsite energies to zero</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="c1"># remember which onsite energies user has specified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[:]</span><span class="o">=</span><span class="kc">False</span>
        
        <span class="c1"># Initialize hoppings to empty list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="o">=</span><span class="p">[]</span>

        <span class="c1"># The onsite energies and hoppings are not specified</span>
        <span class="c1"># when creating a &#39;tb_model&#39; object.  They are speficied</span>
        <span class="c1"># subsequently by separate function calls defined below.</span>

<div class="viewcode-block" id="tb_model.set_onsite">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.set_onsite">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_onsite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">onsite_en</span><span class="p">,</span><span class="n">ind_i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;        </span>
<span class="sd">        Defines on-site energies for tight-binding orbitals. One can</span>
<span class="sd">        either set energy for one tight-binding orbital, or all at</span>
<span class="sd">        once.</span>

<span class="sd">        :param onsite_en: Either a list of on-site energies (in</span>
<span class="sd">          arbitrary units) for each orbital, or a single on-site</span>
<span class="sd">          energy (in this case *ind_i* parameter must be given). In</span>
<span class="sd">          the case when *nspin* is *1* (spinless) then each on-site</span>
<span class="sd">          energy is a single number.  If *nspin* is *2* then on-site</span>
<span class="sd">          energy can be given either as a single number, or as an</span>
<span class="sd">          array of four numbers, or 2x2 matrix. If a single number is</span>
<span class="sd">          given, it is interpreted as on-site energy for both up and</span>
<span class="sd">          down spin component. If an array of four numbers is given,</span>
<span class="sd">          these are the coefficients of I, sigma_x, sigma_y, and</span>
<span class="sd">          sigma_z (that is, the 2x2 identity and the three Pauli spin</span>
<span class="sd">          matrices) respectively. Finally, full 2x2 matrix can be</span>
<span class="sd">          given as well. If this function is never called, on-site</span>
<span class="sd">          energy is assumed to be zero.</span>

<span class="sd">        :param ind_i: Index of tight-binding orbital whose on-site</span>
<span class="sd">          energy you wish to change. This parameter should be</span>
<span class="sd">          specified only when *onsite_en* is a single number (not a</span>
<span class="sd">          list).</span>
<span class="sd">          </span>
<span class="sd">        :param mode: Similar to parameter *mode* in function set_hop*. </span>
<span class="sd">          Speficies way in which parameter *onsite_en* is</span>
<span class="sd">          used. It can either set value of on-site energy from scratch,</span>
<span class="sd">          reset it, or add to it.</span>

<span class="sd">          * &quot;set&quot; -- Default value. On-site energy is set to value of</span>
<span class="sd">            *onsite_en* parameter. One can use &quot;set&quot; on each</span>
<span class="sd">            tight-binding orbital only once.</span>

<span class="sd">          * &quot;reset&quot; -- Specifies on-site energy to given value. This</span>
<span class="sd">            function can be called multiple times for the same</span>
<span class="sd">            orbital(s).</span>

<span class="sd">          * &quot;add&quot; -- Adds to the previous value of on-site</span>
<span class="sd">            energy. This function can be called multiple times for the</span>
<span class="sd">            same orbital(s).</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Defines on-site energy of first orbital to be 0.0,</span>
<span class="sd">          # second 1.0, and third 2.0</span>
<span class="sd">          tb.set_onsite([0.0, 1.0, 2.0])</span>
<span class="sd">          # Increases value of on-site energy for second orbital</span>
<span class="sd">          tb.set_onsite(100.0, 1, mode=&quot;add&quot;)</span>
<span class="sd">          # Changes on-site energy of second orbital to zero</span>
<span class="sd">          tb.set_onsite(0.0, 1, mode=&quot;reset&quot;)</span>
<span class="sd">          # Sets all three on-site energies at once</span>
<span class="sd">          tb.set_onsite([2.0, 3.0, 4.0], mode=&quot;reset&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ind_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">)</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong number of site energies&quot;</span><span class="p">)</span>
        <span class="c1"># make sure ind_i is not out of scope</span>
        <span class="k">if</span> <span class="n">ind_i</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ind_i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">ind_i</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Index ind_i out of scope.&quot;</span><span class="p">)</span>
        <span class="c1"># make sure that onsite terms are real/hermitian</span>
        <span class="k">if</span> <span class="n">ind_i</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">to_check</span><span class="o">=</span><span class="p">[</span><span class="n">onsite_en</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_check</span><span class="o">=</span><span class="n">onsite_en</span>
        <span class="k">for</span> <span class="n">ons</span> <span class="ow">in</span> <span class="n">to_check</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">&gt;</span><span class="mf">1.0E-8</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Onsite energy should not have imaginary part!&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()))</span><span class="o">&gt;</span><span class="mf">1.0E-8</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Onsite energy or Zeeman field should not have imaginary part!&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()))</span><span class="o">&gt;</span><span class="mf">1.0E-8</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Onsite matrix should be Hermitian!&quot;</span><span class="p">)</span>
        <span class="c1"># specifying onsite energies from scratch, can be called only once</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;set&quot;</span><span class="p">:</span>
            <span class="c1"># specifying only one site at a time</span>
            <span class="k">if</span> <span class="n">ind_i</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="c1"># make sure we specify things only once</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Onsite energy for this site was already specified! Use mode=</span><span class="se">\&quot;</span><span class="s2">reset</span><span class="se">\&quot;</span><span class="s2"> or mode=</span><span class="se">\&quot;</span><span class="s2">add</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="c1"># specifying all sites at once</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># make sure we specify things only once</span>
                <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Some or all onsite energies were already specified! Use mode=</span><span class="se">\&quot;</span><span class="s2">reset</span><span class="se">\&quot;</span><span class="s2"> or mode=</span><span class="se">\&quot;</span><span class="s2">add</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[:]</span><span class="o">=</span><span class="kc">True</span>
        <span class="c1"># reset values of onsite terms, without adding to previous value</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;reset&quot;</span><span class="p">:</span>
            <span class="c1"># specifying only one site at a time</span>
            <span class="k">if</span> <span class="n">ind_i</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="c1"># specifying all sites at once</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[:]</span><span class="o">=</span><span class="kc">True</span>
        <span class="c1"># add to previous value</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;add&quot;</span><span class="p">:</span>
            <span class="c1"># specifying only one site at a time</span>
            <span class="k">if</span> <span class="n">ind_i</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[</span><span class="n">ind_i</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="c1"># specifying all sites at once</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[:]</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong value of mode parameter&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="tb_model.set_hop">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.set_hop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_hop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hop_amp</span><span class="p">,</span><span class="n">ind_i</span><span class="p">,</span><span class="n">ind_j</span><span class="p">,</span><span class="n">ind_R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;set&quot;</span><span class="p">,</span><span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Defines hopping parameters between tight-binding orbitals. In</span>
<span class="sd">        the notation used in section 3.1 equation 3.6 of</span>
<span class="sd">        :download:`notes on tight-binding formalism</span>
<span class="sd">        &lt;misc/pythtb-formalism.pdf&gt;` this function specifies the</span>
<span class="sd">        following object</span>

<span class="sd">        .. math::</span>

<span class="sd">          H_{ij}({\bf R})= \langle \phi_{{\bf 0} i}  \vert H  \vert \phi_{{\bf R},j} \rangle</span>

<span class="sd">        Where :math:`\langle \phi_{{\bf 0} i} \vert` is i-th</span>
<span class="sd">        tight-binding orbital in the home unit cell and</span>
<span class="sd">        :math:`\vert \phi_{{\bf R},j} \rangle` is j-th tight-binding orbital in</span>
<span class="sd">        unit cell shifted by lattice vector :math:`{\bf R}`. :math:`H`</span>
<span class="sd">        is the Hamiltonian.</span>

<span class="sd">        (Strictly speaking, this term specifies hopping amplitude</span>
<span class="sd">        for hopping from site *j+R* to site *i*, not vice-versa.)</span>

<span class="sd">        Hopping in the opposite direction is automatically included by</span>
<span class="sd">        the code since</span>

<span class="sd">        .. math::</span>

<span class="sd">          H_{ji}(-{\bf R})= \left[ H_{ij}({\bf R}) \right]^{*}</span>

<span class="sd">        .. warning::</span>

<span class="sd">           There is no need to specify hoppings in both :math:`i</span>
<span class="sd">           \rightarrow j+R` direction and opposite :math:`j</span>
<span class="sd">           \rightarrow i-R` direction since that is done</span>
<span class="sd">           automatically. If you want to specifiy hoppings in both</span>
<span class="sd">           directions, see description of parameter</span>
<span class="sd">           *allow_conjugate_pair*.</span>

<span class="sd">        :param hop_amp: Hopping amplitude; can be real or complex</span>
<span class="sd">          number, equals :math:`H_{ij}({\bf R})`. If *nspin* is *2*</span>
<span class="sd">          then hopping amplitude can be given either as a single</span>
<span class="sd">          number, or as an array of four numbers, or as 2x2 matrix. If</span>
<span class="sd">          a single number is given, it is interpreted as hopping</span>
<span class="sd">          amplitude for both up and down spin component.  If an array</span>
<span class="sd">          of four numbers is given, these are the coefficients of I,</span>
<span class="sd">          sigma_x, sigma_y, and sigma_z (that is, the 2x2 identity and</span>
<span class="sd">          the three Pauli spin matrices) respectively. Finally, full</span>
<span class="sd">          2x2 matrix can be given as well.</span>

<span class="sd">        :param ind_i: Index of bra orbital from the bracket :math:`\langle</span>
<span class="sd">          \phi_{{\bf 0} i} \vert H \vert \phi_{{\bf R},j} \rangle`. This</span>
<span class="sd">          orbital is assumed to be in the home unit cell.</span>

<span class="sd">        :param ind_j: Index of ket orbital from the bracket :math:`\langle</span>
<span class="sd">          \phi_{{\bf 0} i} \vert H \vert \phi_{{\bf R},j} \rangle`. This</span>
<span class="sd">          orbital does not have to be in the home unit cell; its unit cell</span>
<span class="sd">          position is determined by parameter *ind_R*.</span>

<span class="sd">        :param ind_R: Lattice vector (integer array, in reduced</span>
<span class="sd">          coordinates) pointing to the unit cell where the ket</span>
<span class="sd">          orbital is located.  The number of coordinates must equal</span>
<span class="sd">          the dimensionality in real space (*dim_r* parameter) for</span>
<span class="sd">          consistency, but only the periodic directions of ind_R are</span>
<span class="sd">          used. If reciprocal space is zero-dimensional (as in a</span>
<span class="sd">          molecule), this parameter does not need to be specified.</span>

<span class="sd">        :param mode: Similar to parameter *mode* in function *set_onsite*. </span>
<span class="sd">          Speficies way in which parameter *hop_amp* is</span>
<span class="sd">          used. It can either set value of hopping term from scratch,</span>
<span class="sd">          reset it, or add to it.</span>

<span class="sd">          * &quot;set&quot; -- Default value. Hopping term is set to value of</span>
<span class="sd">            *hop_amp* parameter. One can use &quot;set&quot; for each triplet of</span>
<span class="sd">            *ind_i*, *ind_j*, *ind_R* only once.</span>

<span class="sd">          * &quot;reset&quot; -- Specifies on-site energy to given value. This</span>
<span class="sd">            function can be called multiple times for the same triplet</span>
<span class="sd">            *ind_i*, *ind_j*, *ind_R*.</span>

<span class="sd">          * &quot;add&quot; -- Adds to the previous value of hopping term This</span>
<span class="sd">            function can be called multiple times for the same triplet</span>
<span class="sd">            *ind_i*, *ind_j*, *ind_R*.</span>

<span class="sd">          If *set_hop* was ever called with *allow_conjugate_pair* set</span>
<span class="sd">          to True, then it is possible that user has specified both</span>
<span class="sd">          :math:`i \rightarrow j+R` and conjugate pair :math:`j</span>
<span class="sd">          \rightarrow i-R`.  In this case, &quot;set&quot;, &quot;reset&quot;, and &quot;add&quot;</span>
<span class="sd">          parameters will treat triplet *ind_i*, *ind_j*, *ind_R* and</span>
<span class="sd">          conjugate triplet *ind_j*, *ind_i*, *-ind_R* as distinct.</span>

<span class="sd">        :param allow_conjugate_pair: Default value is *False*. If set</span>
<span class="sd">          to *True* code will allow user to specify hopping</span>
<span class="sd">          :math:`i \rightarrow j+R` even if conjugate-pair hopping</span>
<span class="sd">          :math:`j \rightarrow i-R` has been</span>
<span class="sd">          specified. If both terms are specified, code will</span>
<span class="sd">          still count each term two times.</span>
<span class="sd">          </span>
<span class="sd">        Example usage::</span>

<span class="sd">          # Specifies complex hopping amplitude between first orbital in home</span>
<span class="sd">          # unit cell and third orbital in neigbouring unit cell.</span>
<span class="sd">          tb.set_hop(0.3+0.4j, 0, 2, [0, 1])</span>
<span class="sd">          # change value of this hopping</span>
<span class="sd">          tb.set_hop(0.1+0.2j, 0, 2, [0, 1], mode=&quot;reset&quot;)</span>
<span class="sd">          # add to previous value (after this function call below,</span>
<span class="sd">          # hopping term amplitude is 100.1+0.2j)</span>
<span class="sd">          tb.set_hop(100.0, 0, 2, [0, 1], mode=&quot;add&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind_R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Need to specify ind_R!&quot;</span><span class="p">)</span>
        <span class="c1"># if necessary convert from integer to array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">ind_R</span><span class="p">):</span>
            <span class="n">tmpR</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">tmpR</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span><span class="o">=</span><span class="n">ind_R</span>
            <span class="n">ind_R</span><span class="o">=</span><span class="n">tmpR</span>
        <span class="c1"># check length of ind_R</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_R</span><span class="p">)</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Length of input ind_R vector must equal dim_r! Even if dim_k&lt;dim_r.&quot;</span><span class="p">)</span>
        <span class="c1"># make sure ind_i and ind_j are not out of scope</span>
        <span class="k">if</span> <span class="n">ind_i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">ind_i</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Index ind_i out of scope.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ind_j</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">ind_j</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Index ind_j out of scope.&quot;</span><span class="p">)</span>        
        <span class="c1"># do not allow onsite hoppings to be specified here because then they</span>
        <span class="c1"># will be double-counted</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ind_i</span><span class="o">==</span><span class="n">ind_j</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Do not use set_hop for onsite terms. Use set_onsite instead!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ind_i</span><span class="o">==</span><span class="n">ind_j</span><span class="p">:</span>
                <span class="n">all_zer</span><span class="o">=</span><span class="kc">True</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind_R</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">all_zer</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">if</span> <span class="n">all_zer</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Do not use set_hop for onsite terms. Use set_onsite instead!&quot;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># make sure that if &lt;i|H|j+R&gt; is specified that &lt;j|H|i-R&gt; is not!</span>
        <span class="k">if</span> <span class="n">allow_conjugate_pair</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ind_i</span><span class="o">==</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ind_j</span><span class="o">==</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>\
<span class="sd">&quot;&quot;&quot;\n</span>
<span class="sd">Following matrix element was already implicitely specified:</span>
<span class="sd">   i=&quot;&quot;&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ind_i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; j=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ind_j</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Remember, specifying &lt;i|H|j&gt; automatically specifies &lt;j|H|i&gt;.  For</span>
<span class="s2">consistency, specify all hoppings for a given bond in the same</span>
<span class="s2">direction.  (Or, alternatively, see the documentation on the</span>
<span class="s2">&#39;allow_conjugate_pair&#39; flag.)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="kc">False</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span><span class="o">==</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>\
<span class="sd">&quot;&quot;&quot;\n</span>
<span class="sd">Following matrix element was already implicitely specified:</span>
<span class="sd">   i=&quot;&quot;&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ind_i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; j=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ind_j</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; R=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ind_R</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Remember,specifying &lt;i|H|j+R&gt; automatically specifies &lt;j|H|i-R&gt;.  For</span>
<span class="s2">consistency, specify all hoppings for a given bond in the same</span>
<span class="s2">direction.  (Or, alternatively, see the documentation on the</span>
<span class="s2">&#39;allow_conjugate_pair&#39; flag.)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="c1"># convert to 2by2 matrix if needed</span>
        <span class="n">hop_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">hop_amp</span><span class="p">)</span>
        <span class="c1"># hopping term parameters to be stored</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">new_hop</span><span class="o">=</span><span class="p">[</span><span class="n">hop_use</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind_i</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">ind_j</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_hop</span><span class="o">=</span><span class="p">[</span><span class="n">hop_use</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind_i</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">ind_j</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">)]</span>
        <span class="c1">#</span>
        <span class="c1"># see if there is a hopping term with same i,j,R</span>
        <span class="n">use_index</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">for</span> <span class="n">iih</span><span class="p">,</span><span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">):</span>
            <span class="c1"># check if the same</span>
            <span class="n">same_ijR</span><span class="o">=</span><span class="kc">False</span> 
            <span class="k">if</span> <span class="n">ind_i</span><span class="o">==</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ind_j</span><span class="o">==</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">same_ijR</span><span class="o">=</span><span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="kc">False</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]):</span>
                        <span class="n">same_ijR</span><span class="o">=</span><span class="kc">True</span>
            <span class="c1"># if they are the same then store index of site at which they are the same</span>
            <span class="k">if</span> <span class="n">same_ijR</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="n">use_index</span><span class="o">=</span><span class="n">iih</span>
        <span class="c1">#</span>
        <span class="c1"># specifying hopping terms from scratch, can be called only once</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;set&quot;</span><span class="p">:</span>
            <span class="c1"># make sure we specify things only once</span>
            <span class="k">if</span> <span class="n">use_index</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Hopping energy for this site was already specified! Use mode=</span><span class="se">\&quot;</span><span class="s2">reset</span><span class="se">\&quot;</span><span class="s2"> or mode=</span><span class="se">\&quot;</span><span class="s2">add</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hop</span><span class="p">)</span>
        <span class="c1"># reset value of hopping term, without adding to previous value</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;reset&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_index</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">use_index</span><span class="p">]</span><span class="o">=</span><span class="n">new_hop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hop</span><span class="p">)</span>
        <span class="c1"># add to previous value</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;add&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_index</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">use_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">new_hop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong value of mode parameter&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_val_to_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If nspin=2 then returns a 2 by 2 matrix from the input</span>
<span class="sd">        parameters. If only one real number is given in the input then</span>
<span class="sd">        assume that this is the diagonal term. If array with four</span>
<span class="sd">        elements is given then first one is the diagonal term, and</span>
<span class="sd">        other three are Zeeman field direction. If given a 2 by 2</span>
<span class="sd">        matrix, just return it.  If nspin=1 then just returns val.&quot;&quot;&quot;</span>
        <span class="c1"># spinless case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span>
        <span class="c1"># spinfull case</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># matrix to return</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="c1"># </span>
            <span class="n">use_val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="c1"># only one number is given</span>
            <span class="k">if</span> <span class="n">use_val</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">():</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span>
            <span class="c1"># if four numbers are given</span>
            <span class="k">elif</span> <span class="n">use_val</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
                <span class="c1"># diagonal</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># sigma_x</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># sigma_y</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span><span class="p">)</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span> <span class="mf">1.0</span><span class="n">j</span><span class="p">)</span>
                <span class="c1"># sigma_z</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">use_val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>        
            <span class="c1"># if 2 by 2 matrix is given</span>
            <span class="k">elif</span> <span class="n">use_val</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">use_val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>\
<span class="sd">&quot;&quot;&quot;\n</span>
<span class="sd">Wrong format of the on-site or hopping term. Must be single number, or</span>
<span class="sd">in the case of a spinfull model can be array of four numbers or 2x2</span>
<span class="sd">matrix.&quot;&quot;&quot;</span><span class="p">)</span>            
            <span class="k">return</span> <span class="n">ret</span>        
        
<div class="viewcode-block" id="tb_model.display">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.display">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints on the screen some information about this tight-binding</span>
<span class="sd">        model. This function doesn&#39;t take any parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;---------------------------------------&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;report of tight-binding model&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;---------------------------------------&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k-space dimension           =&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;r-space dimension           =&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of spin components   =&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;periodic directions         =&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of orbitals          =&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of electronic states =&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lattice vectors:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; #&quot;</span><span class="p">,</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="s2">&quot; ===&gt;  [&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">_nice_float</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;positions of orbitals:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; #&quot;</span><span class="p">,</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="s2">&quot; ===&gt;  [&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">_nice_float</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;site energies:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; #&quot;</span><span class="p">,</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="s2">&quot; ===&gt;  &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">_nice_float</span><span class="p">(</span><span class="n">site</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hoppings:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">hopping</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">),</span><span class="s2">&quot;| H |&quot;</span><span class="p">,</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">2</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;+ [&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;     ===&gt; &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">_nice_complex</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hopping distances:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">hopping</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;|  pos(&quot;</span><span class="p">,</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">),</span><span class="s2">&quot;)  - pos(&quot;</span><span class="p">,</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">2</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;+ [&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">_nice_int</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;) |  =  &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">pos_i</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">hopping</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
            <span class="n">pos_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">hopping</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">pos_j</span><span class="o">+=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
            <span class="n">dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pos_j</span><span class="o">-</span><span class="n">pos_i</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">_nice_float</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">()</span></div>


<div class="viewcode-block" id="tb_model.visualize">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.visualize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visualize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dir_first</span><span class="p">,</span><span class="n">dir_second</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">eig_dr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">draw_hoppings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ph_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Rudimentary function for visualizing tight-binding model geometry,</span>
<span class="sd">        hopping between tight-binding orbitals, and electron eigenstates.</span>

<span class="sd">        If eigenvector is not drawn, then orbitals in home cell are drawn</span>
<span class="sd">        as red circles, and those in neighboring cells are drawn with</span>
<span class="sd">        different shade of red. Hopping term directions are drawn with</span>
<span class="sd">        green lines connecting two orbitals. Origin of unit cell is</span>
<span class="sd">        indicated with blue dot, while real space unit vectors are drawn</span>
<span class="sd">        with blue lines.</span>

<span class="sd">        If eigenvector is drawn, then electron eigenstate on each orbital</span>
<span class="sd">        is drawn with a circle whose size is proportional to wavefunction</span>
<span class="sd">        amplitude while its color depends on the phase. There are various</span>
<span class="sd">        coloring schemes for the phase factor; see more details under</span>
<span class="sd">        *ph_color* parameter. If eigenvector is drawn and coloring scheme</span>
<span class="sd">        is &quot;red-blue&quot; or &quot;wheel&quot;, all other elements of the picture are</span>
<span class="sd">        drawn in gray or black.</span>

<span class="sd">        :param dir_first: First index of Cartesian coordinates used for</span>
<span class="sd">          plotting.</span>

<span class="sd">        :param dir_second: Second index of Cartesian coordinates used for</span>
<span class="sd">          plotting. For example if dir_first=0 and dir_second=2, and</span>
<span class="sd">          Cartesian coordinates of some orbital is [2.0,4.0,6.0] then it</span>
<span class="sd">          will be drawn at coordinate [2.0,6.0]. If dimensionality of real</span>
<span class="sd">          space (*dim_r*) is zero or one then dir_second should not be</span>
<span class="sd">          specified.</span>

<span class="sd">        :param eig_dr: Optional parameter specifying eigenstate to</span>
<span class="sd">          plot. If specified, this should be one-dimensional array of</span>
<span class="sd">          complex numbers specifying wavefunction at each orbital in</span>
<span class="sd">          the tight-binding basis. If not specified, eigenstate is not</span>
<span class="sd">          drawn.</span>

<span class="sd">        :param draw_hoppings: Optional parameter specifying whether to</span>
<span class="sd">          draw all allowed hopping terms in the tight-binding</span>
<span class="sd">          model. Default value is True.</span>

<span class="sd">        :param ph_color: Optional parameter determining the way</span>
<span class="sd">          eigenvector phase factors are translated into color. Default</span>
<span class="sd">          value is &quot;black&quot;. Convention of the wavefunction phase is as</span>
<span class="sd">          in convention 1 in section 3.1 of :download:`notes on</span>
<span class="sd">          tight-binding formalism  &lt;misc/pythtb-formalism.pdf&gt;`.  In</span>
<span class="sd">          other words, these wavefunction phases are in correspondence</span>
<span class="sd">          with cell-periodic functions :math:`u_{n {\bf k}} ({\bf r})`</span>
<span class="sd">          not :math:`\Psi_{n {\bf k}} ({\bf r})`.</span>

<span class="sd">          * &quot;black&quot; -- phase of eigenvectors are ignored and wavefunction</span>
<span class="sd">            is always colored in black.</span>

<span class="sd">          * &quot;red-blue&quot; -- zero phase is drawn red, while phases or pi or</span>
<span class="sd">            -pi are drawn blue. Phases in between are interpolated between</span>
<span class="sd">            red and blue. Some phase information is lost in this coloring</span>
<span class="sd">            becase phase of +phi and -phi have same color.</span>

<span class="sd">          * &quot;wheel&quot; -- each phase is given unique color. In steps of pi/3</span>
<span class="sd">            starting from 0, colors are assigned (in increasing hue) as:</span>
<span class="sd">            red, yellow, green, cyan, blue, magenta, red.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **fig** -- Figure object from matplotlib.pyplot module</span>
<span class="sd">            that can be used to save the figure in PDF, EPS or similar</span>
<span class="sd">            format, for example using fig.savefig(&quot;name.pdf&quot;) command.</span>
<span class="sd">          * **ax** -- Axes object from matplotlib.pyplot module that can be</span>
<span class="sd">            used to tweak the plot, for example by adding a plot title</span>
<span class="sd">            ax.set_title(&quot;Title goes here&quot;).</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Draws x-y projection of tight-binding model</span>
<span class="sd">          # tweaks figure and saves it as a PDF.</span>
<span class="sd">          (fig, ax) = tb.visualize(0, 1)</span>
<span class="sd">          ax.set_title(&quot;Title goes here&quot;)</span>
<span class="sd">          fig.savefig(&quot;model.pdf&quot;)</span>

<span class="sd">        See also these examples: :ref:`edge-example`,</span>
<span class="sd">        :ref:`visualize-example`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check the format of eig_dr</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">eig_dr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">eig_dr</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong format of eig_dr! Must be array of size norb.&quot;</span><span class="p">)</span>
        
        <span class="c1"># check that ph_color is correct</span>
        <span class="k">if</span> <span class="n">ph_color</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;black&quot;</span><span class="p">,</span><span class="s2">&quot;red-blue&quot;</span><span class="p">,</span><span class="s2">&quot;wheel&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong value of ph_color parameter!&quot;</span><span class="p">)</span>

        <span class="c1"># check if dir_second had to be specified</span>
        <span class="k">if</span> <span class="n">dir_second</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Need to specify index of second coordinate for projection!&quot;</span><span class="p">)</span>

        <span class="c1"># start a new figure</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">ax</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">proj</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="s2">&quot;Project vector onto drawing plane&quot;</span>
            <span class="n">coord_x</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="n">dir_first</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dir_second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coord_y</span><span class="o">=</span><span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coord_y</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="n">dir_second</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">coord_x</span><span class="p">,</span><span class="n">coord_y</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">to_cart</span><span class="p">(</span><span class="n">red</span><span class="p">):</span>
            <span class="s2">&quot;Convert reduced to Cartesian coordinates&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">red</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>

        <span class="c1"># define colors to be used in plotting everything</span>
        <span class="c1"># except eigenvectors</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eig_dr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ph_color</span><span class="o">==</span><span class="s2">&quot;black&quot;</span><span class="p">:</span>
            <span class="n">c_cell</span><span class="o">=</span><span class="s2">&quot;b&quot;</span>
            <span class="n">c_orb</span><span class="o">=</span><span class="s2">&quot;r&quot;</span>
            <span class="n">c_nei</span><span class="o">=</span><span class="p">[</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">0.65</span><span class="p">,</span><span class="mf">0.65</span><span class="p">]</span>
            <span class="n">c_hop</span><span class="o">=</span><span class="s2">&quot;g&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_cell</span><span class="o">=</span><span class="p">[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">]</span>
            <span class="n">c_orb</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]</span>
            <span class="n">c_nei</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.6</span><span class="p">]</span>
            <span class="n">c_hop</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]</span>
        <span class="c1"># determine color scheme for eigenvectors</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">color_to_phase</span><span class="p">(</span><span class="n">ph</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ph_color</span><span class="o">==</span><span class="s2">&quot;black&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;k&quot;</span>
            <span class="k">if</span> <span class="n">ph_color</span><span class="o">==</span><span class="s2">&quot;red-blue&quot;</span><span class="p">:</span>
                <span class="n">ph</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ph</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">-</span><span class="n">ph</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="n">ph</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ph_color</span><span class="o">==</span><span class="s2">&quot;wheel&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ph</span><span class="o">&lt;</span><span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">ph</span><span class="o">=</span><span class="n">ph</span><span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">ph</span><span class="o">=</span><span class="mf">6.0</span><span class="o">*</span><span class="n">ph</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">x_ph</span><span class="o">=</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ph</span><span class="o">%</span><span class="mf">2.0</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ph</span><span class="o">&gt;=</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">ph</span><span class="o">&lt;</span><span class="mf">1.0</span><span class="p">:</span> <span class="n">ret_col</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span> <span class="p">,</span><span class="n">x_ph</span><span class="p">,</span><span class="mf">0.0</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">ph</span><span class="o">&gt;=</span><span class="mf">1.0</span> <span class="ow">and</span> <span class="n">ph</span><span class="o">&lt;</span><span class="mf">2.0</span><span class="p">:</span> <span class="n">ret_col</span><span class="o">=</span><span class="p">[</span><span class="n">x_ph</span><span class="p">,</span><span class="mf">1.0</span> <span class="p">,</span><span class="mf">0.0</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">ph</span><span class="o">&gt;=</span><span class="mf">2.0</span> <span class="ow">and</span> <span class="n">ph</span><span class="o">&lt;</span><span class="mf">3.0</span><span class="p">:</span> <span class="n">ret_col</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span> <span class="p">,</span><span class="mf">1.0</span> <span class="p">,</span><span class="n">x_ph</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ph</span><span class="o">&gt;=</span><span class="mf">3.0</span> <span class="ow">and</span> <span class="n">ph</span><span class="o">&lt;</span><span class="mf">4.0</span><span class="p">:</span> <span class="n">ret_col</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span> <span class="p">,</span><span class="n">x_ph</span><span class="p">,</span><span class="mf">1.0</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">ph</span><span class="o">&gt;=</span><span class="mf">4.0</span> <span class="ow">and</span> <span class="n">ph</span><span class="o">&lt;</span><span class="mf">5.0</span><span class="p">:</span> <span class="n">ret_col</span><span class="o">=</span><span class="p">[</span><span class="n">x_ph</span><span class="p">,</span><span class="mf">0.0</span> <span class="p">,</span><span class="mf">1.0</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">ph</span><span class="o">&gt;=</span><span class="mf">5.0</span> <span class="ow">and</span> <span class="n">ph</span><span class="o">&lt;=</span><span class="mf">6.0</span><span class="p">:</span> <span class="n">ret_col</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span> <span class="p">,</span><span class="mf">0.0</span> <span class="p">,</span><span class="n">x_ph</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">ret_col</span>

        <span class="c1"># draw origin</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">],</span><span class="s2">&quot;o&quot;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">c_cell</span><span class="p">,</span><span class="n">mec</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span><span class="n">mew</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mf">4.5</span><span class="p">)</span>

        <span class="c1"># first draw unit cell vectors which are considered to be periodic</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
            <span class="c1"># pick a unit cell vector and project it down to the drawing plane</span>
            <span class="n">vec</span><span class="o">=</span><span class="n">proj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mf">0.0</span><span class="p">,</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">c_cell</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

        <span class="c1"># now draw all orbitals</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
            <span class="c1"># find position of orbital in cartesian coordinates</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">to_cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">proj</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="s2">&quot;o&quot;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">c_orb</span><span class="p">,</span><span class="n">mec</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span><span class="n">mew</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mf">4.0</span><span class="p">)</span>

        <span class="c1"># draw hopping terms</span>
        <span class="k">if</span> <span class="n">draw_hoppings</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">:</span>
                <span class="c1"># draw both i-&gt;j+R and i-R-&gt;j hop</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="c1"># get &quot;from&quot; and &quot;to&quot; coordinates</span>
                    <span class="n">pos_i</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="n">pos_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
                    <span class="c1"># add also lattice vector if not 0-dim</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">s</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                            <span class="n">pos_j</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span><span class="o">=</span><span class="n">pos_j</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">s</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">pos_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span><span class="o">=</span><span class="n">pos_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span>
                    <span class="c1"># project down vector to the plane</span>
                    <span class="n">pos_i</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj</span><span class="p">(</span><span class="n">to_cart</span><span class="p">(</span><span class="n">pos_i</span><span class="p">)))</span>
                    <span class="n">pos_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj</span><span class="p">(</span><span class="n">to_cart</span><span class="p">(</span><span class="n">pos_j</span><span class="p">)))</span>
                    <span class="c1"># add also one point in the middle to bend the curve</span>
                    <span class="n">prcnt</span><span class="o">=</span><span class="mf">0.05</span> <span class="c1"># bend always by this ammount</span>
                    <span class="n">pos_mid</span><span class="o">=</span><span class="p">(</span><span class="n">pos_i</span><span class="o">+</span><span class="n">pos_j</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
                    <span class="n">dif</span><span class="o">=</span><span class="n">pos_j</span><span class="o">-</span><span class="n">pos_i</span> <span class="c1"># difference vector</span>
                    <span class="n">orth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dif</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">dif</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="c1"># orthogonal to difference vector</span>
                    <span class="n">orth</span><span class="o">=</span><span class="n">orth</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">orth</span><span class="p">,</span><span class="n">orth</span><span class="p">))</span> <span class="c1"># normalize</span>
                    <span class="n">pos_mid</span><span class="o">=</span><span class="n">pos_mid</span><span class="o">+</span><span class="n">orth</span><span class="o">*</span><span class="n">prcnt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dif</span><span class="p">,</span><span class="n">dif</span><span class="p">))</span> <span class="c1"># shift mid point in orthogonal direction</span>
                    <span class="c1"># draw hopping</span>
                    <span class="n">all_pnts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pos_i</span><span class="p">,</span><span class="n">pos_mid</span><span class="p">,</span><span class="n">pos_j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">all_pnts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">all_pnts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">c_hop</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                    <span class="c1"># draw &quot;from&quot; and &quot;to&quot; sites</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pos_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">pos_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="s2">&quot;o&quot;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">c_nei</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span><span class="n">mew</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span><span class="n">mec</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pos_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">pos_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="s2">&quot;o&quot;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">c_nei</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span><span class="n">mew</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span><span class="n">mec</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="c1"># now draw the eigenstate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">eig_dr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
                <span class="c1"># find position of orbital in cartesian coordinates</span>
                <span class="n">pos</span><span class="o">=</span><span class="n">to_cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">pos</span><span class="o">=</span><span class="n">proj</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                <span class="c1"># find norm of eigenfunction at this point</span>
                <span class="n">nrm</span><span class="o">=</span><span class="p">(</span><span class="n">eig_dr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">eig_dr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>
                <span class="c1"># rescale and get size of circle</span>
                <span class="n">nrm_rad</span><span class="o">=</span><span class="mf">2.0</span><span class="o">*</span><span class="n">nrm</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">)</span>
                <span class="c1"># get color based on the phase of the eigenstate</span>
                <span class="n">phase</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">eig_dr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">c_ph</span><span class="o">=</span><span class="n">color_to_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="s2">&quot;o&quot;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">c_ph</span><span class="p">,</span><span class="n">mec</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span><span class="n">mew</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="n">nrm_rad</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

        <span class="c1"># center the image</span>
        <span class="c1">#  first get the current limit, which is probably tight</span>
        <span class="n">xl</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">()</span>
        <span class="n">yl</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">()</span>
        <span class="c1"># now get the center of current limit</span>
        <span class="n">centx</span><span class="o">=</span><span class="p">(</span><span class="n">xl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">xl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span>
        <span class="n">centy</span><span class="o">=</span><span class="p">(</span><span class="n">yl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">yl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span>
        <span class="c1"># now get the maximal size (lengthwise or heightwise)</span>
        <span class="n">mx</span><span class="o">=</span><span class="nb">max</span><span class="p">([</span><span class="n">xl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">yl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">yl</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="c1"># set new limits</span>
        <span class="n">extr</span><span class="o">=</span><span class="mf">0.05</span> <span class="c1"># add some boundary as well</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">centx</span><span class="o">-</span><span class="n">mx</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="n">extr</span><span class="p">),</span><span class="n">centx</span><span class="o">+</span><span class="n">mx</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="n">extr</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">centy</span><span class="o">-</span><span class="n">mx</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="n">extr</span><span class="p">),</span><span class="n">centy</span><span class="o">+</span><span class="n">mx</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="n">extr</span><span class="p">))</span>

        <span class="c1"># return a figure and axes to the user</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span></div>


<div class="viewcode-block" id="tb_model.get_num_orbitals">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.get_num_orbitals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns number of orbitals in the model.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span></div>


<div class="viewcode-block" id="tb_model.get_orb">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.get_orb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_orb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns reduced coordinates of orbitals in format [orbital,coordinate.]&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="tb_model.get_lat">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.get_lat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_lat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns lattice vectors in format [vector,coordinate].&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_gen_ham</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k_input</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Hamiltonian for a certain k-point,</span>
<span class="sd">        K-point is given in reduced coordinates!&quot;&quot;&quot;</span>
        <span class="n">kpnt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k_input</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">k_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># if kpnt is just a number then convert it to an array</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpnt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">kpnt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kpnt</span><span class="p">])</span>
            <span class="c1"># check that k-vector is of corect size</span>
            <span class="k">if</span> <span class="n">kpnt</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">k-vector of wrong shape!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Have to provide a k-vector!&quot;</span><span class="p">)</span>
        <span class="c1"># zero the Hamiltonian matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">ham</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">ham</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="c1"># modify diagonal elements</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ham</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">ham</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># go over all hoppings</span>
        <span class="k">for</span> <span class="n">hopping</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">:</span>
            <span class="c1"># get all data for the hopping parameter</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">amp</span><span class="o">=</span><span class="nb">complex</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">amp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">i</span><span class="o">=</span><span class="n">hopping</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">j</span><span class="o">=</span><span class="n">hopping</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># in 0-dim case there is no phase factor</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ind_R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="c1"># vector from one site to another</span>
                <span class="n">rv</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">+</span><span class="n">ind_R</span>
                <span class="c1"># Take only components of vector which are periodic</span>
                <span class="n">rv</span><span class="o">=</span><span class="n">rv</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span>
                <span class="c1"># Calculate the hopping, see details in pythtb-formalism.pdf</span>
                <span class="n">phase</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="mf">2.0</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kpnt</span><span class="p">,</span><span class="n">rv</span><span class="p">))</span>
                <span class="n">amp</span><span class="o">=</span><span class="n">amp</span><span class="o">*</span><span class="n">phase</span>
            <span class="c1"># add this hopping into a matrix and also its conjugate</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ham</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">amp</span>
                <span class="n">ham</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">amp</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">ham</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="n">j</span><span class="p">,:]</span><span class="o">+=</span><span class="n">amp</span>
                <span class="n">ham</span><span class="p">[</span><span class="n">j</span><span class="p">,:,</span><span class="n">i</span><span class="p">,:]</span><span class="o">+=</span><span class="n">amp</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ham</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sol_ham</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ham</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solves Hamiltonian and returns eigenvectors, eigenvalues&quot;&quot;&quot;</span>
        <span class="c1"># reshape matrix first</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">ham_use</span><span class="o">=</span><span class="n">ham</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">ham_use</span><span class="o">=</span><span class="n">ham</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">))</span>
        <span class="c1"># check that matrix is hermitian</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ham_use</span><span class="o">-</span><span class="n">ham_use</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">&gt;</span><span class="mf">1.0E-9</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Hamiltonian matrix is not hermitian?!&quot;</span><span class="p">)</span>
        <span class="c1">#solve matrix</span>
        <span class="k">if</span> <span class="n">eig_vectors</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span> <span class="c1"># only find eigenvalues</span>
            <span class="nb">eval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">ham_use</span><span class="p">)</span>
            <span class="c1"># sort eigenvalues and convert to real numbers</span>
            <span class="nb">eval</span><span class="o">=</span><span class="n">_nicefy_eig</span><span class="p">(</span><span class="nb">eval</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># find eigenvalues and eigenvectors</span>
            <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">eig</span><span class="p">)</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">ham_use</span><span class="p">)</span>
            <span class="c1"># transpose matrix eig since otherwise it is confusing</span>
            <span class="c1"># now eig[i,:] is eigenvector for eval[i]-th eigenvalue</span>
            <span class="n">eig</span><span class="o">=</span><span class="n">eig</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># sort evectors, eigenvalues and convert to real numbers</span>
            <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">eig</span><span class="p">)</span><span class="o">=</span><span class="n">_nicefy_eig</span><span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">eig</span><span class="p">)</span>
            <span class="c1"># reshape eigenvectors if doing a spinfull calculation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">eig</span><span class="o">=</span><span class="n">eig</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">eig</span><span class="p">)</span>

<div class="viewcode-block" id="tb_model.solve_all">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.solve_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves for eigenvalues and (optionally) eigenvectors of the</span>
<span class="sd">        tight-binding model on a given one-dimensional list of k-vectors.</span>

<span class="sd">        .. note::</span>

<span class="sd">           Eigenvectors (wavefunctions) returned by this</span>
<span class="sd">           function and used throughout the code are exclusively given</span>
<span class="sd">           in convention 1 as described in section 3.1 of</span>
<span class="sd">           :download:`notes on tight-binding formalism</span>
<span class="sd">           &lt;misc/pythtb-formalism.pdf&gt;`.  In other words, they</span>
<span class="sd">           are in correspondence with cell-periodic functions</span>
<span class="sd">           :math:`u_{n {\bf k}} ({\bf r})` not</span>
<span class="sd">           :math:`\Psi_{n {\bf k}} ({\bf r})`.</span>

<span class="sd">        .. note::</span>

<span class="sd">           In some cases class :class:`pythtb.wf_array` provides a more</span>
<span class="sd">           elegant way to deal with eigensolutions on a regular mesh of</span>
<span class="sd">           k-vectors.</span>

<span class="sd">        :param k_list: One-dimensional array of k-vectors. Each k-vector</span>
<span class="sd">          is given in reduced coordinates of the reciprocal space unit</span>
<span class="sd">          cell. For example, for real space unit cell vectors [1.0,0.0]</span>
<span class="sd">          and [0.0,2.0] and associated reciprocal space unit vectors</span>
<span class="sd">          [2.0*pi,0.0] and [0.0,pi], k-vector with reduced coordinates</span>
<span class="sd">          [0.25,0.25] corresponds to k-vector [0.5*pi,0.25*pi].</span>
<span class="sd">          Dimensionality of each vector must equal to the number of</span>
<span class="sd">          periodic directions (i.e. dimensionality of reciprocal space,</span>
<span class="sd">          *dim_k*).</span>
<span class="sd">          This parameter shouldn&#39;t be specified for system with</span>
<span class="sd">          zero-dimensional k-space (*dim_k* =0).</span>

<span class="sd">        :param eig_vectors: Optional boolean parameter, specifying whether</span>
<span class="sd">          eigenvectors should be returned. If *eig_vectors* is True, then</span>
<span class="sd">          both eigenvalues and eigenvectors are returned, otherwise only</span>
<span class="sd">          eigenvalues are returned.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **eval** -- Two dimensional array of eigenvalues for</span>
<span class="sd">            all bands for all kpoints. Format is eval[band,kpoint] where</span>
<span class="sd">            first index (band) corresponds to the electron band in</span>
<span class="sd">            question and second index (kpoint) corresponds to the k-point</span>
<span class="sd">            as listed in the input parameter *k_list*. Eigenvalues are</span>
<span class="sd">            sorted from smallest to largest at each k-point seperately.</span>

<span class="sd">            In the case when reciprocal space is zero-dimensional (as in a</span>
<span class="sd">            molecule) kpoint index is dropped and *eval* is of the format</span>
<span class="sd">            eval[band].</span>

<span class="sd">          * **evec** -- Three dimensional array of eigenvectors for</span>
<span class="sd">            all bands and all kpoints. If *nspin* equals 1 the format</span>
<span class="sd">            of *evec* is evec[band,kpoint,orbital] where &quot;band&quot; is the</span>
<span class="sd">            electron band in question, &quot;kpoint&quot; is index of k-vector</span>
<span class="sd">            as given in input parameter *k_list*. Finally, &quot;orbital&quot;</span>
<span class="sd">            refers to the tight-binding orbital basis function.</span>
<span class="sd">            Ordering of bands is the same as in *eval*.  </span>
<span class="sd">            </span>
<span class="sd">            Eigenvectors evec[n,k,j] correspond to :math:`C^{n {\bf</span>
<span class="sd">            k}}_{j}` from section 3.1 equation 3.5 and 3.7 of the</span>
<span class="sd">            :download:`notes on tight-binding formalism</span>
<span class="sd">            &lt;misc/pythtb-formalism.pdf&gt;`.</span>

<span class="sd">            In the case when reciprocal space is zero-dimensional (as in a</span>
<span class="sd">            molecule) kpoint index is dropped and *evec* is of the format</span>
<span class="sd">            evec[band,orbital].</span>

<span class="sd">            In the spinfull calculation (*nspin* equals 2) evec has</span>
<span class="sd">            additional component evec[...,spin] corresponding to the</span>
<span class="sd">            spin component of the wavefunction.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Returns eigenvalues for three k-vectors</span>
<span class="sd">          eval = tb.solve_all([[0.0, 0.0], [0.0, 0.2], [0.0, 0.5]])</span>
<span class="sd">          # Returns eigenvalues and eigenvectors for two k-vectors</span>
<span class="sd">          (eval, evec) = tb.solve_all([[0.0, 0.0], [0.0, 0.2]], eig_vectors=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if not 0-dim case</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">k_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">nkp</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">k_list</span><span class="p">)</span> <span class="c1"># number of k points</span>
            <span class="c1"># first initialize matrices for all return data</span>
            <span class="c1">#    indices are [band,kpoint]</span>
            <span class="n">ret_eval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta</span><span class="p">,</span><span class="n">nkp</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1">#    indices are [band,kpoint,orbital,spin]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ret_evec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta</span><span class="p">,</span><span class="n">nkp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">ret_evec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta</span><span class="p">,</span><span class="n">nkp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="c1"># go over all kpoints</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k_list</span><span class="p">):</span>
                <span class="c1"># generate Hamiltonian at that point</span>
                <span class="n">ham</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gen_ham</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="c1"># solve Hamiltonian</span>
                <span class="k">if</span> <span class="n">eig_vectors</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                    <span class="nb">eval</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sol_ham</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">)</span>
                    <span class="n">ret_eval</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">eval</span><span class="p">[:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sol_ham</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">)</span>
                    <span class="n">ret_eval</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">eval</span><span class="p">[:]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">ret_evec</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="n">evec</span><span class="p">[:,:]</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">ret_evec</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">evec</span><span class="p">[:,:,:]</span>
            <span class="c1"># return stuff</span>
            <span class="k">if</span> <span class="n">eig_vectors</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="c1"># indices of eval are [band,kpoint]</span>
                <span class="k">return</span> <span class="n">ret_eval</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># indices of eval are [band,kpoint] for evec are [band,kpoint,orbital,(spin)]</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">ret_eval</span><span class="p">,</span><span class="n">ret_evec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 0 dim case</span>
            <span class="c1"># generate Hamiltonian</span>
            <span class="n">ham</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gen_ham</span><span class="p">()</span>
            <span class="c1"># solve</span>
            <span class="k">if</span> <span class="n">eig_vectors</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="nb">eval</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sol_ham</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">)</span>
                <span class="c1"># indices of eval are [band]</span>
                <span class="k">return</span> <span class="nb">eval</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sol_ham</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">)</span>
                <span class="c1"># indices of eval are [band] and of evec are [band,orbital,spin]</span>
                <span class="k">return</span> <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span></div>


<div class="viewcode-block" id="tb_model.solve_one">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.solve_one">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k_point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Similar to :func:`pythtb.tb_model.solve_all` but solves tight-binding</span>
<span class="sd">        model for only one k-vector.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if not 0-dim case</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">k_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">eig_vectors</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="nb">eval</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solve_all</span><span class="p">([</span><span class="n">k_point</span><span class="p">],</span><span class="n">eig_vectors</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">)</span>
                <span class="c1"># indices of eval are [band]</span>
                <span class="k">return</span> <span class="nb">eval</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solve_all</span><span class="p">([</span><span class="n">k_point</span><span class="p">],</span><span class="n">eig_vectors</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">)</span>
                <span class="c1"># indices of eval are [band] for evec are [band,orbital,spin]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="nb">eval</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">evec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="nb">eval</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">evec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># do the same as solve_all</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_all</span><span class="p">(</span><span class="n">eig_vectors</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">)</span></div>


<div class="viewcode-block" id="tb_model.cut_piece">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.cut_piece">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cut_piece</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">num</span><span class="p">,</span><span class="n">fin_dir</span><span class="p">,</span><span class="n">glue_edgs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a (d-1)-dimensional tight-binding model out of a</span>
<span class="sd">        d-dimensional one by repeating the unit cell a given number of</span>
<span class="sd">        times along one of the periodic lattice vectors. The real-space</span>
<span class="sd">        lattice vectors of the returned model are the same as those of</span>
<span class="sd">        the original model; only the dimensionality of reciprocal space</span>
<span class="sd">        is reduced.</span>

<span class="sd">        :param num: How many times to repeat the unit cell.</span>

<span class="sd">        :param fin_dir: Index of the real space lattice vector along</span>
<span class="sd">          which you no longer wish to maintain periodicity.</span>

<span class="sd">        :param glue_edgs: Optional boolean parameter specifying whether to</span>
<span class="sd">          allow hoppings from one edge to the other of a cut model.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **fin_model** -- Object of type</span>
<span class="sd">            :class:`pythtb.tb_model` representing a cutout</span>
<span class="sd">            tight-binding model. Orbitals in *fin_model* are</span>
<span class="sd">            numbered so that the i-th orbital of the n-th unit</span>
<span class="sd">            cell has index i+norb*n (here norb is the number of</span>
<span class="sd">            orbitals in the original model).</span>

<span class="sd">        Example usage::</span>

<span class="sd">          A = tb_model(3, 3, ...)</span>
<span class="sd">          # Construct two-dimensional model B out of three-dimensional</span>
<span class="sd">          # model A by repeating model along second lattice vector ten times</span>
<span class="sd">          B = A.cut_piece(10, 1)</span>
<span class="sd">          # Further cut two-dimensional model B into one-dimensional model</span>
<span class="sd">          # A by repeating unit cell twenty times along third lattice</span>
<span class="sd">          # vector and allow hoppings from one edge to the other</span>
<span class="sd">          C = B.cut_piece(20, 2, glue_edgs=True)</span>

<span class="sd">        See also these examples: :ref:`haldane_fin-example`,</span>
<span class="sd">        :ref:`edge-example`.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Model is already finite&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument num not an integer&quot;</span><span class="p">)</span>

        <span class="c1"># check value of num</span>
        <span class="k">if</span> <span class="n">num</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument num must be positive!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">glue_edgs</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Can&#39;t have num==1 and glueing of the edges!&quot;</span><span class="p">)</span>

        <span class="c1"># generate orbitals of a finite model</span>
        <span class="n">fin_orb</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">onsite</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># store also onsite energies</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span> <span class="c1"># go over all cells in finite direction</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span> <span class="c1"># go over all orbitals in one cell</span>
                <span class="c1"># make a copy of j-th orbital</span>
                <span class="n">orb_tmp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">j</span><span class="p">,:])</span>
                <span class="c1"># change coordinate along finite direction</span>
                <span class="n">orb_tmp</span><span class="p">[</span><span class="n">fin_dir</span><span class="p">]</span><span class="o">+=</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="c1"># add to the list</span>
                <span class="n">fin_orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orb_tmp</span><span class="p">)</span>
                <span class="c1"># do the onsite energies at the same time</span>
                <span class="n">onsite</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">onsite</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">onsite</span><span class="p">)</span>
        <span class="n">fin_orb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fin_orb</span><span class="p">)</span>

        <span class="c1"># generate periodic directions of a finite model</span>
        <span class="n">fin_per</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span>
        <span class="c1"># find if list of periodic directions contains the one you</span>
        <span class="c1"># want to make finite</span>
        <span class="k">if</span> <span class="n">fin_per</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">fin_dir</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Can not make model finite along this direction!&quot;</span><span class="p">)</span>
        <span class="c1"># remove index which is no longer periodic</span>
        <span class="n">fin_per</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fin_dir</span><span class="p">)</span>

        <span class="c1"># generate object of tb_model type that will correspond to a cutout</span>
        <span class="n">fin_model</span><span class="o">=</span><span class="n">tb_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span>
                           <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">),</span>
                           <span class="n">fin_orb</span><span class="p">,</span>
                           <span class="n">fin_per</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span>

        <span class="c1"># remember if came from w90</span>
        <span class="n">fin_model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span>

        <span class="c1"># now put all onsite terms for the finite model</span>
        <span class="n">fin_model</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="n">onsite</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reset&quot;</span><span class="p">)</span>

        <span class="c1"># put all hopping terms</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span> <span class="c1"># go over all cells in finite direction</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)):</span> <span class="c1"># go over all hoppings in one cell</span>
                <span class="c1"># amplitude of the hop is the same</span>
                <span class="n">amp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># lattice vector of the hopping</span>
                <span class="n">ind_R</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">jump_fin</span><span class="o">=</span><span class="n">ind_R</span><span class="p">[</span><span class="n">fin_dir</span><span class="p">]</span> <span class="c1"># store by how many cells is the hopping in finite direction</span>
                <span class="k">if</span> <span class="n">fin_model</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">ind_R</span><span class="p">[</span><span class="n">fin_dir</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># one of the directions now becomes finite</span>

                <span class="c1"># index of &quot;from&quot; and &quot;to&quot; hopping indices</span>
                <span class="n">hi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>
                <span class="c1">#   have to compensate  for the fact that ind_R in finite direction</span>
                <span class="c1">#   will not be used in the finite model</span>
                <span class="n">hj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">jump_fin</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>

                <span class="c1"># decide whether this hopping should be added or not</span>
                <span class="n">to_add</span><span class="o">=</span><span class="kc">True</span>
                <span class="c1"># if edges are not glued then neglect all jumps that spill out</span>
                <span class="k">if</span> <span class="n">glue_edgs</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">hj</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">hj</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">*</span><span class="n">num</span><span class="p">:</span>
                        <span class="n">to_add</span><span class="o">=</span><span class="kc">False</span>
                <span class="c1"># if edges are glued then do mod division to wrap up the hopping</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hj</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">hj</span><span class="p">)</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">*</span><span class="n">num</span><span class="p">)</span>

                <span class="c1"># add hopping to a finite model</span>
                <span class="k">if</span> <span class="n">to_add</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fin_model</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">fin_model</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span><span class="n">hi</span><span class="p">,</span><span class="n">hj</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span><span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fin_model</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span><span class="n">hi</span><span class="p">,</span><span class="n">hj</span><span class="p">,</span><span class="n">ind_R</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span><span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fin_model</span></div>


<div class="viewcode-block" id="tb_model.reduce_dim">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.reduce_dim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reduce_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">remove_k</span><span class="p">,</span><span class="n">value_k</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduces dimensionality of the model by taking a reciprocal-space</span>
<span class="sd">        slice of the Bloch Hamiltonian :math:`{\cal H}_{\bf k}`. The Bloch</span>
<span class="sd">        Hamiltonian (defined in :download:`notes on tight-binding</span>
<span class="sd">        formalism &lt;misc/pythtb-formalism.pdf&gt;` in section 3.1 equation 3.7) of a</span>
<span class="sd">        d-dimensional model is a function of d-dimensional k-vector.</span>

<span class="sd">        This function returns a d-1 dimensional tight-binding model obtained</span>
<span class="sd">        by constraining one of k-vector components in :math:`{\cal H}_{\bf</span>
<span class="sd">        k}` to be a constant.</span>

<span class="sd">        :param remove_k: Which reciprocal space unit vector component</span>
<span class="sd">          you wish to keep constant.</span>

<span class="sd">        :param value_k: Value of the k-vector component to which you are</span>
<span class="sd">          constraining this model. Must be given in reduced coordinates.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **red_tb** -- Object of type :class:`pythtb.tb_model`</span>
<span class="sd">            representing a reduced tight-binding model.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Constrains second k-vector component to equal 0.3</span>
<span class="sd">          red_tb = tb.reduce_dim(1, 0.3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Can not reduce dimensionality even further!&quot;</span><span class="p">)</span>
        <span class="c1"># make a copy</span>
        <span class="n">red_tb</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># make one of the directions not periodic</span>
        <span class="n">red_tb</span><span class="o">.</span><span class="n">_per</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">remove_k</span><span class="p">)</span>
        <span class="n">red_tb</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">red_tb</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span>
        <span class="c1"># check that really removed one and only one direction</span>
        <span class="k">if</span> <span class="n">red_tb</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Specified wrong dimension to reduce!&quot;</span><span class="p">)</span>
        
        <span class="c1"># specify hopping terms from scratch</span>
        <span class="n">red_tb</span><span class="o">.</span><span class="n">_hoppings</span><span class="o">=</span><span class="p">[]</span>
        <span class="c1"># set all hopping parameters for this value of value_k</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)):</span>
            <span class="n">hop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">amp</span><span class="o">=</span><span class="nb">complex</span><span class="p">(</span><span class="n">hop</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">amp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">i</span><span class="o">=</span><span class="n">hop</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">=</span><span class="n">hop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ind_R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hop</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># vector from one site to another</span>
            <span class="n">rv</span><span class="o">=-</span><span class="n">red_tb</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">+</span><span class="n">red_tb</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># take only r-vector component along direction you are not making periodic</span>
            <span class="n">rv</span><span class="o">=</span><span class="n">rv</span><span class="p">[</span><span class="n">remove_k</span><span class="p">]</span>
            <span class="c1"># Calculate the part of hopping phase, only for this direction</span>
            <span class="n">phase</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="mf">2.0</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">value_k</span><span class="o">*</span><span class="n">rv</span><span class="p">))</span>
            <span class="c1"># store modified version of the hop</span>
            <span class="c1"># Since we are getting rid of one dimension, it could be that now</span>
            <span class="c1"># one of the hopping terms became onsite term because one direction</span>
            <span class="c1"># is no longer periodic</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span> <span class="ow">and</span> <span class="p">(</span><span class="kc">False</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">[</span><span class="n">red_tb</span><span class="o">.</span><span class="n">_per</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">ind_R</span><span class="p">[</span><span class="n">remove_k</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># in this case this is really an onsite term</span>
                    <span class="n">red_tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="n">amp</span><span class="o">*</span><span class="n">phase</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># in this case must treat both R and -R because that term would</span>
                    <span class="c1"># have been counted twice without dimensional reduction</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">red_tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="n">amp</span><span class="o">*</span><span class="n">phase</span><span class="o">+</span><span class="p">(</span><span class="n">amp</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">red_tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="n">amp</span><span class="o">*</span><span class="n">phase</span><span class="o">+</span><span class="p">(</span><span class="n">amp</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">i</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># just in case make the R vector zero along the reduction dimension</span>
                <span class="n">ind_R</span><span class="p">[</span><span class="n">remove_k</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
                <span class="c1"># add hopping term</span>
                <span class="n">red_tb</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span><span class="n">amp</span><span class="o">*</span><span class="n">phase</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">ind_R</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span><span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">red_tb</span></div>


<div class="viewcode-block" id="tb_model.change_nonperiodic_vector">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.change_nonperiodic_vector">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">change_nonperiodic_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np_dir</span><span class="p">,</span> <span class="n">new_latt_vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_home</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">to_home_suppress_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns tight-binding model :class:`pythtb.tb_model` in which one of</span>
<span class="sd">        the nonperiodic &quot;lattice vectors&quot; is changed.  Nonperiodic</span>
<span class="sd">        vectors are those elements of *lat* that are not listed as</span>
<span class="sd">        periodic with the *per* parameter.  (See more information on</span>
<span class="sd">        *lat* and *per* in :class:`pythtb.tb_model`). The returned object</span>
<span class="sd">        also has modified reduced coordinates of orbitals, consistent</span>
<span class="sd">        with the new choice of *lat*.  Therefore, the actual (Cartesian)</span>
<span class="sd">        coordinates of orbitals in original and returned tb_model are</span>
<span class="sd">        the same.</span>

<span class="sd">        This function is especially useful after using *cut_piece* to </span>
<span class="sd">        create slabs, rods, or ribbons.</span>

<span class="sd">        By default, the new nonperiodic vector is constructed</span>
<span class="sd">        from the original by removing all components in the periodic </span>
<span class="sd">        space.  This ensures that the Berry phases computed in the </span>
<span class="sd">        periodic space correspond to the usual expectations.  For </span>
<span class="sd">        example, after this change, the Berry phase computed for a </span>
<span class="sd">        ribbon depends only on the location of the Wannier center </span>
<span class="sd">        in the extended direction, not on its location in the </span>
<span class="sd">        transverse direction. Alternatively, the new nonperiodic </span>
<span class="sd">        vector can be set explicitly via the *new_latt_vec* parameter.</span>

<span class="sd">        See example :ref:`bn_ribbon_berry` for more </span>
<span class="sd">        detail.</span>

<span class="sd">        :param np_dir: Integer specifying which nonperiodic</span>
<span class="sd">          lattice vector to change.</span>

<span class="sd">        :param new_latt_vec: Optional parameter. If *None* (default),</span>
<span class="sd">          the new nonperiodic lattice vector is the same as the</span>
<span class="sd">          original one except that all components in the periodic</span>
<span class="sd">          space have been projected out (so that the new</span>
<span class="sd">          nonperiodic vector is perpendicular to all periodic</span>
<span class="sd">          vectors).  Otherwise, array of integers with size *dim_r*</span>
<span class="sd">          defining the desired new nonperiodic lattice vector.</span>

<span class="sd">        :param to_home: Optional parameter. If *True* (default),</span>
<span class="sd">          will shift all orbitals to the home cell along non-periodic directions.</span>

<span class="sd">        :param to_home_suppress_warning: Optional parameter, if *False* code</span>
<span class="sd">          will print a warning message whenever returned object has an orbital with</span>
<span class="sd">          at least one reduced coordinate smaller than 0 or larger than 1</span>
<span class="sd">          along a non-periodic direction.  If *True* the warning message</span>
<span class="sd">          will not be printed.  Note that this parameter has no</span>
<span class="sd">          effect on the model; it only determines whether a warning</span>
<span class="sd">          message is printed or not.  Default value is *False*.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **nnp_tb** -- Object of type :class:`pythtb.tb_model`</span>
<span class="sd">            representing an equivalent tight-binding model with</span>
<span class="sd">            one redefined nonperiodic lattice vector.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Modify slab model so that nonperiodic third vector is perpendicular to the slab</span>
<span class="sd">          nnp_tb = tb.change_nonperiodic_vector(2)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that selected direction is nonperiodic</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">np_dir</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">np_dir =&quot;</span><span class="p">,</span><span class="n">np_dir</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Selected direction is not nonperiodic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_latt_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># construct new nonperiodic lattice vector</span>
            <span class="n">per_temp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">direc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
                <span class="n">per_temp</span><span class="p">[</span><span class="n">direc</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">direc</span><span class="p">]</span>
            <span class="c1"># find projection coefficients onto space of periodic vectors</span>
            <span class="n">coeffs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">per_temp</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">np_dir</span><span class="p">],</span><span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">projec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">coeffs</span><span class="p">)</span>
            <span class="c1"># subtract off to get new nonperiodic vector</span>
            <span class="n">np_lattice_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">np_dir</span><span class="p">]</span><span class="o">-</span><span class="n">projec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># new_latt_vec is passed as argument</span>
            <span class="c1"># check shape and convert to numpy array</span>
            <span class="n">np_lattice_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_latt_vec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np_lattice_vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Nonperiodic vector has wrong length&quot;</span><span class="p">)</span>

        <span class="c1"># define new set of lattice vectors</span>
        <span class="n">np_lat</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
        <span class="n">np_lat</span><span class="p">[</span><span class="n">np_dir</span><span class="p">]</span><span class="o">=</span><span class="n">np_lattice_vec</span>

        <span class="c1"># convert reduced vector in original lattice to reduced vector in new cell lattice</span>
        <span class="n">np_orb</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">:</span> <span class="c1"># go over all orbitals</span>
            <span class="n">orb_cart</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">orb</span><span class="p">)</span>
            <span class="c1"># convert to reduced coordinates</span>
            <span class="n">np_orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">orb_cart</span><span class="p">))</span>

        <span class="c1"># create new tb_model object to be returned</span>
        <span class="n">nnp_tb</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># update lattice vectors and orbitals</span>
        <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np_lat</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_orb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np_orb</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># double check that everything went as planned</span>
        <span class="c1">#</span>
        <span class="c1"># is the new vector perpendicular to all periodic directions?</span>
        <span class="k">if</span> <span class="n">new_latt_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">np_dir</span><span class="p">]))</span><span class="o">&gt;</span><span class="mf">1.0E-6</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span><span class="s2">This shouldn&#39;t happen.  New nonperiodic vector </span>
<span class="s2">is not perpendicular to periodic vectors!?&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="c1"># are cartesian coordinates of orbitals the same in two cases?</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">cart_old</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">cart_new</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">nnp_tb</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cart_old</span><span class="o">-</span><span class="n">cart_new</span><span class="p">))</span><span class="o">&gt;</span><span class="mf">1.0E-6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span><span class="s2">This shouldn&#39;t happen. New choice of nonperiodic vector</span>
<span class="s2">somehow changed Cartesian coordinates of orbitals.&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="c1"># check that volume of the cell is not zero</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1.0E-6</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Lattice with new choice of nonperiodic vector has zero volume?!&quot;</span><span class="p">)</span>

        <span class="c1"># put orbitals to home cell if asked for</span>
        <span class="k">if</span> <span class="n">to_home</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_shift_to_home</span><span class="p">(</span><span class="n">to_home_suppress_warning</span><span class="p">)</span>
        
        <span class="c1"># return new tb model</span>
        <span class="k">return</span> <span class="n">nnp_tb</span></div>

    
<div class="viewcode-block" id="tb_model.make_supercell">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.make_supercell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc_red_lat</span><span class="p">,</span> <span class="n">return_sc_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">to_home</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">to_home_suppress_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns tight-binding model :class:`pythtb.tb_model`</span>
<span class="sd">        representing a super-cell of a current object. This function</span>
<span class="sd">        can be used together with *cut_piece* in order to create slabs</span>
<span class="sd">        with arbitrary surfaces.</span>

<span class="sd">        By default all orbitals will be shifted to the home cell after</span>
<span class="sd">        unit cell has been created. That way all orbitals will have</span>
<span class="sd">        reduced coordinates between 0 and 1. If you wish to avoid this</span>
<span class="sd">        behavior, you need to set, *to_home* argument to *False*.</span>

<span class="sd">        :param sc_red_lat: Array of integers with size *dim_r*dim_r*</span>
<span class="sd">          defining a super-cell lattice vectors in terms of reduced</span>
<span class="sd">          coordinates of the original tight-binding model. First index</span>
<span class="sd">          in the array specifies super-cell vector, while second index</span>
<span class="sd">          specifies coordinate of that super-cell vector.  If</span>
<span class="sd">          *dim_k&lt;dim_r* then still need to specify full array with</span>
<span class="sd">          size *dim_r*dim_r* for consistency, but non-periodic</span>
<span class="sd">          directions must have 0 on off-diagonal elemets s and 1 on</span>
<span class="sd">          diagonal.</span>

<span class="sd">        :param return_sc_vectors: Optional parameter. Default value is</span>
<span class="sd">          *False*. If *True* returns also lattice vectors inside the</span>
<span class="sd">          super-cell. Internally, super-cell tight-binding model will</span>
<span class="sd">          have orbitals repeated in the same order in which these</span>
<span class="sd">          super-cell vectors are given, but if argument *to_home*</span>
<span class="sd">          is set *True* (which it is by default) then additionally,</span>
<span class="sd">          orbitals will be shifted to the home cell.</span>

<span class="sd">        :param to_home: Optional parameter, if *True* will shift all orbitals </span>
<span class="sd">          to the home cell along non-periodic directions. Default value is *True*.</span>

<span class="sd">        :param to_home_suppress_warning: Optional parameter, if *False* code</span>
<span class="sd">          will print a warning message whenever returned object has an orbital with</span>
<span class="sd">          at least one reduced coordinate smaller than 0 or larger than 1</span>
<span class="sd">          along a non-periodic direction.  If *True* the warning message</span>
<span class="sd">          will not be printed.  Note that setting this parameter to *True*</span>
<span class="sd">          or *False* has no effect on resulting coordinates of the model.</span>
<span class="sd">          The only difference between this parameter set to *True* or *False*</span>
<span class="sd">          is whether a warning message is printed or not.  Default value</span>
<span class="sd">          is *False*.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **sc_tb** -- Object of type :class:`pythtb.tb_model`</span>
<span class="sd">            representing a tight-binding model in a super-cell.</span>

<span class="sd">          * **sc_vectors** -- Super-cell vectors, returned only if</span>
<span class="sd">            *return_sc_vectors* is set to *True* (default value is</span>
<span class="sd">            *False*).</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Creates super-cell out of 2d tight-binding model tb</span>
<span class="sd">          sc_tb = tb.make_supercell([[2, 1], [-1, 2]])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Can&#39;t make super cell for model without periodic directions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Must have at least one periodic direction to make a super-cell&quot;</span><span class="p">)</span>
        
        <span class="c1"># convert array to numpy array</span>
        <span class="n">use_sc_red_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sc_red_lat</span><span class="p">)</span>
        
        <span class="c1"># checks on super-lattice array</span>
        <span class="k">if</span> <span class="n">use_sc_red_lat</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Dimension of sc_red_lat array must be dim_r*dim_r&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_sc_red_lat</span><span class="o">.</span><span class="n">dtype</span><span class="o">!=</span><span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">sc_red_lat array elements must be integers&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_sc_red_lat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Diagonal elements of sc_red_lat for non-periodic directions must equal 1.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">))</span> <span class="ow">and</span> <span class="n">use_sc_red_lat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Off-diagonal elements of sc_red_lat for non-periodic directions must equal 0.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1.0E-6</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Super-cell lattice vectors length/area/volume too close to zero, or zero.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Super-cell lattice vectors need to form right handed system.&quot;</span><span class="p">)</span>

        <span class="c1"># converts reduced vector in original lattice to reduced vector in super-cell lattice</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">to_red_sc</span><span class="p">(</span><span class="n">red_vec_orig</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">red_vec_orig</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>

        <span class="c1"># conservative estimate on range of search for super-cell vectors</span>
        <span class="n">max_R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span>

        <span class="c1"># candidates for super-cell vectors</span>
        <span class="c1"># this is hard-coded and can be improved!</span>
        <span class="n">sc_cands</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">sc_cands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">sc_cands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">sc_cands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span><span class="n">max_R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">sc_cands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong dimensionality of dim_r!&quot;</span><span class="p">)</span>

        <span class="c1"># find all vectors inside super-cell</span>
        <span class="c1"># store them here</span>
        <span class="n">sc_vec</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">eps_shift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0E-8</span> <span class="c1"># shift of the grid, so to avoid double counting</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">sc_cands</span><span class="p">:</span>
            <span class="c1"># compute reduced coordinates of this candidate vector in the super-cell frame</span>
            <span class="n">tmp_red</span><span class="o">=</span><span class="n">to_red_sc</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># check if in the interior</span>
            <span class="n">inside</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tmp_red</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">&lt;=-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">eps_shift</span> <span class="ow">or</span> <span class="n">t</span><span class="o">&gt;</span><span class="mf">1.0</span><span class="o">-</span><span class="n">eps_shift</span><span class="p">:</span>
                    <span class="n">inside</span><span class="o">=</span><span class="kc">False</span>                
            <span class="k">if</span> <span class="n">inside</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="n">sc_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span>
        <span class="c1"># number of times unit cell is repeated in the super-cell</span>
        <span class="n">num_sc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">sc_vec</span><span class="p">)</span>

        <span class="c1"># check that found enough super-cell vectors</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">))))</span><span class="o">!=</span><span class="n">num_sc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Super-cell generation failed! Wrong number of super-cell vectors found.&quot;</span><span class="p">)</span>

        <span class="c1"># cartesian vectors of the super lattice</span>
        <span class="n">sc_cart_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>

        <span class="c1"># orbitals of the super-cell tight-binding model</span>
        <span class="n">sc_orb</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">cur_sc_vec</span> <span class="ow">in</span> <span class="n">sc_vec</span><span class="p">:</span> <span class="c1"># go over all super-cell vectors</span>
            <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">:</span> <span class="c1"># go over all orbitals</span>
                <span class="c1"># shift orbital and compute coordinates in</span>
                <span class="c1"># reduced coordinates of super-cell</span>
                <span class="n">sc_orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_red_sc</span><span class="p">(</span><span class="n">orb</span><span class="o">+</span><span class="n">cur_sc_vec</span><span class="p">))</span>

        <span class="c1"># create super-cell tb_model object to be returned</span>
        <span class="n">sc_tb</span><span class="o">=</span><span class="n">tb_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span><span class="n">sc_cart_lat</span><span class="p">,</span><span class="n">sc_orb</span><span class="p">,</span><span class="n">per</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">,</span><span class="n">nspin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span>

        <span class="c1"># remember if came from w90</span>
        <span class="n">sc_tb</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span>

        <span class="c1"># repeat onsite energies</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sc</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
                <span class="n">sc_tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>

        <span class="c1"># set hopping terms</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">cur_sc_vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sc_vec</span><span class="p">):</span> <span class="c1"># go over all super-cell vectors</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)):</span> <span class="c1"># go over all hopping terms of the original model</span>
                <span class="c1"># amplitude of the hop is the same</span>
                <span class="n">amp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># lattice vector of the hopping</span>
                <span class="n">ind_R</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="c1"># super-cell component of hopping lattice vector</span>
                <span class="c1"># shift also by current super cell vector</span>
                <span class="n">sc_part</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">to_red_sc</span><span class="p">(</span><span class="n">ind_R</span><span class="o">+</span><span class="n">cur_sc_vec</span><span class="p">))</span> <span class="c1"># round down!</span>
                <span class="n">sc_part</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sc_part</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="c1"># find remaining vector in the original reduced coordinates</span>
                <span class="n">orig_part</span><span class="o">=</span><span class="n">ind_R</span><span class="o">+</span><span class="n">cur_sc_vec</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sc_part</span><span class="p">,</span><span class="n">use_sc_red_lat</span><span class="p">)</span>
                <span class="c1"># remaining vector must equal one of the super-cell vectors</span>
                <span class="n">pair_ind</span><span class="o">=</span><span class="kc">None</span>
                <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">pair_sc_vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sc_vec</span><span class="p">):</span>
                    <span class="k">if</span> <span class="kc">False</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">pair_sc_vec</span><span class="o">==</span><span class="n">orig_part</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">pair_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Found duplicate super cell vector!&quot;</span><span class="p">)</span>
                        <span class="n">pair_ind</span><span class="o">=</span><span class="n">p</span>
                <span class="k">if</span> <span class="n">pair_ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Did not find super cell vector!&quot;</span><span class="p">)</span>
                        
                <span class="c1"># index of &quot;from&quot; and &quot;to&quot; hopping indices</span>
                <span class="n">hi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>
                <span class="n">hj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pair_ind</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>
                
                <span class="c1"># add hopping term</span>
                <span class="n">sc_tb</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span><span class="n">hi</span><span class="p">,</span><span class="n">hj</span><span class="p">,</span><span class="n">sc_part</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span><span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># put orbitals to home cell if asked for</span>
        <span class="k">if</span> <span class="n">to_home</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">sc_tb</span><span class="o">.</span><span class="n">_shift_to_home</span><span class="p">(</span><span class="n">to_home_suppress_warning</span><span class="p">)</span>

        <span class="c1"># return new tb model and vectors if needed</span>
        <span class="k">if</span> <span class="n">return_sc_vectors</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sc_tb</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sc_tb</span><span class="p">,</span><span class="n">sc_vec</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_shift_to_home</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_home_suppress_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shifts orbital coordinates (along periodic directions) to the home</span>
<span class="sd">        unit cell. After this function is called reduced coordinates</span>
<span class="sd">        (along periodic directions) of orbitals will be between 0 and</span>
<span class="sd">        1.  </span>

<span class="sd">        Version of pythtb 1.7.2 (and earlier) was shifting orbitals to</span>
<span class="sd">        home along even nonperiodic directions.  In the later versions</span>
<span class="sd">        of the code (this present version, and future versions) we</span>
<span class="sd">        don&#39;t allow this anymore, as this feature might produce</span>
<span class="sd">        counterintuitive results.  Shifting orbitals along nonperiodic</span>
<span class="sd">        directions changes physical nature of the tight-binding model.</span>
<span class="sd">        This behavior might be especially non-intuitive for</span>
<span class="sd">        tight-binding models that came from the *cut_piece* function.</span>

<span class="sd">        :param to_home_suppress_warning: Optional parameter, if *False* code</span>
<span class="sd">          will print a warning message whenever there is an orbital with</span>
<span class="sd">          at least one reduced coordinate smaller than 0 or larger than 1</span>
<span class="sd">          along a non-periodic direction.  If *True* the warning message </span>
<span class="sd">          will not be printed.  Note that setting this parameter to *True*</span>
<span class="sd">          or *False* has no effect on resulting coordinates of the model.</span>
<span class="sd">          The only difference between this parameter set to *True* or *False*</span>
<span class="sd">          is whether a warning message is printed or not.  Default value </span>
<span class="sd">          is *False*.        </span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># create list of emty lists (one for each real-space direction)</span>
        <span class="n">warning_list</span><span class="o">=</span><span class="p">[[]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span>
        <span class="c1"># go over all orbitals</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
            <span class="c1"># find displacement vector needed to bring back to home cell</span>
            <span class="n">disp_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># shift only in periodic directions</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
                <span class="n">shift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="mf">1.0E-6</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
                    <span class="n">disp_vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">shift</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># check for shift in non-periodic directions</span>
                    <span class="k">if</span> <span class="n">shift</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">warning_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">warning_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># print warning message if needed</span>
        <span class="k">if</span> <span class="n">to_home_suppress_warning</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">warn_str</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
                <span class="n">orbs</span><span class="o">=</span><span class="n">warning_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">orbs</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">orb_str</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">)</span>
                    <span class="n">warn_str</span><span class="o">+=</span><span class="s2">&quot;  * Direction </span><span class="si">%1d</span><span class="s2"> : Orbitals &quot;</span><span class="o">%</span><span class="n">k</span><span class="o">+</span><span class="n">orb_str</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">warn_str</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="o">+</span><span class="mi">69</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">  WARNING from &#39;_shift_to_home&#39; (called by &#39;change_nonperiodic_vector&#39;</span>
<span class="s2">  or &#39;make_supercell&#39;): Orbitals are not &quot;shifted to home&quot; along</span>
<span class="s2">  non-periodic directions.  Older versions of PythTb (1.7.2 and older)</span>
<span class="s2">  allowed this, but it changes the physical nature of the tight-binding</span>
<span class="s2">  model.  PythTB 1.7.3 and newer versions of PythTb no longer shift</span>
<span class="s2">  orbitals along non-periodic directions.</span>
<span class="s2">  *</span>
<span class="s2">  In the present case, the following orbitals would have been assigned</span>
<span class="s2">  different coordinates in PythTb 1.7.2 and older:</span>
<span class="s2">  *</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span><span class="o">+</span><span class="n">warn_str</span><span class="o">+</span><span class="s2">&quot;&quot;&quot;  *</span>
<span class="s2">  To prevent printing this warning, call &#39;change_nonperiodic_vector&#39;</span>
<span class="s2">  or &#39;make_supercell&#39; with &#39;to_home_suppress_warning=True&#39;.</span>
<span class="s2">  *</span>
<span class="s2">  This warning message will be removed in future versions of PythTb.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">+</span><span class="s1">&#39;  &#39;</span><span class="o">+</span><span class="mi">69</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># shift orbitals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-=</span><span class="n">disp_vec</span>
            <span class="c1"># shift hoppings</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">-=</span><span class="n">disp_vec</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">+=</span><span class="n">disp_vec</span>
                            

<div class="viewcode-block" id="tb_model.remove_orb">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.remove_orb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_orb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">to_remove</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns a model with some orbitals removed.  Note that this</span>
<span class="sd">        will reindex the orbitals with indices higher than those that</span>
<span class="sd">        are removed.  For example.  If model has 6 orbitals and one</span>
<span class="sd">        wants to remove 2nd orbital, then returned model will have 5</span>
<span class="sd">        orbitals indexed as 0,1,2,3,4.  In the returned model orbital</span>
<span class="sd">        indexed as 2 corresponds to the one indexed as 3 in the</span>
<span class="sd">        original model.  Similarly 3 and 4 correspond to 4 and 5.</span>
<span class="sd">        Indices of first two orbitals (0 and 1) are unaffected.</span>

<span class="sd">        :param to_remove: List of orbital indices to be removed, or </span>
<span class="sd">          index of single orbital to be removed</span>

<span class="sd">        :returns:</span>

<span class="sd">          * **del_tb** -- Object of type :class:`pythtb.tb_model` </span>
<span class="sd">            representing a model with removed orbitals.</span>

<span class="sd">        Example usage::</span>
<span class="sd">        </span>
<span class="sd">          # if original_model has say 10 orbitals then</span>
<span class="sd">          # returned small_model will have only 8 orbitals.</span>

<span class="sd">          small_model=original_model.remove_orb([2,5])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if a single integer is given, convert to a list with one element</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">to_remove</span><span class="p">):</span>
            <span class="n">orb_index</span><span class="o">=</span><span class="p">[</span><span class="n">to_remove</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orb_index</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>

        <span class="c1"># check range of indices</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">orb_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orb_index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">orb_ind</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">orb_ind</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">orb_ind</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Specified wrong orbitals to remove!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ind1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orb_index</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">orb_index</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="n">ind1</span><span class="o">==</span><span class="n">ind2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Specified duplicate orbitals to remove!&quot;</span><span class="p">)</span>

        <span class="c1"># put the orbitals to be removed in desceding order</span>
        <span class="n">orb_index</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">orb_index</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># make copy of a model</span>
        <span class="n">ret</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># adjust some variables in the new model</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_norb</span><span class="o">-=</span><span class="nb">len</span><span class="p">(</span><span class="n">orb_index</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_nsta</span><span class="o">-=</span><span class="nb">len</span><span class="p">(</span><span class="n">orb_index</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="c1"># remove indices one by one</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">orb_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orb_index</span><span class="p">):</span>
            <span class="c1"># adjust variables</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_orb</span><span class="p">,</span><span class="n">orb_ind</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_site_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">,</span><span class="n">orb_ind</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_site_energies_specified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">,</span><span class="n">orb_ind</span><span class="p">)</span>
            <span class="c1"># adjust hopping terms (in reverse)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">h</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1"># remove all terms that involve this orbital</span>
                <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">orb_ind</span> <span class="ow">or</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">orb_ind</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># otherwise modify term</span>
                    <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">orb_ind</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="n">orb_ind</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
        <span class="c1"># return new model</span>
        <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="tb_model.k_uniform_mesh">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.k_uniform_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">k_uniform_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh_size</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Returns a uniform grid of k-points that can be passed to</span>
<span class="sd">        passed to function :func:`pythtb.tb_model.solve_all`.  This</span>
<span class="sd">        function is useful for plotting density of states histogram</span>
<span class="sd">        and similar.</span>

<span class="sd">        Returned uniform grid of k-points always contains the origin.</span>

<span class="sd">        :param mesh_size: Number of k-points in the mesh in each</span>
<span class="sd">          periodic direction of the model.</span>
<span class="sd">          </span>
<span class="sd">        :returns:</span>

<span class="sd">          * **k_vec** -- Array of k-vectors on the mesh that can be</span>
<span class="sd">            directly passed to function  :func:`pythtb.tb_model.solve_all`.</span>

<span class="sd">        Example usage::</span>
<span class="sd">          </span>
<span class="sd">          # returns a 10x20x30 mesh of a tight binding model</span>
<span class="sd">          # with three periodic directions</span>
<span class="sd">          k_vec = my_model.k_uniform_mesh([10,20,30])</span>
<span class="sd">          # solve model on the uniform mesh</span>
<span class="sd">          my_model.solve_all(k_vec)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># get the mesh size and checks for consistency</span>
        <span class="n">use_mesh</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">round</span><span class="p">,</span><span class="n">mesh_size</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_mesh</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">,):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">use_mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Incorrect size of the specified k-mesh!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">use_mesh</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Mesh must have positive non-zero number of elements.&quot;</span><span class="p">)</span>

        <span class="c1"># construct the mesh</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># get a mesh</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># normalize the mesh</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">use_mesh</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span><span class="n">use_mesh</span><span class="p">)</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">use_mesh</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">k_vec</span><span class="o">/</span><span class="n">norm</span>
            <span class="c1"># final reshape</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">k_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># get a mesh</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">:</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># normalize the mesh</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">use_mesh</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span><span class="n">use_mesh</span><span class="p">)</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">use_mesh</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">k_vec</span><span class="o">/</span><span class="n">norm</span>
            <span class="c1"># final reshape</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">k_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="c1"># get a mesh</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">:</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">:</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># normalize the mesh</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">use_mesh</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span><span class="n">use_mesh</span><span class="p">)</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">use_mesh</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">k_vec</span><span class="o">/</span><span class="n">norm</span>
            <span class="c1"># final reshape</span>
            <span class="n">k_vec</span><span class="o">=</span><span class="n">k_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">use_mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Unsupported dim_k!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">k_vec</span></div>


<div class="viewcode-block" id="tb_model.k_path">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.k_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">k_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">kpts</span><span class="p">,</span><span class="n">nk</span><span class="p">,</span><span class="n">report</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">        Interpolates a path in reciprocal space between specified</span>
<span class="sd">        k-points.  In 2D or 3D the k-path can consist of several</span>
<span class="sd">        straight segments connecting high-symmetry points (&quot;nodes&quot;),</span>
<span class="sd">        and the results can be used to plot the bands along this path.</span>
<span class="sd">        </span>
<span class="sd">        The interpolated path that is returned contains as</span>
<span class="sd">        equidistant k-points as possible.</span>
<span class="sd">    </span>
<span class="sd">        :param kpts: Array of k-vectors in reciprocal space between</span>
<span class="sd">          which interpolated path should be constructed. These</span>
<span class="sd">          k-vectors must be given in reduced coordinates.  As a</span>
<span class="sd">          special case, in 1D k-space kpts may be a string:</span>
<span class="sd">    </span>
<span class="sd">          * *&quot;full&quot;*  -- Implies  *[ 0.0, 0.5, 1.0]*  (full BZ)</span>
<span class="sd">          * *&quot;fullc&quot;* -- Implies  *[-0.5, 0.0, 0.5]*  (full BZ, centered)</span>
<span class="sd">          * *&quot;half&quot;*  -- Implies  *[ 0.0, 0.5]*  (half BZ)</span>
<span class="sd">    </span>
<span class="sd">        :param nk: Total number of k-points to be used in making the plot.</span>
<span class="sd">        </span>
<span class="sd">        :param report: Optional parameter specifying whether printout</span>
<span class="sd">          is desired (default is True).</span>

<span class="sd">        :returns:</span>

<span class="sd">          * **k_vec** -- Array of (nearly) equidistant interpolated</span>
<span class="sd">            k-points. The distance between the points is calculated in</span>
<span class="sd">            the Cartesian frame, however coordinates themselves are</span>
<span class="sd">            given in dimensionless reduced coordinates!  This is done</span>
<span class="sd">            so that this array can be directly passed to function</span>
<span class="sd">            :func:`pythtb.tb_model.solve_all`.</span>

<span class="sd">          * **k_dist** -- Array giving accumulated k-distance to each</span>
<span class="sd">            k-point in the path.  Unlike array *k_vec* this one has</span>
<span class="sd">            dimensions! (Units are defined here so that for an</span>
<span class="sd">            one-dimensional crystal with lattice constant equal to for</span>
<span class="sd">            example *10* the length of the Brillouin zone would equal</span>
<span class="sd">            *1/10=0.1*.  In other words factors of :math:`2\pi` are</span>
<span class="sd">            absorbed into *k*.) This array can be used to plot path in</span>
<span class="sd">            the k-space so that the distances between the k-points in</span>
<span class="sd">            the plot are exact.</span>

<span class="sd">          * **k_node** -- Array giving accumulated k-distance to each</span>
<span class="sd">            node on the path in Cartesian coordinates.  This array is</span>
<span class="sd">            typically used to plot nodes (typically special points) on</span>
<span class="sd">            the path in k-space.</span>
<span class="sd">    </span>
<span class="sd">        Example usage::</span>
<span class="sd">    </span>
<span class="sd">          # Construct a path connecting four nodal points in k-space</span>
<span class="sd">          # Path will contain 401 k-points, roughly equally spaced</span>
<span class="sd">          path = [[0.0, 0.0], [0.0, 0.5], [0.5, 0.5], [0.0, 0.0]]</span>
<span class="sd">          (k_vec,k_dist,k_node) = my_model.k_path(path,401)</span>
<span class="sd">          # solve for eigenvalues on that path</span>
<span class="sd">          evals = tb.solve_all(k_vec)</span>
<span class="sd">          # then use evals, k_dist, and k_node to plot bandstructure</span>
<span class="sd">          # (see examples)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1"># processing of special cases for kpts</span>
        <span class="k">if</span> <span class="n">kpts</span><span class="o">==</span><span class="s1">&#39;full&#39;</span><span class="p">:</span>
            <span class="c1"># full Brillouin zone for 1D case</span>
            <span class="n">k_list</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">],[</span><span class="mf">1.</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="n">kpts</span><span class="o">==</span><span class="s1">&#39;fullc&#39;</span><span class="p">:</span>
            <span class="c1"># centered full Brillouin zone for 1D case</span>
            <span class="n">k_list</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">],[</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="n">kpts</span><span class="o">==</span><span class="s1">&#39;half&#39;</span><span class="p">:</span>
            <span class="c1"># half Brillouin zone for 1D case</span>
            <span class="n">k_list</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k_list</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
    
        <span class="c1"># in 1D case if path is specified as a vector, convert it to an (n,1) array</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_list</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">k_list</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k_list</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># make sure that k-points in the path have correct dimension</span>
        <span class="k">if</span> <span class="n">k_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;input k-space dimension is&#39;</span><span class="p">,</span><span class="n">k_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k-space dimension taken from model is&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">k-space dimensions do not match&quot;</span><span class="p">)</span>

        <span class="c1"># must have more k-points in the path than number of nodes</span>
        <span class="k">if</span> <span class="n">nk</span><span class="o">&lt;</span><span class="n">k_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Must have more points in the path than number of nodes.&quot;</span><span class="p">)</span>

        <span class="c1"># number of nodes</span>
        <span class="n">n_nodes</span><span class="o">=</span><span class="n">k_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
        <span class="c1"># extract the lattice vectors from the TB model</span>
        <span class="n">lat_per</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
        <span class="c1"># choose only those that correspond to periodic directions</span>
        <span class="n">lat_per</span><span class="o">=</span><span class="n">lat_per</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span>    
        <span class="c1"># compute k_space metric tensor</span>
        <span class="n">k_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lat_per</span><span class="p">,</span><span class="n">lat_per</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

        <span class="c1"># Find distances between nodes and set k_node, which is</span>
        <span class="c1"># accumulated distance since the start of the path</span>
        <span class="c1">#  initialize array k_node</span>
        <span class="n">k_node</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_nodes</span><span class="p">):</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">k_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">k_list</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dklen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k_metric</span><span class="p">,</span><span class="n">dk</span><span class="p">)))</span>
            <span class="n">k_node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">k_node</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dklen</span>
    
        <span class="c1"># Find indices of nodes in interpolated list</span>
        <span class="n">node_index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">frac</span><span class="o">=</span><span class="n">k_node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">k_node</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">node_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">frac</span><span class="o">*</span><span class="p">(</span><span class="n">nk</span><span class="o">-</span><span class="mi">1</span><span class="p">))))</span>
        <span class="n">node_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nk</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
        <span class="c1"># initialize two arrays temporarily with zeros</span>
        <span class="c1">#   array giving accumulated k-distance to each k-point</span>
        <span class="n">k_dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nk</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1">#   array listing the interpolated k-points    </span>
        <span class="n">k_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
        <span class="c1"># go over all kpoints</span>
        <span class="n">k_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">k_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_nodes</span><span class="p">):</span>
            <span class="n">n_i</span><span class="o">=</span><span class="n">node_index</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_f</span><span class="o">=</span><span class="n">node_index</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">kd_i</span><span class="o">=</span><span class="n">k_node</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">kd_f</span><span class="o">=</span><span class="n">k_node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">k_i</span><span class="o">=</span><span class="n">k_list</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k_f</span><span class="o">=</span><span class="n">k_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_i</span><span class="p">,</span><span class="n">n_f</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">frac</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">n_i</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n_f</span><span class="o">-</span><span class="n">n_i</span><span class="p">)</span>
                <span class="n">k_dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">kd_i</span><span class="o">+</span><span class="n">frac</span><span class="o">*</span><span class="p">(</span><span class="n">kd_f</span><span class="o">-</span><span class="n">kd_i</span><span class="p">)</span>
                <span class="n">k_vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">k_i</span><span class="o">+</span><span class="n">frac</span><span class="o">*</span><span class="p">(</span><span class="n">k_f</span><span class="o">-</span><span class="n">k_i</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">report</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Path in 1D BZ defined by nodes at &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k_list</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----- k_path report begin ----------&#39;</span><span class="p">)</span>
                <span class="n">original</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;real-space lattice vectors</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">lat_per</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k-space metric tensor</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">k_metric</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;internal coordinates of nodes</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">k_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lat_per</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">lat_per</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="c1"># lat_per is invertible</span>
                    <span class="n">lat_per_inv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lat_per</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reciprocal-space lattice vectors</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">lat_per_inv</span><span class="p">)</span>
                    <span class="c1"># cartesian coordinates of nodes</span>
                    <span class="n">kpts_cart</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">k_list</span><span class="p">,</span><span class="n">lat_per_inv</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cartesian coordinates of nodes</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">kpts_cart</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;list of segments:&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_nodes</span><span class="p">):</span>
                    <span class="n">dk</span><span class="o">=</span><span class="n">k_node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">k_node</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dk_str</span><span class="o">=</span><span class="n">_nice_float</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  length = &#39;</span><span class="o">+</span><span class="n">dk_str</span><span class="o">+</span><span class="s1">&#39;  from &#39;</span><span class="p">,</span><span class="n">k_list</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39; to &#39;</span><span class="p">,</span><span class="n">k_list</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;node distance list:&#39;</span><span class="p">,</span> <span class="n">k_node</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;node index list:   &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_index</span><span class="p">))</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">original</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----- k_path report end ------------&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">k_vec</span><span class="p">,</span><span class="n">k_dist</span><span class="p">,</span><span class="n">k_node</span><span class="p">)</span></div>


<div class="viewcode-block" id="tb_model.ignore_position_operator_offdiagonal">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.ignore_position_operator_offdiagonal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ignore_position_operator_offdiagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call to this function enables one to approximately compute</span>
<span class="sd">        Berry-like objects from tight-binding models that were</span>
<span class="sd">        obtained from Wannier90.&quot;&quot;&quot;</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">=</span><span class="kc">True</span></div>


<div class="viewcode-block" id="tb_model.position_matrix">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.position_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evec</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns matrix elements of the position operator along</span>
<span class="sd">        direction *dir* for eigenvectors *evec* at a single k-point.</span>
<span class="sd">        Position operator is defined in reduced coordinates.</span>

<span class="sd">        The returned object :math:`X` is</span>

<span class="sd">        .. math::</span>

<span class="sd">          X_{m n {\bf k}}^{\alpha} = \langle u_{m {\bf k}} \vert</span>
<span class="sd">          r^{\alpha} \vert u_{n {\bf k}} \rangle</span>

<span class="sd">        Here :math:`r^{\alpha}` is the position operator along direction</span>
<span class="sd">        :math:`\alpha` that is selected by *dir*.</span>

<span class="sd">        :param evec: Eigenvectors for which we are computing matrix</span>
<span class="sd">          elements of the position operator.  The shape of this array</span>
<span class="sd">          is evec[band,orbital] if *nspin* equals 1 and</span>
<span class="sd">          evec[band,orbital,spin] if *nspin* equals 2.</span>

<span class="sd">        :param dir: Direction along which we are computing the center.</span>
<span class="sd">          This integer must not be one of the periodic directions</span>
<span class="sd">          since position operator matrix element in that case is not</span>
<span class="sd">          well defined.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **pos_mat** -- Position operator matrix :math:`X_{m n}` as defined </span>
<span class="sd">            above. This is a square matrix with size determined by number of bands</span>
<span class="sd">            given in *evec* input array.  First index of *pos_mat* corresponds to</span>
<span class="sd">            bra vector (*m*) and second index to ket (*n*).</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # diagonalizes Hamiltonian at some k-points</span>
<span class="sd">          (evals, evecs) = my_model.solve_all(k_vec,eig_vectors=True)</span>
<span class="sd">          # computes position operator matrix elements for 3-rd kpoint </span>
<span class="sd">          # and bottom five bands along first coordinate</span>
<span class="sd">          pos_mat = my_model.position_matrix(evecs[:5,2], 0)</span>

<span class="sd">        See also this example: :ref:`haldane_hwf-example`,</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure specified direction is not periodic!</span>
        <span class="k">if</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Can not compute position matrix elements along periodic direction!&quot;</span><span class="p">)</span>
        <span class="c1"># make sure direction is not out of range</span>
        <span class="k">if</span> <span class="nb">dir</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">dir</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Direction out of range!&quot;</span><span class="p">)</span>
        
        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="c1"># get coordinates of orbitals along the specified direction</span>
        <span class="n">pos_tmp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[:,</span><span class="nb">dir</span><span class="p">]</span>
        <span class="c1"># reshape arrays in the case of spinfull calculation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># tile along spin direction if needed</span>
            <span class="n">pos_use</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">pos_tmp</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="c1"># also flatten the state along the spin index</span>
            <span class="n">evec_use</span><span class="o">=</span><span class="n">evec</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">evec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">evec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">evec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>                
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_use</span><span class="o">=</span><span class="n">pos_tmp</span>
            <span class="n">evec_use</span><span class="o">=</span><span class="n">evec</span>

        <span class="c1"># position matrix elements</span>
        <span class="n">pos_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">evec_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">evec_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="c1"># go over all bands</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">evec_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">evec_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">pos_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evec_use</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">pos_use</span><span class="o">*</span><span class="n">evec_use</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="c1"># make sure matrix is hermitian</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos_mat</span><span class="o">-</span><span class="n">pos_mat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">&gt;</span><span class="mf">1.0E-9</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> Position matrix is not hermitian?!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pos_mat</span></div>


<div class="viewcode-block" id="tb_model.position_expectation">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.position_expectation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_expectation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">evec</span><span class="p">,</span><span class="nb">dir</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>

<span class="sd">        Returns diagonal matrix elements of the position operator.</span>
<span class="sd">        These elements :math:`X_{n n}` can be interpreted as an</span>
<span class="sd">        average position of n-th Bloch state *evec[n]* along</span>
<span class="sd">        direction *dir*.  Generally speaking these centers are *not*</span>
<span class="sd">        hybrid Wannier function centers (which are instead</span>
<span class="sd">        returned by :func:`pythtb.tb_model.position_hwf`).</span>
<span class="sd">        </span>
<span class="sd">        See function :func:`pythtb.tb_model.position_matrix` for</span>
<span class="sd">        definition of matrix :math:`X`.</span>

<span class="sd">        :param evec: Eigenvectors for which we are computing matrix</span>
<span class="sd">          elements of the position operator.  The shape of this array</span>
<span class="sd">          is evec[band,orbital] if *nspin* equals 1 and</span>
<span class="sd">          evec[band,orbital,spin] if *nspin* equals 2.</span>

<span class="sd">        :param dir: Direction along which we are computing matrix</span>
<span class="sd">          elements.  This integer must not be one of the periodic</span>
<span class="sd">          directions since position operator matrix element in that</span>
<span class="sd">          case is not well defined.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **pos_exp** -- Diagonal elements of the position operator matrix :math:`X`.</span>
<span class="sd">            Length of this vector is determined by number of bands given in *evec* input </span>
<span class="sd">            array.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # diagonalizes Hamiltonian at some k-points</span>
<span class="sd">          (evals, evecs) = my_model.solve_all(k_vec,eig_vectors=True)</span>
<span class="sd">          # computes average position for 3-rd kpoint </span>
<span class="sd">          # and bottom five bands along first coordinate</span>
<span class="sd">          pos_exp = my_model.position_expectation(evecs[:5,2], 0)</span>

<span class="sd">        See also this example: :ref:`haldane_hwf-example`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="n">pos_exp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pos_exp</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="tb_model.position_hwf">
<a class="viewcode-back" href="../usage.html#pythtb.tb_model.position_hwf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_hwf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">evec</span><span class="p">,</span><span class="nb">dir</span><span class="p">,</span><span class="n">hwf_evec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">basis</span><span class="o">=</span><span class="s2">&quot;orbital&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>

<span class="sd">        Returns eigenvalues and optionally eigenvectors of the</span>
<span class="sd">        position operator matrix :math:`X` in basis of the orbitals</span>
<span class="sd">        or, optionally, of the input wave functions (typically Bloch</span>
<span class="sd">        functions).  The returned eigenvectors can be interpreted as</span>
<span class="sd">        linear combinations of the input states *evec* that have</span>
<span class="sd">        minimal extent (or spread :math:`\Omega` in the sense of</span>
<span class="sd">        maximally localized Wannier functions) along direction</span>
<span class="sd">        *dir*. The eigenvalues are average positions of these</span>
<span class="sd">        localized states.</span>

<span class="sd">        Note that these eigenvectors are not maximally localized</span>
<span class="sd">        Wannier functions in the usual sense because they are</span>
<span class="sd">        localized only along one direction.  They are also not the</span>
<span class="sd">        average positions of the Bloch states *evec*, which are</span>
<span class="sd">        instead computed by :func:`pythtb.tb_model.position_expectation`.</span>

<span class="sd">        See function :func:`pythtb.tb_model.position_matrix` for</span>
<span class="sd">        the definition of the matrix :math:`X`.</span>

<span class="sd">        See also Fig. 3 in Phys. Rev. Lett. 102, 107603 (2009) for a</span>
<span class="sd">        discussion of the hybrid Wannier function centers in the</span>
<span class="sd">        context of a Chern insulator.</span>

<span class="sd">        :param evec: Eigenvectors for which we are computing matrix</span>
<span class="sd">          elements of the position operator.  The shape of this array</span>
<span class="sd">          is evec[band,orbital] if *nspin* equals 1 and</span>
<span class="sd">          evec[band,orbital,spin] if *nspin* equals 2.</span>

<span class="sd">        :param dir: Direction along which we are computing matrix</span>
<span class="sd">          elements.  This integer must not be one of the periodic</span>
<span class="sd">          directions since position operator matrix element in that</span>
<span class="sd">          case is not well defined.</span>

<span class="sd">        :param hwf_evec: Optional boolean variable.  If set to *True* </span>
<span class="sd">          this function will return not only eigenvalues but also </span>
<span class="sd">          eigenvectors of :math:`X`. Default value is *False*.</span>

<span class="sd">        :param basis: Optional parameter. If basis=&quot;wavefunction&quot;, the hybrid</span>
<span class="sd">          Wannier function *hwf_evec* is returned in the basis of the input</span>
<span class="sd">          wave functions.  That is, the elements of hwf[i,j] give the amplitudes</span>
<span class="sd">          of the i-th hybrid Wannier function on the j-th input state.</span>
<span class="sd">          Note that option basis=&quot;bloch&quot; is a synonym for basis=&quot;wavefunction&quot;.</span>
<span class="sd">          If basis=&quot;orbital&quot;, the elements of hwf[i,orb] (or hwf[i,orb,spin]</span>
<span class="sd">          if nspin=2) give the amplitudes of the i-th hybrid Wannier function on</span>
<span class="sd">          the specified basis function.  Default is basis=&quot;orbital&quot;.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **hwfc** -- Eigenvalues of the position operator matrix :math:`X`</span>
<span class="sd">            (also called hybrid Wannier function centers).</span>
<span class="sd">            Length of this vector equals number of bands given in *evec* input </span>
<span class="sd">            array.  Hybrid Wannier function centers are ordered in ascending order.</span>
<span class="sd">            Note that in general *n*-th hwfc does not correspond to *n*-th electronic</span>
<span class="sd">            state *evec*.</span>

<span class="sd">          * **hwf** -- Eigenvectors of the position operator matrix :math:`X`.</span>
<span class="sd">            (also called hybrid Wannier functions).  These are returned only if</span>
<span class="sd">            parameter *hwf_evec* is set to *True*.</span>
<span class="sd">            The shape of this array is [h,x] or [h,x,s] depending on value of *basis*</span>
<span class="sd">            and *nspin*.  If *basis* is &quot;bloch&quot; then x refers to indices of </span>
<span class="sd">            Bloch states *evec*.  If *basis* is &quot;orbital&quot; then *x* (or *x* and *s*)</span>
<span class="sd">            correspond to orbital index (or orbital and spin index if *nspin* is 2).</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # diagonalizes Hamiltonian at some k-points</span>
<span class="sd">          (evals, evecs) = my_model.solve_all(k_vec,eig_vectors=True)</span>
<span class="sd">          # computes hybrid Wannier centers (and functions) for 3-rd kpoint </span>
<span class="sd">          # and bottom five bands along first coordinate</span>
<span class="sd">          (hwfc, hwf) = my_model.position_hwf(evecs[:5,2], 0, hwf_evec=True, basis=&quot;orbital&quot;)</span>

<span class="sd">        See also this example: :ref:`haldane_hwf-example`,</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="c1"># get position matrix</span>
        <span class="n">pos_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span>

        <span class="c1"># diagonalize</span>
        <span class="k">if</span> <span class="n">hwf_evec</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">hwfc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">pos_mat</span><span class="p">)</span>
            <span class="c1"># sort eigenvalues and convert to real numbers</span>
            <span class="n">hwfc</span><span class="o">=</span><span class="n">_nicefy_eig</span><span class="p">(</span><span class="n">hwfc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hwfc</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># find eigenvalues and eigenvectors</span>
            <span class="p">(</span><span class="n">hwfc</span><span class="p">,</span><span class="n">hwf</span><span class="p">)</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">pos_mat</span><span class="p">)</span>
            <span class="c1"># transpose matrix eig since otherwise it is confusing</span>
            <span class="c1"># now eig[i,:] is eigenvector for eval[i]-th eigenvalue</span>
            <span class="n">hwf</span><span class="o">=</span><span class="n">hwf</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># sort evectors, eigenvalues and convert to real numbers</span>
            <span class="p">(</span><span class="n">hwfc</span><span class="p">,</span><span class="n">hwf</span><span class="p">)</span><span class="o">=</span><span class="n">_nicefy_eig</span><span class="p">(</span><span class="n">hwfc</span><span class="p">,</span><span class="n">hwf</span><span class="p">)</span>
            <span class="c1"># convert to right basis</span>
            <span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;wavefunction&quot;</span><span class="p">,</span><span class="s2">&quot;bloch&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">hwfc</span><span class="p">,</span><span class="n">hwf</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;orbital&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">ret_hwf</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="c1"># sum over bloch states to get hwf in orbital basis</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ret_hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">ret_hwf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hwf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">evec</span><span class="p">)</span>
                    <span class="n">hwf</span><span class="o">=</span><span class="n">ret_hwf</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret_hwf</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="c1"># get rid of spin indices</span>
                    <span class="n">evec_use</span><span class="o">=</span><span class="n">evec</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
                    <span class="c1"># sum over states</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ret_hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">ret_hwf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hwf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">evec_use</span><span class="p">)</span>
                    <span class="c1"># restore spin indices</span>
                    <span class="n">hwf</span><span class="o">=</span><span class="n">ret_hwf</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">hwfc</span><span class="p">,</span><span class="n">hwf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Basis must be either &#39;wavefunction&#39;, &#39;bloch&#39;, or &#39;orbital&#39;&quot;</span><span class="p">)</span></div>
</div>



<span class="c1">#=======================================================================</span>
<div class="viewcode-block" id="wf_array">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">wf_array</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1">#=======================================================================</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This class is used to store and manipulate an array of</span>
<span class="sd">    wavefunctions of a tight-binding model</span>
<span class="sd">    :class:`pythtb.tb_model` on a regular or non-regular grid</span>
<span class="sd">    These are typically the Bloch energy eigenstates of the</span>
<span class="sd">    model, but this class can also be used to store a subset</span>
<span class="sd">    of Bloch bands, a set of hybrid Wannier functions for a</span>
<span class="sd">    ribbon or slab, or any other set of wavefunctions that</span>
<span class="sd">    are expressed in terms of the underlying basis orbitals.</span>
<span class="sd">    It provides methods that can be used to calculate Berry </span>
<span class="sd">    phases, Berry curvatures, 1st Chern numbers, etc.</span>

<span class="sd">    *Regular k-space grid*:</span>
<span class="sd">    If the grid is a regular k-mesh (no parametric dimensions),</span>
<span class="sd">    a single call to the function</span>
<span class="sd">    :func:`pythtb.wf_array.solve_on_grid` will both construct a</span>
<span class="sd">    k-mesh that uniformly covers the Brillouin zone, and populate</span>
<span class="sd">    it with wavefunctions (eigenvectors) computed on this grid.</span>
<span class="sd">    The last point in each k-dimension is set so that it represents</span>
<span class="sd">    the same Bloch function as the first one (this involves the</span>
<span class="sd">    insertion of some orbital-position-dependent phase factors).</span>

<span class="sd">    Example :ref:`haldane_bp-example` shows how to use wf_array on</span>
<span class="sd">    a regular grid of points in k-space. Examples :ref:`cone-example`</span>
<span class="sd">    and :ref:`3site_cycle-example` show how to use non-regular grid of</span>
<span class="sd">    points.</span>

<span class="sd">    *Parametric or irregular k-space grid grid*:</span>
<span class="sd">    An irregular grid of points, or a grid that includes also</span>
<span class="sd">    one or more parametric dimensions, can be populated manually</span>
<span class="sd">    with the help of the *[]* operator.  For example, to copy</span>
<span class="sd">    eigenvectors *evec* into coordinate (2,3) in the *wf_array*</span>
<span class="sd">    object *wf* one can simply do::</span>

<span class="sd">      wf[2,3]=evec</span>

<span class="sd">    The wavefunctions (here the eigenvectors) *evec* above</span>
<span class="sd">    are expected to be in the format *evec[state,orbital]*</span>
<span class="sd">    (or *evec[state,orbital,spin]* for the spinfull calculation),</span>
<span class="sd">    where *state* typically runs over all bands.</span>
<span class="sd">    This is the same format as returned by</span>
<span class="sd">    :func:`pythtb.tb_model.solve_one` or</span>
<span class="sd">    :func:`pythtb.tb_model.solve_all` (in the latter case one</span>
<span class="sd">    needs to restrict it to a single k-point as *evec[:,kpt,:]*</span>
<span class="sd">    if the model has *dim_k&gt;=1*).</span>

<span class="sd">    If wf_array is used for closed paths, either in a</span>
<span class="sd">    reciprocal-space or parametric direction, then one needs to</span>
<span class="sd">    include both the starting and ending eigenfunctions even though</span>
<span class="sd">    they are physically equivalent.  If the array dimension in</span>
<span class="sd">    question is a k-vector direction and the path traverses the</span>
<span class="sd">    Brillouin zone in a primitive reciprocal-lattice direction,</span>
<span class="sd">    :func:`pythtb.wf_array.impose_pbc` can be used to associate</span>
<span class="sd">    the starting and ending points with each other; if it is a</span>
<span class="sd">    non-winding loop in k-space or a loop in parameter space,</span>
<span class="sd">    then :func:`pythtb.wf_array.impose_loop` can be used instead.</span>
<span class="sd">    (These may not be necessary if only Berry fluxes are needed.)</span>

<span class="sd">    Example :ref:`3site_cycle-example` shows how one</span>
<span class="sd">    of the directions of *wf_array* object need not be a k-vector</span>
<span class="sd">    direction, but can instead be a Hamiltonian parameter :math:`\lambda`</span>
<span class="sd">    (see also discussion after equation 4.1 in :download:`notes on</span>
<span class="sd">    tight-binding formalism &lt;misc/pythtb-formalism.pdf&gt;`).</span>

<span class="sd">    The wavevectors stored in *wf_array* are typically Hamiltonian</span>
<span class="sd">    eigenstates (e.g., Bloch functions for k-space arrays),</span>
<span class="sd">    with the *state* index running over all bands.  However, a</span>
<span class="sd">    *wf_array* object can also be used for other purposes, such</span>
<span class="sd">    as to store only a restricted set of Bloch states (e.g.,</span>
<span class="sd">    just the occupied ones); a set of modified Bloch states</span>
<span class="sd">    (e.g., premultiplied by a position, velocity, or Hamiltonian</span>
<span class="sd">    operator); or for hybrid Wannier functions (i.e., eigenstates</span>
<span class="sd">    of a position operator in a nonperiodic direction).  For an</span>
<span class="sd">    example of this kind, see :ref:`cubic_slab_hwf`.</span>

<span class="sd">    :param model: Object of type :class:`pythtb.tb_model` representing</span>
<span class="sd">      tight-binding model associated with this array of eigenvectors.</span>

<span class="sd">    :param mesh_arr: List of dimensions of the mesh of the *wf_array*,</span>
<span class="sd">      in order of reciprocal-space and/or parametric directions.</span>

<span class="sd">    :param nsta_arr: Optional parameter specifying the number of states</span>
<span class="sd">      packed into the *wf_array* at each point on the mesh.  Defaults</span>
<span class="sd">      to all states (i.e., norb*nspin).</span>

<span class="sd">    Example usage::</span>

<span class="sd">      # Construct wf_array capable of storing an 11x21 array of</span>
<span class="sd">      # wavefunctions      </span>
<span class="sd">      wf = wf_array(tb, [11, 21])</span>
<span class="sd">      # populate this wf_array with regular grid of points in</span>
<span class="sd">      # Brillouin zone</span>
<span class="sd">      wf.solve_on_grid([0.0, 0.0])</span>
<span class="sd">      </span>
<span class="sd">      # Compute set of eigenvectors at one k-point</span>
<span class="sd">      (eval, evec) = tb.solve_one([kx, ky], eig_vectors = True)</span>
<span class="sd">      # Store it manually into a specified location in the array</span>
<span class="sd">      wf[3,4] = evec</span>
<span class="sd">      # To access the eigenvectors from the same position</span>
<span class="sd">      print(wf[3,4])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">mesh_arr</span><span class="p">,</span><span class="n">nsta_arr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># number of electronic states for each k-point</span>
        <span class="k">if</span> <span class="n">nsta_arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">_nsta</span>  <span class="c1"># this = norb*nspin = no. of bands</span>
            <span class="c1"># note: &#39;None&#39; means to use the default, which is all bands!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">nsta_arr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument nsta_arr not an integer&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="o">=</span><span class="n">nsta_arr</span>         <span class="c1"># set by optional argument</span>
        <span class="c1"># number of spin components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="c1"># number of orbitals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">_norb</span>
        <span class="c1"># store orbitals from the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">_orb</span><span class="p">)</span>
        <span class="c1"># store entire model as well</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="c1"># store dimension of array of points on which to keep wavefunctions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_arr</span><span class="p">)</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">)</span>
        <span class="c1"># all dimensions should be 2 or larger, because pbc can be used</span>
        <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Dimension of wf_array object in each direction must be 2 or larger.&quot;</span><span class="p">)</span>
        <span class="c1"># generate temporary array used later to generate object ._wfs</span>
        <span class="n">wfs_dim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">)</span>
        <span class="n">wfs_dim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs_dim</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="p">)</span>
        <span class="n">wfs_dim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs_dim</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">wfs_dim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs_dim</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span>            
        <span class="c1"># store wavefunctions in the form</span>
        <span class="c1">#   _wfs[kx_index,ky_index, ... ,state,orb,spin]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">wfs_dim</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<div class="viewcode-block" id="wf_array.solve_on_grid">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.solve_on_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_on_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">start_k</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Solve a tight-binding model on a regular mesh of k-points covering</span>
<span class="sd">        the entire reciprocal-space unit cell. Both points at the opposite</span>
<span class="sd">        sides of reciprocal-space unit cell are included in the array.</span>

<span class="sd">        This function also automatically imposes periodic boundary</span>
<span class="sd">        conditions on the eigenfunctions. See also the discussion in</span>
<span class="sd">        :func:`pythtb.wf_array.impose_pbc`.</span>

<span class="sd">        :param start_k: Origin of a regular grid of points in the reciprocal space.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **gaps** -- returns minimal direct bandgap between n-th and n+1-th </span>
<span class="sd">              band on all the k-points in the mesh.  Note that in the case of band</span>
<span class="sd">              crossings one may have to use very dense k-meshes to resolve</span>
<span class="sd">              the crossing.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Solve eigenvectors on a regular grid anchored</span>
<span class="sd">          # at a given point</span>
<span class="sd">          wf.solve_on_grid([-0.5, -0.5])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check dimensionality</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>\
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">If using solve_on_grid method, dimension of wf_array must equal&quot;</span>\
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">dim_k of the tight-binding model!&quot;</span><span class="p">)</span>

        <span class="c1"># check number of states</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_nsta</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>\
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">When initializing this object, you specified nsta_arr to be &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, but&quot;</span>\
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">this does not match the total number of bands specified in the model,&quot;</span>\
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">which was &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_nsta</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.  If you wish to use the solve_on_grid method, do&quot;</span>\
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">not specify the nsta_arr parameter when initializing this object.</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># store start_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_k</span><span class="o">=</span><span class="n">start_k</span>

        <span class="c1"># to return gaps at all k-points</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">all_gaps</span><span class="o">=</span><span class="kc">None</span> <span class="c1"># trivial case since there is only one band</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gap_dim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">gap_dim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gap_dim</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">all_gaps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">gap_dim</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># don&#39;t need to go over the last point because that will be</span>
            <span class="c1"># computed in the impose_pbc call</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># generate a kpoint</span>
                <span class="n">kpt</span><span class="o">=</span><span class="p">[</span><span class="n">start_k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="c1"># solve at that point</span>
                <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">solve_one</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># store wavefunctions</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">evec</span>
                <span class="c1"># store gaps</span>
                <span class="k">if</span> <span class="n">all_gaps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">all_gaps</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="nb">eval</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="nb">eval</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># impose boundary conditions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">impose_pbc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_per</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">kpt</span><span class="o">=</span><span class="p">[</span><span class="n">start_k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>\
                         <span class="n">start_k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                    <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">solve_one</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">evec</span>
                    <span class="k">if</span> <span class="n">all_gaps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">all_gaps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span><span class="o">=</span><span class="nb">eval</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="nb">eval</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">impose_pbc</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_per</span><span class="p">[</span><span class="nb">dir</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">kpt</span><span class="o">=</span><span class="p">[</span><span class="n">start_k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>\
                             <span class="n">start_k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>\
                             <span class="n">start_k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                        <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">solve_one</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">evec</span>
                        <span class="k">if</span> <span class="n">all_gaps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">all_gaps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,:]</span><span class="o">=</span><span class="nb">eval</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="nb">eval</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">impose_pbc</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_per</span><span class="p">[</span><span class="nb">dir</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">kpt</span><span class="o">=</span><span class="p">[</span><span class="n">start_k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>\
                                     <span class="n">start_k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>\
                                     <span class="n">start_k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>\
                                     <span class="n">start_k</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                            <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">solve_one</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">=</span><span class="n">evec</span>
                            <span class="k">if</span> <span class="n">all_gaps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">all_gaps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">,:]</span><span class="o">=</span><span class="nb">eval</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="nb">eval</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">impose_pbc</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_per</span><span class="p">[</span><span class="nb">dir</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong dimensionality!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">all_gaps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">all_gaps</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

        
<div class="viewcode-block" id="wf_array.solve_on_one_point">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.solve_on_one_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_on_one_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">kpt</span><span class="p">,</span><span class="n">mesh_indices</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Solve a tight-binding model on a single k-point and store the eigenvectors</span>
<span class="sd">        in the *wf_array* object in the location specified by *mesh_indices*.</span>

<span class="sd">        :param kpt: List specifying desired k-point</span>

<span class="sd">        :param mesh_indices: List specifying associated set of mesh indices</span>

<span class="sd">        :returns:</span>
<span class="sd">          None</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Solve eigenvectors on a sphere of radius kappa surrounding</span>
<span class="sd">          # point k_0 in 3d k-space and pack into a predefined 2d wf_array</span>
<span class="sd">          for i in range[n+1]:</span>
<span class="sd">            for j in range[m+1]:</span>
<span class="sd">              theta=np.pi*i/n</span>
<span class="sd">              phi=2*np.pi*j/m</span>
<span class="sd">              kx=k_0[0]+kappa*np.sin(theta)*np.cos(phi)</span>
<span class="sd">              ky=k_0[1]+kappa*np.sin(theta)*np.sin(phi)</span>
<span class="sd">              kz=k_0[2]+kappa*np.cos(theta)</span>
<span class="sd">              wf.solve_on_one_point([kx,ky,kz],[i,j])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">evec</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">solve_one</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">mesh_indices</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[(</span><span class="n">mesh_indices</span><span class="p">,)]</span><span class="o">=</span><span class="n">evec</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mesh_indices</span><span class="p">)]</span><span class="o">=</span><span class="n">evec</span></div>


<div class="viewcode-block" id="wf_array.choose_states">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.choose_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">choose_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">subset</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Create a new *wf_array* object containing a subset of the</span>
<span class="sd">        states in the original one.</span>

<span class="sd">        :param subset: List of integers specifying states to keep</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **wf_new** -- returns a *wf_array* that is identical in all</span>
<span class="sd">              respects except that a subset of states have been kept.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Make new *wf_array* object containing only two states</span>
<span class="sd">          wf_new=wf.choose_states([3,5])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make a full copy of the wf_array</span>
        <span class="n">wf_new</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">subset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subset</span><span class="o">.</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Parameter subset must be a one-dimensional array.&quot;</span><span class="p">)</span>
        
        <span class="n">wf_new</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="o">=</span><span class="n">subset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="o">=</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,</span><span class="n">subset</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="o">=</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,</span><span class="n">subset</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="o">=</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,:,</span><span class="n">subset</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="o">=</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,:,:,</span><span class="n">subset</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">_dim_array too large.&quot;</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">wf_new</span><span class="p">)</span></div>


<div class="viewcode-block" id="wf_array.empty_like">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.empty_like">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsta_arr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Create a new empty *wf_array* object based on the original,</span>
<span class="sd">        optionally modifying the number of states carried in the array.</span>

<span class="sd">        :param nsta_arr: Optional parameter specifying the number</span>
<span class="sd">              of states (or bands) to be carried in the array.</span>
<span class="sd">              Defaults to the same as the original *wf_array* object.</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **wf_new** -- returns a similar wf_array except that array</span>
<span class="sd">              elements are unitialized and the number of states may have</span>
<span class="sd">              changed.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Make new empty wf_array object containing 6 bands per k-point</span>
<span class="sd">          wf_new=wf.empty_like(nsta_arr=6)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make a full copy of the wf_array</span>
        <span class="n">wf_new</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsta_arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wf_shape</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># modify numer of states (after k indices &amp; before orb and spin)</span>
            <span class="n">wf_shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="p">]</span><span class="o">=</span><span class="n">nsta_arr</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="n">wf_shape</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">wf_new</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__check_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="c1"># key is an index list specifying the grid point of interest</span>
        <span class="c1"># exception: in 1D, key should simply be an integer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Key should be an integer!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">&lt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">key</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Key outside the range!&quot;</span><span class="p">)</span>
        <span class="c1"># do checks for higher dimension</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong dimensionality of key!&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Key should be set of integers!&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">&lt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">k</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Key outside the range!&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="c1"># check that index array &#39;key&#39; is valid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># return wavefunction</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="c1"># check that index array &#39;key&#39; is valid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># store wavefunction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<div class="viewcode-block" id="wf_array.impose_pbc">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.impose_pbc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">impose_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh_dir</span><span class="p">,</span><span class="n">k_dir</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        If the *wf_array* object was populated using the</span>
<span class="sd">        :func:`pythtb.wf_array.solve_on_grid` method, this function</span>
<span class="sd">        should not be used since it will be called automatically by</span>
<span class="sd">        the code.</span>

<span class="sd">        The eigenfunctions :math:`\Psi_{n {\bf k}}` are by convention</span>
<span class="sd">        chosen to obey a periodic gauge, i.e.,</span>
<span class="sd">        :math:`\Psi_{n,{\bf k+G}}=\Psi_{n {\bf k}}` not only up to a</span>
<span class="sd">        phase, but they are also equal in phase.  It follows that</span>
<span class="sd">        the cell-periodic Bloch functions are related by</span>
<span class="sd">        :math:`u_{n,{\bf k+G}}=e^{-i{\bf G}\cdot{\bf r}} u_{n {\bf k}}`.</span>
<span class="sd">        See :download:`notes on tight-binding formalism</span>
<span class="sd">        &lt;misc/pythtb-formalism.pdf&gt;` section 4.4 and equation 4.18 for</span>
<span class="sd">        more detail.  This routine sets the cell-periodic Bloch function</span>
<span class="sd">        at the end of the string in direction :math:`{\bf G}` according</span>
<span class="sd">        to this formula, overwriting the previous value.</span>

<span class="sd">        This function will impose these periodic boundary conditions along</span>
<span class="sd">        one direction of the array. We are assuming that the k-point</span>
<span class="sd">        mesh increases by exactly one reciprocal lattice vector along</span>
<span class="sd">        this direction. This is currently **not** checked by the code;</span>
<span class="sd">        it is the responsibility of the user. Currently *wf_array*</span>
<span class="sd">        does not store the k-vectors on which the model was solved;</span>
<span class="sd">        it only stores the eigenvectors (wavefunctions).</span>
<span class="sd">        </span>
<span class="sd">        :param mesh_dir: Direction of wf_array along which you wish to</span>
<span class="sd">          impose periodic boundary conditions.</span>

<span class="sd">        :param k_dir: Corresponding to the periodic k-vector direction</span>
<span class="sd">          in the Brillouin zone of the underlying *tb_model*.  Since</span>
<span class="sd">          version 1.7.0 this parameter is defined so that it is</span>
<span class="sd">          specified between 0 and *dim_r-1*.</span>

<span class="sd">        See example :ref:`3site_cycle-example`, where the periodic boundary</span>
<span class="sd">        condition is applied only along one direction of *wf_array*.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Imposes periodic boundary conditions along the mesh_dir=0</span>
<span class="sd">          # direction of the wf_array object, assuming that along that</span>
<span class="sd">          # direction the k_dir=1 component of the k-vector is increased</span>
<span class="sd">          # by one reciprocal lattice vector.  This could happen, for</span>
<span class="sd">          # example, if the underlying tb_model is two dimensional but</span>
<span class="sd">          # wf_array is a one-dimensional path along k_y direction.          </span>
<span class="sd">          wf.impose_pbc(mesh_dir=0,k_dir=1)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">k_dir</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Periodic boundary condition can be specified only along periodic directions!&quot;</span><span class="p">)</span>

        <span class="c1"># Compute phase factors</span>
        <span class="n">ffac</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[:,</span><span class="n">k_dir</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">phase</span><span class="o">=</span><span class="n">ffac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for spinors, same phase multiplies both components</span>
            <span class="n">phase</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">phase</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">ffac</span>
            <span class="n">phase</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">ffac</span>
        
        <span class="c1"># Copy first eigenvector onto last one, multiplying by phase factors</span>
        <span class="c1"># We can use numpy broadcasting since the orbital index is last</span>
        <span class="k">if</span> <span class="n">mesh_dir</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">*</span><span class="n">phase</span>
        <span class="k">elif</span> <span class="n">mesh_dir</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">*</span><span class="n">phase</span>
        <span class="k">elif</span> <span class="n">mesh_dir</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">*</span><span class="n">phase</span>
        <span class="k">elif</span> <span class="n">mesh_dir</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">*</span><span class="n">phase</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong value of mesh_dir.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="wf_array.impose_loop">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.impose_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">impose_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh_dir</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        If the user knows that the first and last points along the</span>
<span class="sd">        *mesh_dir* direction correspond to the same Hamiltonian (this</span>
<span class="sd">        is **not** checked), then this routine can be used to set the</span>
<span class="sd">        eigenvectors equal (with equal phase), by replacing the last</span>
<span class="sd">        eigenvector with the first one (for each band, and for each</span>
<span class="sd">        other mesh direction, if any).</span>

<span class="sd">        This routine should not be used if the first and last points</span>
<span class="sd">        are related by a reciprocal lattice vector; in that case,</span>
<span class="sd">        :func:`pythtb.wf_array.impose_pbc` should be used instead.</span>

<span class="sd">        :param mesh_dir: Direction of wf_array along which you wish to</span>
<span class="sd">          impose periodic boundary conditions.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Suppose the wf_array object is three-dimensional</span>
<span class="sd">          # corresponding to (kx,ky,lambda) where (kx,ky) are</span>
<span class="sd">          # wavevectors of a 2D insulator and lambda is an</span>
<span class="sd">          # adiabatic parameter that goes around a closed loop.</span>
<span class="sd">          # Then to insure that the states at the ends of the lambda</span>
<span class="sd">          # path are equal (with equal phase) in preparation for</span>
<span class="sd">          # computing Berry phases in lambda for given (kx,ky),</span>
<span class="sd">          # do wf.impose_loop(mesh_dir=2)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Copy first eigenvector onto last one</span>
        <span class="k">if</span> <span class="n">mesh_dir</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mesh_dir</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mesh_dir</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mesh_dir</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong value of mesh_dir.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="wf_array.position_matrix">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.position_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Similar to :func:`pythtb.tb_model.position_matrix`.  Only</span>
<span class="sd">        difference is that, in addition to specifying *dir*, one also</span>
<span class="sd">        has to specify *key* (k-point of interest) and *occ* (list of</span>
<span class="sd">        states to be included, which can optionally be &#39;All&#39;).&quot;&quot;&quot;</span>

        <span class="c1"># Check for special case of parameter occ</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">occ</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">occ</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">:</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">occ</span><span class="o">.</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span><span class="s2">Parameter occ must be a one-dimensional array or string &quot;All&quot;.&quot;&quot;&quot;</span><span class="p">)</span>
            
        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="n">evec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)][</span><span class="n">occ</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="wf_array.position_expectation">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.position_expectation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_expectation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Similar to :func:`pythtb.tb_model.position_expectation`.  Only</span>
<span class="sd">        difference is that, in addition to specifying *dir*, one also</span>
<span class="sd">        has to specify *key* (k-point of interest) and *occ* (list of</span>
<span class="sd">        states to be included, which can optionally be &#39;All&#39;).&quot;&quot;&quot;</span>

        <span class="c1"># Check for special case of parameter occ</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">occ</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">occ</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">:</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">occ</span><span class="o">.</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span><span class="s2">Parameter occ must be a one-dimensional array or string &quot;All&quot;.&quot;&quot;&quot;</span><span class="p">)</span>
            
        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="n">evec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)][</span><span class="n">occ</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">position_expectation</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="wf_array.position_hwf">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.position_hwf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_hwf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">hwf_evec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;wavefunction&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Similar to :func:`pythtb.tb_model.position_hwf`, except that</span>
<span class="sd">        in addition to specifying *dir*, one also has to specify</span>
<span class="sd">        *key*, the k-point of interest, and *occ*, a list of states to</span>
<span class="sd">        be included (typically the occupied states).</span>

<span class="sd">        For backwards compatibility the default value of *basis* here is different</span>
<span class="sd">        from that in :func:`pythtb.tb_model.position_hwf`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check for special case of parameter occ</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">occ</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">occ</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">:</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">occ</span><span class="o">.</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span><span class="s2">Parameter occ must be a one-dimensional array or string &quot;All&quot;.&quot;&quot;&quot;</span><span class="p">)</span>
            
        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="n">evec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)][</span><span class="n">occ</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">position_hwf</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span><span class="nb">dir</span><span class="p">,</span><span class="n">hwf_evec</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span></div>


<div class="viewcode-block" id="wf_array.berry_phase">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.berry_phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">berry_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">occ</span><span class="o">=</span><span class="s2">&quot;All&quot;</span><span class="p">,</span><span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">contin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">berry_evals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Computes the Berry phase along a given array direction</span>
<span class="sd">        and for a given set of states.  These are typically the</span>
<span class="sd">        occupied Bloch states, in which case *occ* should range</span>
<span class="sd">        over all occupied bands.  In this context, the occupied</span>
<span class="sd">        and unoccupied bands should be well separated in energy;</span>
<span class="sd">        it is the responsibility of the user to check that this</span>
<span class="sd">        is satisfied.  If *occ* is not specified or is specified</span>
<span class="sd">        as &#39;All&#39;, all states are selected. By default, the</span>
<span class="sd">        function returns the Berry phase traced over the</span>
<span class="sd">        specified set of bands, but optionally the individual</span>
<span class="sd">        phases of the eigenvalues of the global unitary rotation</span>
<span class="sd">        matrix (corresponding to &quot;maximally localized Wannier</span>
<span class="sd">        centers&quot; or &quot;Wilson loop eigenvalues&quot;) can be requested</span>
<span class="sd">        (see parameter *berry_evals* for more details).</span>

<span class="sd">        For an array of size *N* in direction $dir$, the Berry phase</span>
<span class="sd">        is computed from the *N-1* inner products of neighboring</span>
<span class="sd">        eigenfunctions.  This corresponds to an &quot;open-path Berry</span>
<span class="sd">        phase&quot; if the first and last points have no special</span>
<span class="sd">        relation.  If they correspond to the same physical</span>
<span class="sd">        Hamiltonian, and have been properly aligned in phase using</span>
<span class="sd">        :func:`pythtb.wf_array.impose_pbc` or</span>
<span class="sd">        :func:`pythtb.wf_array.impose_loop`, then a closed-path</span>
<span class="sd">        Berry phase will be computed.</span>

<span class="sd">        For a one-dimensional wf_array (i.e., a single string), the</span>
<span class="sd">        computed Berry phases are always chosen to be between -pi and pi.</span>
<span class="sd">        For a higher dimensional wf_array, the Berry phase is computed</span>
<span class="sd">        for each one-dimensional string of points, and an array of</span>
<span class="sd">        Berry phases is returned. The Berry phase for the first string</span>
<span class="sd">        (with lowest index) is always constrained to be between -pi and</span>
<span class="sd">        pi. The range of the remaining phases depends on the value of</span>
<span class="sd">        the input parameter *contin*.</span>

<span class="sd">        The discretized formula used to compute Berry phase is described</span>
<span class="sd">        in Sec. 4.5 of :download:`notes on tight-binding formalism</span>
<span class="sd">        &lt;misc/pythtb-formalism.pdf&gt;`.</span>

<span class="sd">        :param occ: Optional array of indices of states to be included</span>
<span class="sd">          in the subsequent calculations, typically the indices of</span>
<span class="sd">          bands considered occupied.  Default is all bands.</span>

<span class="sd">        :param dir: Index of wf_array direction along which Berry phase is</span>
<span class="sd">          computed. This parameters needs not be specified for</span>
<span class="sd">          a one-dimensional wf_array.</span>

<span class="sd">        :param contin: Optional boolean parameter. If True then the</span>
<span class="sd">          branch choice of the Berry phase (which is indeterminate</span>
<span class="sd">          modulo 2*pi) is made so that neighboring strings (in the</span>
<span class="sd">          direction of increasing index value) have as close as</span>
<span class="sd">          possible phases. The phase of the first string (with lowest</span>
<span class="sd">          index) is always constrained to be between -pi and pi. If</span>
<span class="sd">          False, the Berry phase for every string is constrained to be</span>
<span class="sd">          between -pi and pi. The default value is True.</span>

<span class="sd">        :param berry_evals: Optional boolean parameter. If True then</span>
<span class="sd">          will compute and return the phases of the eigenvalues of the</span>
<span class="sd">          product of overlap matrices. (These numbers correspond also</span>
<span class="sd">          to hybrid Wannier function centers.) These phases are either</span>
<span class="sd">          forced to be between -pi and pi (if *contin* is *False*) or</span>
<span class="sd">          they are made to be continuous (if *contin* is True).</span>

<span class="sd">        :returns:</span>
<span class="sd">          * **pha** -- If *berry_evals* is False (default value) then</span>
<span class="sd">            returns the Berry phase for each string. For a</span>
<span class="sd">            one-dimensional wf_array this is just one number. For a</span>
<span class="sd">            higher-dimensional wf_array *pha* contains one phase for</span>
<span class="sd">            each one-dimensional string in the following format. For</span>
<span class="sd">            example, if *wf_array* contains k-points on mesh with</span>
<span class="sd">            indices [i,j,k] and if direction along which Berry phase</span>
<span class="sd">            is computed is *dir=1* then *pha* will be two dimensional</span>
<span class="sd">            array with indices [i,k], since Berry phase is computed</span>
<span class="sd">            along second direction. If *berry_evals* is True then for</span>
<span class="sd">            each string returns phases of all eigenvalues of the</span>
<span class="sd">            product of overlap matrices. In the convention used for</span>
<span class="sd">            previous example, *pha* in this case would have indices</span>
<span class="sd">            [i,k,n] where *n* refers to index of individual phase of</span>
<span class="sd">            the product matrix eigenvalue.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Computes Berry phases along second direction for three lowest</span>
<span class="sd">          # occupied states. For example, if wf is threedimensional, then</span>
<span class="sd">          # pha[2,3] would correspond to Berry phase of string of states</span>
<span class="sd">          # along wf[2,:,3]</span>
<span class="sd">          pha = wf.berry_phase([0, 1, 2], 1)</span>

<span class="sd">        See also these examples: :ref:`haldane_bp-example`,</span>
<span class="sd">        :ref:`cone-example`, :ref:`3site_cycle-example`,</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># special case requesting all states in the array</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">occ</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">occ</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">occ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># note that &#39;None&#39; means &#39;not specified&#39;, not &#39;no states&#39;</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">occ</span><span class="o">.</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span><span class="s2">Parameter occ must be a one-dimensional array or string &quot;All&quot; or None.&quot;&quot;&quot;</span><span class="p">)</span>

                    
        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="c1">#if dir&lt;0 or dir&gt;self._dim_arr-1:</span>
        <span class="c1">#  raise Exception(&quot;\n\nDirection key out of range&quot;)</span>
        <span class="c1">#</span>
        <span class="c1"># This could be coded more efficiently, but it is hard-coded for now.</span>
        <span class="c1">#</span>
        <span class="c1"># 1D case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># pick which wavefunctions to use</span>
            <span class="n">wf_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,</span><span class="n">occ</span><span class="p">,:]</span>
            <span class="c1"># calculate berry phase</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">_one_berry_loop</span><span class="p">(</span><span class="n">wf_use</span><span class="p">,</span><span class="n">berry_evals</span><span class="p">)</span>
        <span class="c1"># 2D case</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># choice along which direction you wish to calculate berry phase</span>
            <span class="k">if</span> <span class="nb">dir</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">wf_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:,:][:,</span><span class="n">occ</span><span class="p">,:]</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_one_berry_loop</span><span class="p">(</span><span class="n">wf_use</span><span class="p">,</span><span class="n">berry_evals</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">dir</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">wf_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:,:][:,</span><span class="n">occ</span><span class="p">,:]</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_one_berry_loop</span><span class="p">(</span><span class="n">wf_use</span><span class="p">,</span><span class="n">berry_evals</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong direction for Berry phase calculation!&quot;</span><span class="p">)</span>
        <span class="c1"># 3D case</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="c1"># choice along which direction you wish to calculate berry phase</span>
            <span class="k">if</span> <span class="nb">dir</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">ret_t</span><span class="o">=</span><span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                        <span class="n">wf_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:,:][:,</span><span class="n">occ</span><span class="p">,:]</span>
                        <span class="n">ret_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_one_berry_loop</span><span class="p">(</span><span class="n">wf_use</span><span class="p">,</span><span class="n">berry_evals</span><span class="p">))</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret_t</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">dir</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ret_t</span><span class="o">=</span><span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                        <span class="n">wf_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="n">j</span><span class="p">,:,:][:,</span><span class="n">occ</span><span class="p">,:]</span>
                        <span class="n">ret_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_one_berry_loop</span><span class="p">(</span><span class="n">wf_use</span><span class="p">,</span><span class="n">berry_evals</span><span class="p">))</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret_t</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">dir</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ret_t</span><span class="o">=</span><span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">wf_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:,:,:][:,</span><span class="n">occ</span><span class="p">,:]</span>
                        <span class="n">ret_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_one_berry_loop</span><span class="p">(</span><span class="n">wf_use</span><span class="p">,</span><span class="n">berry_evals</span><span class="p">))</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret_t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong direction for Berry phase calculation!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong dimensionality!&quot;</span><span class="p">)</span>

        <span class="c1"># convert phases to numpy array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">berry_evals</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># make phases of eigenvalues continuous</span>
        <span class="k">if</span> <span class="n">contin</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="c1"># iron out 2pi jumps, make the gauge choice such that first phase in the</span>
            <span class="c1"># list is fixed, others are then made continuous.</span>
            <span class="k">if</span> <span class="n">berry_evals</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="c1"># 2D case</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">=</span><span class="n">_one_phase_cont</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># 3D case</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">clos</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span> <span class="n">clos</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">ret</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">_one_phase_cont</span><span class="p">(</span><span class="n">ret</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span><span class="n">clos</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong dimensionality!&quot;</span><span class="p">)</span>
            <span class="c1"># make eigenvalues continuous. This does not take care of band-character</span>
            <span class="c1"># at band crossing for example it will just connect pairs that are closest</span>
            <span class="c1"># at neighboring points.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 2D case</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">=</span><span class="n">_array_phases_cont</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
                <span class="c1"># 3D case</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">clos</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
                        <span class="k">else</span><span class="p">:</span> <span class="n">clos</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
                        <span class="n">ret</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">_array_phases_cont</span><span class="p">(</span><span class="n">ret</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span><span class="n">clos</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong dimensionality!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    
<div class="viewcode-block" id="wf_array.berry_flux">
<a class="viewcode-back" href="../usage.html#pythtb.wf_array.berry_flux">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">berry_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">occ</span><span class="o">=</span><span class="s2">&quot;All&quot;</span><span class="p">,</span><span class="n">dirs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">individual_phases</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        In the case of a 2-dimensional *wf_array* array calculates the</span>
<span class="sd">        integral of Berry curvature over the entire plane.  In higher</span>
<span class="sd">        dimensional case (3 or 4) it will compute integrated curvature</span>
<span class="sd">        over all 2-dimensional slices of a higher-dimensional</span>
<span class="sd">        *wf_array*.</span>

<span class="sd">        :param occ: Optional array of indices of states to be included</span>
<span class="sd">          in the subsequent calculations, typically the indices of</span>
<span class="sd">          bands considered occupied.  If not specified or specified as</span>
<span class="sd">          &#39;All&#39;, all bands are included.</span>

<span class="sd">        :param dirs: Array of indices of two wf_array directions on which</span>
<span class="sd">          the Berry flux is computed. This parameter needs not be</span>
<span class="sd">          specified for a two-dimensional wf_array.  By default *dirs* takes</span>
<span class="sd">          first two directions in the array.</span>

<span class="sd">        :param individual_phases: If *True* then returns Berry phase</span>
<span class="sd">          for each plaquette (small square) in the array. Default</span>
<span class="sd">          value is *False*.</span>

<span class="sd">        :returns:</span>

<span class="sd">          * **flux** -- In a 2-dimensional case returns and integral</span>
<span class="sd">            of Berry curvature (if *individual_phases* is *True* then</span>
<span class="sd">            returns integral of Berry phase around each plaquette).</span>
<span class="sd">            In higher dimensional case returns integral of Berry</span>
<span class="sd">            curvature over all slices defined with directions *dirs*.</span>
<span class="sd">            Returned value is an array over the remaining indices of</span>
<span class="sd">            *wf_array*.  (If *individual_phases* is *True* then it</span>
<span class="sd">            returns again phases around each plaquette for each</span>
<span class="sd">            slice. First indices define the slice, last two indices</span>
<span class="sd">            index the plaquette.)</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # Computes integral of Berry curvature of first three bands</span>
<span class="sd">          flux = wf.berry_flux([0, 1, 2])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># special case requesting all states in the array</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">occ</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">occ</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">occ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># note that &#39;None&#39; means &#39;not specified&#39;, not &#39;no states&#39;</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nsta_arr</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">occ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            
        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="c1"># default case is to take first two directions for flux calculation</span>
        <span class="k">if</span> <span class="n">dirs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dirs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># consistency checks</span>
        <span class="k">if</span> <span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">dirs</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need to specify two different directions for Berry flux calculation.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span> <span class="ow">or</span> <span class="n">dirs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span> <span class="ow">or</span> <span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">dirs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Direction for Berry flux calculation out of bounds.&quot;</span><span class="p">)</span>

        <span class="c1"># 2D case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># compute the fluxes through all plaquettes on the entire plane </span>
            <span class="nb">ord</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
            <span class="c1"># select two directions from dirs</span>
            <span class="nb">ord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">ord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">dirs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">plane_wfs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span>
            <span class="c1"># take bands of choice</span>
            <span class="n">plane_wfs</span><span class="o">=</span><span class="n">plane_wfs</span><span class="p">[:,:,</span><span class="n">occ</span><span class="p">]</span>

            <span class="c1"># compute fluxes</span>
            <span class="n">all_phases</span><span class="o">=</span><span class="n">_one_flux_plane</span><span class="p">(</span><span class="n">plane_wfs</span><span class="p">)</span>

            <span class="c1"># return either total flux or individual phase for each plaquete</span>
            <span class="k">if</span> <span class="n">individual_phases</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">all_phases</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">all_phases</span>

        <span class="c1"># 3D or 4D case</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span>
            <span class="c1"># compute the fluxes through all plaquettes on the entire plane </span>
            <span class="nb">ord</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
            <span class="c1"># select two directions from dirs</span>
            <span class="nb">ord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">ord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">dirs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># find directions over which we wish to loop</span>
            <span class="n">ld</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="p">))</span>
            <span class="n">ld</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ld</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ld</span><span class="p">)</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Hm, this should not happen? Inconsistency with the mesh size.&quot;</span><span class="p">)</span>
            
            <span class="c1"># add remaining indices</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="nb">ord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">ld</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="nb">ord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">ld</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">ord</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">ld</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># reorder wavefunctions</span>
            <span class="n">use_wfs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span>

            <span class="c1"># loop over the the remaining direction</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">slice_phases</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="nb">ord</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="n">dirs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="nb">ord</span><span class="p">[</span><span class="mi">2</span><span class="p">]]):</span>
                    <span class="c1"># take a 2d slice</span>
                    <span class="n">plane_wfs</span><span class="o">=</span><span class="n">use_wfs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># take bands of choice</span>
                    <span class="n">plane_wfs</span><span class="o">=</span><span class="n">plane_wfs</span><span class="p">[:,:,</span><span class="n">occ</span><span class="p">]</span>
                    <span class="c1"># compute fluxes on the slice</span>
                    <span class="n">slice_phases</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">_one_flux_plane</span><span class="p">(</span><span class="n">plane_wfs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_arr</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">slice_phases</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="nb">ord</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="nb">ord</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="n">dirs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="nb">ord</span><span class="p">[</span><span class="mi">2</span><span class="p">]]):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_arr</span><span class="p">[</span><span class="nb">ord</span><span class="p">[</span><span class="mi">3</span><span class="p">]]):</span>
                        <span class="c1"># take a 2d slice</span>
                        <span class="n">plane_wfs</span><span class="o">=</span><span class="n">use_wfs</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                        <span class="c1"># take bands of choice</span>
                        <span class="n">plane_wfs</span><span class="o">=</span><span class="n">plane_wfs</span><span class="p">[:,:,</span><span class="n">occ</span><span class="p">]</span>
                        <span class="c1"># compute fluxes on the slice</span>
                        <span class="n">slice_phases</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">_one_flux_plane</span><span class="p">(</span><span class="n">plane_wfs</span><span class="p">)</span>

            <span class="c1"># return either total flux or individual phase for each plaquete</span>
            <span class="k">if</span> <span class="n">individual_phases</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slice_phases</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slice_phases</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Wrong dimensionality!&quot;</span><span class="p">)</span></div>
</div>


<span class="c1">#=======================================================================</span>
<div class="viewcode-block" id="w90">
<a class="viewcode-back" href="../usage.html#pythtb.w90">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">w90</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1">#=======================================================================</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>

<span class="sd">    This class of the PythTB package imports tight-binding model</span>
<span class="sd">    parameters from an output of a `Wannier90</span>
<span class="sd">    &lt;http://www.wannier.org&gt;`_ code. </span>

<span class="sd">    The `Wannier90 &lt;http://www.wannier.org&gt;`_ code is a</span>
<span class="sd">    post-processing tool that takes as an input electron wavefunctions</span>
<span class="sd">    and energies computed from first-principles using any of the</span>
<span class="sd">    following codes: Quantum-Espresso (PWscf), AbInit, SIESTA, FLEUR,</span>
<span class="sd">    Wien2k, VASP.  As an output Wannier90 will create files that</span>
<span class="sd">    contain parameters for a tight-binding model that exactly</span>
<span class="sd">    reproduces the first-principles calculated electron band</span>
<span class="sd">    structure.</span>

<span class="sd">    The interface from Wannier90 to PythTB will use only the following</span>
<span class="sd">    files created by Wannier90:</span>

<span class="sd">    - *prefix*.win</span>
<span class="sd">    - *prefix*\_hr.dat</span>
<span class="sd">    - *prefix*\_centres.xyz</span>
<span class="sd">    - *prefix*\_band.kpt (optional)</span>
<span class="sd">    - *prefix*\_band.dat (optional)</span>
<span class="sd">    </span>
<span class="sd">    The first file (*prefix*.win) is an input file to Wannier90 itself. This</span>
<span class="sd">    file is needed so that PythTB can read in the unit cell vectors.</span>

<span class="sd">    To correctly create the second and the third file (*prefix*\_hr.dat and</span>
<span class="sd">    *prefix*\_centres.dat) one needs to include the following flags in the win</span>
<span class="sd">    file::</span>

<span class="sd">       hr_plot = True</span>
<span class="sd">       write_xyz = True</span>
<span class="sd">       translate_home_cell = False</span>

<span class="sd">    These lines ensure that *prefix*\_hr.dat and *prefix*\_centres.dat</span>
<span class="sd">    are written and that the centers of the Wannier functions written</span>
<span class="sd">    in the *prefix*\_centres.dat file are not translated to the home</span>
<span class="sd">    cell.  The *prefix*\_hr.dat file contains the onsite and hopping</span>
<span class="sd">    terms.</span>

<span class="sd">    The final two files (*prefix*\_band.kpt and *prefix*\_band.dat)</span>
<span class="sd">    are optional.  Please see documentation of function</span>
<span class="sd">    :func:`pythtb.w90.w90_bands_consistency` for more detail.</span>

<span class="sd">    So far we tested only Wannier90 version 2.0.1.</span>

<span class="sd">    .. warning:: For the time being PythTB is not optimized to be used</span>
<span class="sd">      with very large tight-binding models.  Therefore it is not</span>
<span class="sd">      advisable to use the interface to Wannier90 with large</span>
<span class="sd">      first-principles calculations that contain many k-points and/or</span>
<span class="sd">      electron bands.  One way to reduce the computational cost is to</span>
<span class="sd">      wannierize with Wannier90 only the bands of interest (for</span>
<span class="sd">      example, bands near the Fermi level).</span>

<span class="sd">    Units used throught this interface with Wannier90 are</span>
<span class="sd">    electron-volts (eV) and Angstroms.</span>

<span class="sd">    .. warning:: User needs to make sure that the Wannier functions</span>
<span class="sd">      computed using Wannier90 code are well localized.  Otherwise the</span>
<span class="sd">      tight-binding model might not interpolate well the band</span>
<span class="sd">      structure.  To ensure that the Wannier functions are well</span>
<span class="sd">      localized it is often enough to check that the total spread at</span>
<span class="sd">      the beginning of the minimization procedure (first total spread</span>
<span class="sd">      printed in .wout file) is not more than 20% larger than the</span>
<span class="sd">      total spread at the end of the minimization procedure.  If those</span>
<span class="sd">      spreads differ by much more than 20% user needs to specify</span>
<span class="sd">      better initial projection functions.  </span>

<span class="sd">      In addition, please note that the interpolation is valid only</span>
<span class="sd">      within the frozen energy window of the disentanglement</span>
<span class="sd">      procedure.</span>

<span class="sd">    .. warning:: So far PythTB assumes that the position operator is</span>
<span class="sd">      diagonal in the tight-binding basis.  This is discussed in the</span>
<span class="sd">      :download:`notes on tight-binding formalism</span>
<span class="sd">      &lt;misc/pythtb-formalism.pdf&gt;` in Eq. 2.7.,</span>
<span class="sd">      :math:`\langle\phi_{{\bf R} i} \vert {\bf r} \vert \phi_{{\bf</span>
<span class="sd">      R}&#39; j} \rangle = ({\bf R} + {\bf t}_j) \delta_{{\bf R} {\bf R}&#39;}</span>
<span class="sd">      \delta_{ij}`.  However, this relation does not hold for Wannier</span>
<span class="sd">      functions!  Therefore, if you use tight-binding model derived</span>
<span class="sd">      from this class in computing Berry-like objects that involve</span>
<span class="sd">      position operator such as Berry phase or Berry flux, you would</span>
<span class="sd">      not get the same result as if you computed those objects</span>
<span class="sd">      directly from the first-principles code!  Nevertheless, this</span>
<span class="sd">      approximation does not affect other properties such as band</span>
<span class="sd">      structure dispersion.</span>

<span class="sd">    For the testing purposes user can download the following</span>
<span class="sd">    :download:`wannier90 output example</span>
<span class="sd">    &lt;misc/wannier90_example.tar.gz&gt;` and use the following</span>
<span class="sd">    :ref:`script &lt;w90_quick&gt;` to test the functionality of the interface to</span>
<span class="sd">    PythTB. Run the following command in unix terminal to decompress</span>
<span class="sd">    the tarball::</span>

<span class="sd">        tar -zxf wannier90_example.tar.gz</span>
<span class="sd"> </span>
<span class="sd">    and then run the following :ref:`script &lt;w90_quick&gt;` in the same</span>
<span class="sd">    folder.</span>

<span class="sd">    :param path: Relative path to the folder that contains Wannier90</span>
<span class="sd">       files.  These are *prefix*.win, *prefix*\_hr.dat,</span>
<span class="sd">       *prefix*\_centres.dat and optionally *prefix*\_band.kpt and</span>
<span class="sd">       *prefix*\_band.dat.</span>

<span class="sd">    :param prefix: This is the prefix used by Wannier90 code.</span>
<span class="sd">        Typically the input to the Wannier90 code is name *prefix*.win.</span>

<span class="sd">    Initially this function will read in the entire Wannier90 output.</span>
<span class="sd">    To create :class:`pythtb.tb_model` object user needs to call</span>
<span class="sd">    :func:`pythtb.w90.model`.</span>

<span class="sd">    Example usage::</span>

<span class="sd">      # reads Wannier90 from folder called *example_a*</span>
<span class="sd">      # it assumes that that folder contains files &quot;silicon.win&quot; and so on</span>
<span class="sd">      silicon=w90(&quot;example_a&quot;, &quot;silicon&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">prefix</span><span class="p">):</span>
        <span class="c1"># store path and prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">=</span><span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span>

        <span class="c1"># read in lattice_vectors</span>
        <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s2">&quot;.win&quot;</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">ln</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># get lattice vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">found</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ln</span><span class="p">)):</span>
            <span class="n">sp</span><span class="o">=</span><span class="n">ln</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;begin&quot;</span> <span class="ow">and</span> <span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;unit_cell_cart&quot;</span><span class="p">:</span>
                    <span class="c1"># get units right</span>
                    <span class="k">if</span> <span class="n">ln</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;bohr&quot;</span><span class="p">:</span>
                        <span class="n">pref</span><span class="o">=</span><span class="mf">0.5291772108</span>
                        <span class="n">skip</span><span class="o">=</span><span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">ln</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ang&quot;</span><span class="p">,</span><span class="s2">&quot;angstrom&quot;</span><span class="p">]:</span>
                        <span class="n">pref</span><span class="o">=</span><span class="mf">1.0</span>
                        <span class="n">skip</span><span class="o">=</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pref</span><span class="o">=</span><span class="mf">1.0</span>
                        <span class="n">skip</span><span class="o">=</span><span class="mi">0</span>
                    <span class="c1"># now get vectors</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">sp</span><span class="o">=</span><span class="n">ln</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">skip</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">pref</span>
                    <span class="n">found</span><span class="o">=</span><span class="kc">True</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">found</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unable to find unit_cell_cart block in the .win file.&quot;</span><span class="p">)</span>

        <span class="c1"># read in hamiltonian matrix, in eV</span>
        <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s2">&quot;_hr.dat&quot;</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">ln</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="c1"># get number of wannier functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ln</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># get number of Wigner-Seitz points</span>
        <span class="n">num_ws</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ln</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># get degenereacies of Wigner-Seitz points</span>
        <span class="n">deg_ws</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ln</span><span class="p">)):</span>
            <span class="n">sp</span><span class="o">=</span><span class="n">ln</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
                <span class="n">deg_ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deg_ws</span><span class="p">)</span><span class="o">==</span><span class="n">num_ws</span><span class="p">:</span>
                <span class="n">last_j</span><span class="o">=</span><span class="n">j</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deg_ws</span><span class="p">)</span><span class="o">&gt;</span><span class="n">num_ws</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Too many degeneracies for WS points!&quot;</span><span class="p">)</span>
        <span class="n">deg_ws</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">deg_ws</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># now read in matrix elements</span>
        <span class="c1"># Convention used in w90 is to write out:</span>
        <span class="c1"># R1, R2, R3, i, j, ham_r(i,j,R)</span>
        <span class="c1"># where ham_r(i,j,R) corresponds to matrix element &lt; i | H | j+R &gt;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># format is ham_r[(R1,R2,R3)][&quot;h&quot;][i,j] for &lt; i | H | j+R &gt;</span>
        <span class="n">ind_R</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># which R vector in line is this?</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">last_j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ln</span><span class="p">)):</span>
            <span class="n">sp</span><span class="o">=</span><span class="n">ln</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="c1"># get reduced lattice vector components</span>
            <span class="n">ham_R1</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ham_R2</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ham_R3</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="c1"># get Wannier indices</span>
            <span class="n">ham_i</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">ham_j</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
            <span class="c1"># get matrix element</span>
            <span class="n">ham_val</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="o">+</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
            <span class="c1"># store stuff, for each R store hamiltonian and degeneracy</span>
            <span class="n">ham_key</span><span class="o">=</span><span class="p">(</span><span class="n">ham_R1</span><span class="p">,</span><span class="n">ham_R2</span><span class="p">,</span><span class="n">ham_R3</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ham_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">)</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">[</span><span class="n">ham_key</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;h&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">),</span>
                    <span class="s2">&quot;deg&quot;</span><span class="p">:</span><span class="n">deg_ws</span><span class="p">[</span><span class="n">ind_R</span><span class="p">]</span>
                    <span class="p">}</span>
                <span class="n">ind_R</span><span class="o">+=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">[</span><span class="n">ham_key</span><span class="p">][</span><span class="s2">&quot;h&quot;</span><span class="p">][</span><span class="n">ham_i</span><span class="p">,</span><span class="n">ham_j</span><span class="p">]</span><span class="o">=</span><span class="n">ham_val</span>

        <span class="c1"># check if for every non-zero R there is also -R</span>
        <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">found_pair</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                        <span class="c1"># check if they are opposite</span>
                        <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==-</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==-</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==-</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> 
                            <span class="k">if</span> <span class="n">found_pair</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Found duplicate negative R!&quot;</span><span class="p">)</span>
                            <span class="n">found_pair</span><span class="o">=</span><span class="kc">True</span>
                <span class="k">if</span> <span class="n">found_pair</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Did not find negative R for R = &quot;</span><span class="o">+</span><span class="n">R</span><span class="o">+</span><span class="s2">&quot;!&quot;</span><span class="p">)</span>

        <span class="c1"># read in wannier centers</span>
        <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s2">&quot;_centres.xyz&quot;</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">ln</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># Wannier centers in Cartesian, Angstroms</span>
        <span class="n">xyz_cen</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">):</span>
            <span class="n">sp</span><span class="o">=</span><span class="n">ln</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;X&quot;</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">xyz_cen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Inconsistency in the centres file.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz_cen</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz_cen</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># get orbital positions in reduced coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">red_cen</span><span class="o">=</span><span class="n">_cart_to_red</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_cen</span><span class="p">)</span>


<div class="viewcode-block" id="w90.model">
<a class="viewcode-back" href="../usage.html#pythtb.w90.model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">zero_energy</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">min_hopping_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ignorable_imaginary_part</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        This function returns :class:`pythtb.tb_model` object that can</span>
<span class="sd">        be used to interpolate the band structure at arbitrary</span>
<span class="sd">        k-point, analyze the wavefunction character, etc.  </span>

<span class="sd">        The tight-binding basis orbitals in the returned object are</span>
<span class="sd">        maximally localized Wannier functions as computed by</span>
<span class="sd">        Wannier90.  The orbital character of these functions can be</span>
<span class="sd">        inferred either from the *projections* block in the</span>
<span class="sd">        *prefix*.win or from the *prefix*.nnkp file.  Please note that</span>
<span class="sd">        the character of the maximally localized Wannier functions is</span>
<span class="sd">        not exactly the same as that specified by the initial</span>
<span class="sd">        projections.  One way to ensure that the Wannier functions are</span>
<span class="sd">        as close to the initial projections as possible is to first</span>
<span class="sd">        choose a good set of initial projections (for these initial</span>
<span class="sd">        and final spread should not differ more than 20%) and then</span>
<span class="sd">        perform another Wannier90 run setting *num_iter=0* in the</span>
<span class="sd">        *prefix*.win file.</span>

<span class="sd">        Number of spin components is always set to 1, even if the</span>
<span class="sd">        underlying DFT calculation includes spin.  Please refer to the</span>
<span class="sd">        *projections* block or the *prefix*.nnkp file to see which</span>
<span class="sd">        orbitals correspond to which spin.</span>

<span class="sd">        Locations of the orbitals in the returned</span>
<span class="sd">        :class:`pythtb.tb_model` object are equal to the centers of</span>
<span class="sd">        the Wannier functions computed by Wannier90.</span>
<span class="sd">        </span>
<span class="sd">        :param zero_energy: Sets the zero of the energy in the band</span>
<span class="sd">          structure.  This value is typically set to the Fermi level</span>
<span class="sd">          computed by the density-functional code (or to the top of the</span>
<span class="sd">          valence band).  Units are electron-volts.</span>

<span class="sd">        :param min_hopping_norm: Hopping terms read from Wannier90 with</span>
<span class="sd">          complex norm less than *min_hopping_norm* will not be included</span>
<span class="sd">          in the returned tight-binding model.  This parameters is</span>
<span class="sd">          specified in electron-volts.  By default all terms regardless</span>
<span class="sd">          of their norm are included.</span>
<span class="sd">        </span>
<span class="sd">        :param max_distance: Hopping terms from site *i* to site *j+R* will</span>
<span class="sd">          be ignored if the distance from orbital *i* to *j+R* is larger</span>
<span class="sd">          than *max_distance*.  This parameter is given in Angstroms.</span>
<span class="sd">          By default all terms regardless of the distance are included.</span>

<span class="sd">        :param ignorable_imaginary_part: The hopping term will be assumed to</span>
<span class="sd">          be exactly real if the absolute value of the imaginary part as</span>
<span class="sd">          computed by Wannier90 is less than *ignorable_imaginary_part*.</span>
<span class="sd">          By default imaginary terms are not ignored.  Units are again</span>
<span class="sd">          eV.</span>

<span class="sd">        :returns:</span>
<span class="sd">           * **tb** --  The object of type :class:`pythtb.tb_model` that can be used to</span>
<span class="sd">               interpolate Wannier90 band structure to an arbitrary k-point as well</span>
<span class="sd">               as to analyze the character of the wavefunctions.  Please note </span>

<span class="sd">        Example usage::</span>

<span class="sd">          # returns tb_model with all hopping parameters</span>
<span class="sd">          my_model=silicon.model()</span>

<span class="sd">          # simplified model that contains only hopping terms above 0.01 eV</span>
<span class="sd">          my_model_simple=silicon.model(min_hopping_norm=0.01)</span>
<span class="sd">          my_model_simple.display()</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>    

        <span class="c1"># make the model object</span>
        <span class="n">tb</span><span class="o">=</span><span class="n">tb_model</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">red_cen</span><span class="p">)</span>

        <span class="c1"># remember that this model was computed from w90</span>
        <span class="n">tb</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="o">=</span><span class="kc">False</span>

        <span class="c1"># add onsite energies</span>
        <span class="n">onsite</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">):</span>
            <span class="n">tmp_ham</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)][</span><span class="s2">&quot;h&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)][</span><span class="s2">&quot;deg&quot;</span><span class="p">])</span>
            <span class="n">onsite</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">tmp_ham</span><span class="o">.</span><span class="n">real</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp_ham</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">1.0E-9</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Onsite terms should be real!&quot;</span><span class="p">)</span>
        <span class="n">tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="n">onsite</span><span class="o">-</span><span class="n">zero_energy</span><span class="p">)</span>

        <span class="c1"># add hopping terms</span>
        <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">:</span>
            <span class="c1"># avoid double counting</span>
            <span class="n">use_this_R</span><span class="o">=</span><span class="kc">True</span>
            <span class="c1"># avoid onsite terms</span>
            <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">avoid_diagonal</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avoid_diagonal</span><span class="o">=</span><span class="kc">False</span>
                <span class="c1"># avoid taking both R and -R</span>
                <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">use_this_R</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="n">use_this_R</span><span class="o">=</span><span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="n">use_this_R</span><span class="o">=</span><span class="kc">False</span>
            <span class="c1"># get R vector</span>
            <span class="n">vecR</span><span class="o">=</span><span class="n">_red_to_cart</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">2</span><span class="p">]),[</span><span class="n">R</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># scan through unique R</span>
            <span class="k">if</span> <span class="n">use_this_R</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">):</span>
                    <span class="n">vec_i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_cen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">):</span>
                        <span class="n">vec_j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_cen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="c1"># get distance between orbitals</span>
                        <span class="n">dist_ijR</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">vec_i</span><span class="o">+</span><span class="n">vec_j</span><span class="o">+</span><span class="n">vecR</span><span class="p">,</span>
                                                <span class="o">-</span><span class="n">vec_i</span><span class="o">+</span><span class="n">vec_j</span><span class="o">+</span><span class="n">vecR</span><span class="p">))</span>
                        <span class="c1"># to prevent double counting</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">avoid_diagonal</span><span class="o">==</span><span class="kc">True</span> <span class="ow">and</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="p">):</span>
                            
                            <span class="c1"># only if distance between orbitals is small enough</span>
                            <span class="k">if</span> <span class="n">max_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">dist_ijR</span><span class="o">&gt;</span><span class="n">max_distance</span><span class="p">:</span>
                                    <span class="k">continue</span>

                            <span class="c1"># divide the matrix element from w90 with the degeneracy</span>
                            <span class="n">tmp_ham</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">[</span><span class="n">R</span><span class="p">][</span><span class="s2">&quot;h&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">[</span><span class="n">R</span><span class="p">][</span><span class="s2">&quot;deg&quot;</span><span class="p">])</span>

                            <span class="c1"># only if big enough matrix element</span>
                            <span class="k">if</span> <span class="n">min_hopping_norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp_ham</span><span class="p">)</span><span class="o">&lt;</span><span class="n">min_hopping_norm</span><span class="p">:</span>
                                    <span class="k">continue</span>

                            <span class="c1"># remove imaginary part if needed</span>
                            <span class="k">if</span> <span class="n">ignorable_imaginary_part</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp_ham</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="o">&lt;</span><span class="n">ignorable_imaginary_part</span><span class="p">:</span>
                                    <span class="n">tmp_ham</span><span class="o">=</span><span class="n">tmp_ham</span><span class="o">.</span><span class="n">real</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span>

                            <span class="c1"># set the hopping term</span>
                            <span class="n">tb</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span><span class="n">tmp_ham</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">tb</span></div>




<div class="viewcode-block" id="w90.dist_hop">
<a class="viewcode-back" href="../usage.html#pythtb.w90.dist_hop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dist_hop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        This is one of the diagnostic tools that can be used to help</span>
<span class="sd">        in determining *min_hopping_norm* and *max_distance* parameter in</span>
<span class="sd">        :func:`pythtb.w90.model` function call.</span>

<span class="sd">        This function returns all hopping terms (from orbital *i* to</span>
<span class="sd">        *j+R*) as well as the distances between the *i* and *j+R*</span>
<span class="sd">        orbitals.  For well localized Wannier functions hopping term</span>
<span class="sd">        should decay exponentially with distance.</span>

<span class="sd">        :returns:</span>
<span class="sd">           * **dist** --  Distances between Wannier function centers (*i* and *j+R*) in Angstroms.</span>

<span class="sd">           * **ham** --  Corresponding hopping terms in eV.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # get distances and hopping terms</span>
<span class="sd">          (dist,ham)=silicon.dist_hop()</span>

<span class="sd">          # plot logarithm of the hopping term as a function of distance</span>
<span class="sd">          import matplotlib.pyplot as plt</span>
<span class="sd">          fig, ax = plt.subplots()</span>
<span class="sd">          ax.scatter(dist,np.log(np.abs(ham)))</span>
<span class="sd">          fig.savefig(&quot;localization.pdf&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>    

        <span class="n">ret_ham</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">ret_dist</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">:</span>
            <span class="c1"># treat diagonal terms differently</span>
            <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">avoid_diagonal</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avoid_diagonal</span><span class="o">=</span><span class="kc">False</span>

            <span class="c1"># get R vector</span>
            <span class="n">vecR</span><span class="o">=</span><span class="n">_red_to_cart</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">2</span><span class="p">]),[</span><span class="n">R</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">):</span>
                <span class="n">vec_i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_cen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">):</span>
                    <span class="n">vec_j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_cen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="c1"># diagonal terms</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">avoid_diagonal</span><span class="o">==</span><span class="kc">True</span> <span class="ow">and</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">):</span>
                        
                        <span class="c1"># divide the matrix element from w90 with the degeneracy</span>
                        <span class="n">ret_ham</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">[</span><span class="n">R</span><span class="p">][</span><span class="s2">&quot;h&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">[</span><span class="n">R</span><span class="p">][</span><span class="s2">&quot;deg&quot;</span><span class="p">]))</span>

                        <span class="c1"># get distance between orbitals</span>
                        <span class="n">ret_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">vec_i</span><span class="o">+</span><span class="n">vec_j</span><span class="o">+</span><span class="n">vecR</span><span class="p">,</span><span class="o">-</span><span class="n">vec_i</span><span class="o">+</span><span class="n">vec_j</span><span class="o">+</span><span class="n">vecR</span><span class="p">)))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret_dist</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret_ham</span><span class="p">))</span></div>



<div class="viewcode-block" id="w90.shells">
<a class="viewcode-back" href="../usage.html#pythtb.w90.shells">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">num_digits</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        This is one of the diagnostic tools that can be used to help</span>
<span class="sd">        in determining *max_distance* parameter in</span>
<span class="sd">        :func:`pythtb.w90.model` function call.</span>

<span class="sd">        :param num_digits: Distances will be rounded up to these many</span>
<span class="sd">          digits.  Default value is 2.</span>

<span class="sd">        :returns:</span>
<span class="sd">           * **shells** --  All distances between all Wannier function centers (*i* and *j+R*) in Angstroms.</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # prints on screen all shells</span>
<span class="sd">          print(silicon.shells())</span>

<span class="sd">        &quot;&quot;&quot;</span>    

        <span class="n">shells</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_r</span><span class="p">:</span>
            <span class="c1"># get R vector</span>
            <span class="n">vecR</span><span class="o">=</span><span class="n">_red_to_cart</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">2</span><span class="p">]),[</span><span class="n">R</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">):</span>
                <span class="n">vec_i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_cen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">):</span>
                    <span class="n">vec_j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_cen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="c1"># get distance between orbitals</span>
                    <span class="n">dist_ijR</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">vec_i</span><span class="o">+</span><span class="n">vec_j</span><span class="o">+</span><span class="n">vecR</span><span class="p">,</span>
                                             <span class="o">-</span><span class="n">vec_i</span><span class="o">+</span><span class="n">vec_j</span><span class="o">+</span><span class="n">vecR</span><span class="p">))</span>
                    <span class="c1"># round it up</span>
                    <span class="n">shells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">dist_ijR</span><span class="p">,</span><span class="n">num_digits</span><span class="p">))</span>

        <span class="c1"># remove duplicates and sort</span>
        <span class="n">shells</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shells</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">shells</span></div>



<div class="viewcode-block" id="w90.w90_bands_consistency">
<a class="viewcode-back" href="../usage.html#pythtb.w90.w90_bands_consistency">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">w90_bands_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>

<span class="sd">        This function reads in band structure as interpolated by</span>
<span class="sd">        Wannier90.  Please note that this is not the same as the band</span>
<span class="sd">        structure calculated by the underlying DFT code.  The two will</span>
<span class="sd">        agree only on the coarse set of k-points that were used in</span>
<span class="sd">        Wannier90 generation.</span>

<span class="sd">        The purpose of this function is to compare the interpolation</span>
<span class="sd">        in Wannier90 with that in PythTB.  If no terms were ignored in</span>
<span class="sd">        the call to :func:`pythtb.w90.model` then the two should</span>
<span class="sd">        be exactly the same (up to numerical precision).  Otherwise</span>
<span class="sd">        one should expect deviations.  However, if one carefully</span>
<span class="sd">        chooses the cutoff parameters in :func:`pythtb.w90.model`</span>
<span class="sd">        it is likely that one could reproduce the full band-structure</span>
<span class="sd">        with only few dominant hopping terms.  Please note that this</span>
<span class="sd">        tests only the eigenenergies, not eigenvalues (wavefunctions).</span>

<span class="sd">        The code assumes that the following files were generated by</span>
<span class="sd">        Wannier90,</span>

<span class="sd">          - *prefix*\_band.kpt</span>
<span class="sd">          - *prefix*\_band.dat</span>

<span class="sd">        These files will be generated only if the *prefix*.win file</span>
<span class="sd">        contains the *kpoint_path* block.</span>

<span class="sd">        :returns:</span>
<span class="sd">        </span>
<span class="sd">          * **kpts** -- k-points in reduced coordinates used in the</span>
<span class="sd">            interpolation in Wannier90 code.  The format of *kpts* is</span>
<span class="sd">            the same as the one used by the input to</span>
<span class="sd">            :func:`pythtb.tb_model.solve_all`.</span>

<span class="sd">          * **ene** -- energies interpolated by Wannier90 in</span>
<span class="sd">            eV. Format is ene[band,kpoint].</span>

<span class="sd">        Example usage::</span>

<span class="sd">          # get band structure from wannier90</span>
<span class="sd">          (w90_kpt,w90_evals)=silicon.w90_bands_consistency()</span>

<span class="sd">          # get simplified model</span>
<span class="sd">          my_model_simple=silicon.model(min_hopping_norm=0.01)</span>

<span class="sd">          # solve simplified model on the same k-path as in wannier90</span>
<span class="sd">          evals=my_model.solve_all(w90_kpt)</span>
<span class="sd">          </span>
<span class="sd">          # plot comparison of the two</span>
<span class="sd">          import matplotlib.pyplot as plt</span>
<span class="sd">          fig, ax = plt.subplots() </span>
<span class="sd">          for i in range(evals.shape[0]):</span>
<span class="sd">              ax.plot(range(evals.shape[1]),evals[i],&quot;r-&quot;,zorder=-50)</span>
<span class="sd">          for i in range(w90_evals.shape[0]):</span>
<span class="sd">              ax.plot(range(w90_evals.shape[1]),w90_evals[i],&quot;k-&quot;,zorder=-100)</span>
<span class="sd">          fig.savefig(&quot;comparison.pdf&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># read in kpoints in reduced coordinates</span>
        <span class="n">kpts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s2">&quot;_band.kpt&quot;</span><span class="p">,</span><span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ignore weights</span>
        <span class="n">kpts</span><span class="o">=</span><span class="n">kpts</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># read in energies</span>
        <span class="n">ene</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s2">&quot;_band.dat&quot;</span><span class="p">)</span>
        <span class="c1"># ignore kpath distance</span>
        <span class="n">ene</span><span class="o">=</span><span class="n">ene</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># correct shape </span>
        <span class="n">ene</span><span class="o">=</span><span class="n">ene</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_wan</span><span class="p">,</span><span class="n">kpts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">kpts</span><span class="p">,</span><span class="n">ene</span><span class="p">)</span></div>
</div>


<span class="c1">#=======================================================================</span>
<span class="c1"># Begin internal definitions</span>
<span class="c1">#=======================================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_nicefy_eig</span><span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">eig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">&quot;Sort eigenvaules and eigenvectors, if given, and convert to real numbers&quot;</span>
    <span class="c1"># first take only real parts of the eigenvalues</span>
    <span class="nb">eval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">eval</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># sort energies</span>
    <span class="n">args</span><span class="o">=</span><span class="nb">eval</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="nb">eval</span><span class="o">=</span><span class="nb">eval</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">eig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">eig</span><span class="o">=</span><span class="n">eig</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">eval</span><span class="p">,</span><span class="n">eig</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">eval</span>

<span class="c1"># for nice justified printout</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_nice_float</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">just</span><span class="p">,</span><span class="n">rnd</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">rnd</span><span class="p">))</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">just</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_nice_int</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">just</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">just</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_nice_complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">just</span><span class="p">,</span><span class="n">rnd</span><span class="p">):</span>
    <span class="n">ret</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">ret</span><span class="o">+=</span><span class="n">_nice_float</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">just</span><span class="p">,</span><span class="n">rnd</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="o">&lt;</span><span class="mf">0.0</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">+=</span><span class="s2">&quot; - &quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">+=</span><span class="s2">&quot; + &quot;</span>
    <span class="n">ret</span><span class="o">+=</span><span class="n">_nice_float</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="p">),</span><span class="n">just</span><span class="p">,</span><span class="n">rnd</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">+=</span><span class="s2">&quot; i&quot;</span>
    <span class="k">return</span> <span class="n">ret</span>
    
<span class="k">def</span><span class="w"> </span><span class="nf">_wf_dpr</span><span class="p">(</span><span class="n">wf1</span><span class="p">,</span><span class="n">wf2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;calculate dot product between two wavefunctions.</span>
<span class="sd">    wf1 and wf2 are of the form [orbital,spin]&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wf1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span><span class="n">wf2</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_one_berry_loop</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span><span class="n">berry_evals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Do one Berry phase calculation (also returns a product of M</span>
<span class="sd">    matrices).  Always returns numbers between -pi and pi.  wf has</span>
<span class="sd">    format [kpnt,band,orbital,spin] and kpnt has to be one dimensional.</span>
<span class="sd">    Assumes that first and last k-point are the same. Therefore if</span>
<span class="sd">    there are n wavefunctions in total, will calculate phase along n-1</span>
<span class="sd">    links only!  If berry_evals is True then will compute phases for</span>
<span class="sd">    individual states, these corresponds to 1d hybrid Wannier</span>
<span class="sd">    function centers. Otherwise just return one number, Berry phase.&quot;&quot;&quot;</span>
    <span class="c1"># number of occupied states</span>
    <span class="n">nocc</span><span class="o">=</span><span class="n">wf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># temporary matrices</span>
    <span class="n">prd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nocc</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ovr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nocc</span><span class="p">,</span><span class="n">nocc</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1"># go over all pairs of k-points, assuming that last point is overcounted!</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># generate overlap matrix, go over all bands</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nocc</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nocc</span><span class="p">):</span>
                <span class="n">ovr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">_wf_dpr</span><span class="p">(</span><span class="n">wf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:],</span><span class="n">wf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,:])</span>
        <span class="c1"># only find Berry phase</span>
        <span class="k">if</span> <span class="n">berry_evals</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="c1"># multiply overlap matrices</span>
            <span class="n">prd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prd</span><span class="p">,</span><span class="n">ovr</span><span class="p">)</span>
        <span class="c1"># also find phases of individual eigenvalues</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># cleanup matrices with SVD then take product</span>
            <span class="n">matU</span><span class="p">,</span><span class="n">sing</span><span class="p">,</span><span class="n">matV</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">ovr</span><span class="p">)</span>
            <span class="n">prd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prd</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matU</span><span class="p">,</span><span class="n">matV</span><span class="p">))</span>
    <span class="c1"># calculate Berry phase</span>
    <span class="k">if</span> <span class="n">berry_evals</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
        <span class="n">det</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">prd</span><span class="p">)</span>
        <span class="n">pha</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">det</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pha</span>
    <span class="c1"># calculate phases of all eigenvalues</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">evals</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">prd</span><span class="p">)</span>
        <span class="n">eval_pha</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span>
        <span class="c1"># sort these numbers as well</span>
        <span class="n">eval_pha</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">eval_pha</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eval_pha</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_one_flux_plane</span><span class="p">(</span><span class="n">wfs2d</span><span class="p">):</span>
    <span class="s2">&quot;Compute fluxes on a two-dimensional plane of states.&quot;</span>
    <span class="c1"># size of the mesh</span>
    <span class="n">nk0</span><span class="o">=</span><span class="n">wfs2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nk1</span><span class="o">=</span><span class="n">wfs2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># number of bands (will compute flux of all bands taken together)</span>
    <span class="n">nbnd</span><span class="o">=</span><span class="n">wfs2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># here store flux through each plaquette of the mesh</span>
    <span class="n">all_phases</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nk0</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nk1</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># go over all plaquettes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk0</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk1</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># generate a small loop made out of four pieces</span>
            <span class="n">wf_use</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">wf_use</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
            <span class="n">wf_use</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs2d</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
            <span class="n">wf_use</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs2d</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">wf_use</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">wf_use</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
            <span class="n">wf_use</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wf_use</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="c1"># calculate phase around one plaquette</span>
            <span class="n">all_phases</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">_one_berry_loop</span><span class="p">(</span><span class="n">wf_use</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">all_phases</span>

<span class="k">def</span><span class="w"> </span><span class="nf">no_2pi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">clos</span><span class="p">):</span>
    <span class="s2">&quot;Make x as close to clos by adding or removing 2pi&quot;</span>
    <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">clos</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">clos</span><span class="o">-</span><span class="n">x</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">x</span><span class="o">+=</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="n">clos</span><span class="o">-</span><span class="n">x</span><span class="o">&lt;-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">x</span><span class="o">-=</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_one_phase_cont</span><span class="p">(</span><span class="n">pha</span><span class="p">,</span><span class="n">clos</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reads in 1d array of numbers *pha* and makes sure that they are</span>
<span class="sd">    continuous, i.e., that there are no jumps of 2pi. First number is</span>
<span class="sd">    made as close to *clos* as possible.&quot;&quot;&quot;</span>
    <span class="n">ret</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pha</span><span class="p">)</span>
    <span class="c1"># go through entire list and &quot;iron out&quot; 2pi jumps</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)):</span>
        <span class="c1"># which number to compare to</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">cmpr</span><span class="o">=</span><span class="n">clos</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">cmpr</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># make sure there are no 2pi jumps</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">no_2pi</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">cmpr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_array_phases_cont</span><span class="p">(</span><span class="n">arr_pha</span><span class="p">,</span><span class="n">clos</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reads in 2d array of phases *arr_pha* and makes sure that they</span>
<span class="sd">    are continuous along first index, i.e., that there are no jumps of</span>
<span class="sd">    2pi. First array of phasese is made as close to *clos* as</span>
<span class="sd">    possible.&quot;&quot;&quot;</span>
    <span class="n">ret</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">arr_pha</span><span class="p">)</span>
    <span class="c1"># go over all points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr_pha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># which phases to compare to</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">cmpr</span><span class="o">=</span><span class="n">clos</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">cmpr</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="c1"># remember which indices are still available to be matched</span>
        <span class="n">avail</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arr_pha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># go over all phases in cmpr[:]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cmpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># minimal distance between pairs</span>
            <span class="n">min_dist</span><span class="o">=</span><span class="mf">1.0E10</span>
            <span class="c1"># closest index</span>
            <span class="n">best_k</span><span class="o">=</span><span class="kc">None</span>
            <span class="c1"># go over each phase in arr_pha[i,:]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">avail</span><span class="p">:</span>
                <span class="n">cur_dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="n">cmpr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="n">arr_pha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">cur_dist</span><span class="o">&lt;=</span><span class="n">min_dist</span><span class="p">:</span>
                    <span class="n">min_dist</span><span class="o">=</span><span class="n">cur_dist</span>
                    <span class="n">best_k</span><span class="o">=</span><span class="n">k</span>
            <span class="c1"># remove this index from being possible pair later</span>
            <span class="n">avail</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">avail</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">best_k</span><span class="p">))</span>
            <span class="c1"># store phase in correct place</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">arr_pha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">best_k</span><span class="p">]</span>
            <span class="c1"># make sure there are no 2pi jumps</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">no_2pi</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">cmpr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span>



<span class="k">def</span><span class="w"> </span><span class="nf">_cart_to_red</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">cart</span><span class="p">):</span>
    <span class="s2">&quot;Convert cartesian vectors cart to reduced coordinates of a1,a2,a3 vectors&quot;</span>
    <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span><span class="p">)</span><span class="o">=</span><span class="n">tmp</span>
    <span class="c1"># matrix with lattice vectors</span>
    <span class="n">cnv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span><span class="p">])</span>
    <span class="c1"># transpose a matrix</span>
    <span class="n">cnv</span><span class="o">=</span><span class="n">cnv</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># invert a matrix</span>
    <span class="n">cnv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cnv</span><span class="p">)</span>
    <span class="c1"># reduced coordinates</span>
    <span class="n">red</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cart</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">cart</span><span class="p">)):</span>
        <span class="n">red</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cnv</span><span class="p">,</span><span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">red</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_red_to_cart</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">red</span><span class="p">):</span>
    <span class="s2">&quot;Convert reduced to cartesian vectors.&quot;</span>
    <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span><span class="p">)</span><span class="o">=</span><span class="n">tmp</span>
    <span class="c1"># cartesian coordinates</span>
    <span class="n">cart</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">red</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">cart</span><span class="p">)):</span>
        <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="n">a1</span><span class="o">*</span><span class="n">red</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">a2</span><span class="o">*</span><span class="n">red</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">a3</span><span class="o">*</span><span class="n">red</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cart</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_is_int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_offdiag_approximation_warning_and_stop</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">----------------------------------------------------------------------</span>

<span class="s2">  It looks like you are trying to calculate Berry-like object that</span>
<span class="s2">  involves position operator.  However, you are using a tight-binding</span>
<span class="s2">  model that was generated from Wannier90.  This procedure introduces</span>
<span class="s2">  approximation as it ignores off-diagonal elements of the position</span>
<span class="s2">  operator in the Wannier basis.  This is discussed here in more</span>
<span class="s2">  detail:</span>

<span class="s2">    http://www.physics.rutgers.edu/pythtb/usage.html#pythtb.w90</span>

<span class="s2">  If you know what you are doing and wish to continue with the</span>
<span class="s2">  calculation despite this approximation, please call the following</span>
<span class="s2">  function on your tb_model object</span>

<span class="s2">    my_model.ignore_position_operator_offdiagonal()</span>

<span class="s2">----------------------------------------------------------------------</span>

<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">PythTB</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../formalism.html">Formalism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citation.html">Citation</a></li>
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PythTB 1.8.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pythtb</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2016, Sinisa Coh and David Vanderbilt.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>