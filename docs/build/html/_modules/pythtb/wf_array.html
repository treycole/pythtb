
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pythtb.wf_array &#8212; PythTB Docs</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css?v=7f9a90b1" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=1a152b8d" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=7f41d439"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=cbcfbdad"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pythtb/wf_array';</script>
    <script defer="defer" src="../../_static/custom-icons.js?v=7518156e"></script>
    <script src="https://unpkg.com/thebe@latest/lib/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">PythTB Docs</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../about.html">
    About
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../install.html">
    Install
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../CHANGELOG.html">
    Changelog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../formalism.html">
    Formalism
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../resources.html">
    Resources
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../citation.html">
    Citation
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/treycole/pythtb" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pythtb/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../about.html">
    About
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../install.html">
    Install
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../CHANGELOG.html">
    Changelog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../formalism.html">
    Formalism
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../resources.html">
    Resources
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../citation.html">
    Citation
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/treycole/pythtb" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pythtb/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">pythtb.wf_array</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pythtb.wf_array</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_is_int</span><span class="p">,</span> <span class="n">_offdiag_approximation_warning_and_stop</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.tb_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">TBModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mesh</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>  <span class="c1"># for deepcopying</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WFArray&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="WFArray">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WFArray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This class is used to store and manipulate an array of</span>
<span class="sd">    wavefunctions of a tight-binding model</span>
<span class="sd">    :class:`pythtb.TBModel` on a regular or non-regular grid.</span>
<span class="sd">    These could be the Bloch energy eigenstates of the</span>
<span class="sd">    model, but could also be a subset of Bloch bands, </span>
<span class="sd">    a set of hybrid Wannier functions for a ribbon or slab, </span>
<span class="sd">    or any other set of wavefunctions that are expressed in terms </span>
<span class="sd">    of the underlying basis orbitals. It provides methods that can</span>
<span class="sd">    be used to calculate Berry phases, Berry curvatures,</span>
<span class="sd">    first Chern numbers, etc.</span>

<span class="sd">    The wavevectors stored in *WFArray* are typically Hamiltonian</span>
<span class="sd">    eigenstates (e.g., Bloch functions for k-space arrays),</span>
<span class="sd">    with the *state* index running over all bands. However, a</span>
<span class="sd">    *WFArray* object can also be used for other purposes, such</span>
<span class="sd">    as to store only a restricted set of Bloch states (e.g.,</span>
<span class="sd">    just the occupied ones); a set of modified Bloch states</span>
<span class="sd">    (e.g., premultiplied by a position, velocity, or Hamiltonian</span>
<span class="sd">    operator); or for hybrid Wannier functions (i.e., eigenstates</span>
<span class="sd">    of a position operator in a nonperiodic direction).</span>

<span class="sd">    *Regular k-space grid*:</span>
<span class="sd">    If the grid is a regular k-mesh (no parametric dimensions),</span>
<span class="sd">    a single call to the function :func:`pythtb.WFArray.solve_on_grid` </span>
<span class="sd">    will both construct a k-mesh that uniformly covers the Brillouin zone, </span>
<span class="sd">    and populate it with the energy eigenvectors computed on this grid.</span>
<span class="sd">    This function will ensure that the last point along each k-dimension is </span>
<span class="sd">    the same Bloch function as the first one multiplied by a phase factor to</span>
<span class="sd">    ensure the periodic boundary conditions are satisfied (see notes below).</span>

<span class="sd">    *Parametric or irregular k-space grid grid*:</span>
<span class="sd">    An irregular grid of points, or a grid that includes also</span>
<span class="sd">    one or more parametric dimensions, can be populated manually</span>
<span class="sd">    using the ``[]`` operator (see example below). The wavefunctions</span>
<span class="sd">    above are expected to be in the format `evec[state, orbital]`</span>
<span class="sd">    (or `evec[state, orbital, spin]` for the spinfull calculation).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    model : :class:`pythtb.TBModel`</span>
<span class="sd">        A :class:`pythtb.TBModel` representing</span>
<span class="sd">        the tight-binding model associated with this array of eigenvectors.</span>

<span class="sd">    mesh_size: list, tuple</span>
<span class="sd">        A list or tuple specifying the size of the mesh of points</span>
<span class="sd">        in the order of reciprocal-space and/or parametric directions.</span>

<span class="sd">    nstates : int, optional</span>
<span class="sd">        Optional parameter specifying the number of states</span>
<span class="sd">        packed into the *WFArray* at each point on the mesh. Defaults</span>
<span class="sd">        to all states (i.e., `norb*nspin`).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :ref:`haldane-bp-nb` : For an example of using WFArray on a regular grid of points in k-space.</span>

<span class="sd">    :ref:`cone-nb` : For an example of using WFArray on a non-regular grid of points in k-space.</span>

<span class="sd">    :ref:`3site-cycle-nb` : For an example of using `WFArray` on a non-regular grid of points in parameter space.</span>
<span class="sd">        This example shows how one of the directions of *WFArray* object need not be a k-vector direction, </span>
<span class="sd">        but can instead be a Hamiltonian parameter :math:`\lambda`. See also discussion after equation 4.1 in</span>
<span class="sd">        :ref:`formalism`.</span>

<span class="sd">    :ref:`cubic-slab-hwf-nb` : For an example of using `WFArray` to store hybrid Wannier functions.</span>

<span class="sd">    :func:`pythtb.TBModel.solve_ham`</span>

<span class="sd">    :ref:`formalism`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When using :func:`pythtb.WFArray.solve_on_grid` the last wavefunction along each mesh dimension</span>
<span class="sd">    is stored according the the boundary conditions </span>

<span class="sd">    .. math::</span>

<span class="sd">        u_{n, \mathbf{k} + \mathbf{G}}(\mathbf{r}) = e^{-i \mathbf{G} \cdot \mathbf{r}} u_{n, \mathbf{k}}(\mathbf{r})</span>

<span class="sd">    where :math:`\mathbf{G}` is a reciprocal lattice vector and :math:`\mathbf{r}` is the position vector.</span>
<span class="sd">    See section 4.4 in :download:`notes on tight-binding formalism &lt;/misc/pythtb-formalism.pdf&gt;` for more details.</span>


<span class="sd">    If WFArray is used for closed paths, either in a</span>
<span class="sd">    reciprocal-space or parametric direction, then one needs to</span>
<span class="sd">    include both the starting and ending eigenfunctions even though</span>
<span class="sd">    they are physically equivalent. If the array dimension in</span>
<span class="sd">    question is a k-vector direction and the path traverses the</span>
<span class="sd">    Brillouin zone in a primitive reciprocal-lattice direction,</span>
<span class="sd">    :func:`pythtb.WFArray.impose_pbc` can be used to associate</span>
<span class="sd">    the starting and ending points with each other. If it is a</span>
<span class="sd">    non-winding loop in k-space or a loop in parameter space,</span>
<span class="sd">    then :func:`pythtb.WFArray.impose_loop` can be used instead.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Construct `WFArray` capable of storing an 11x21 array of</span>
<span class="sd">    wavefunctions</span>

<span class="sd">    &gt;&gt;&gt; wf = WFArray(tb, [11, 21])</span>

<span class="sd">    Populate this `WFArray` with regular grid of points in</span>
<span class="sd">    Brillouin zone</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; wf.solve_on_grid([0.0, 0.0])</span>

<span class="sd">    Compute set of eigenvectors at one k-point</span>

<span class="sd">    &gt;&gt;&gt; eval, evec = tb.solve_one([kx, ky], eig_vectors = True)</span>
<span class="sd">    </span>
<span class="sd">    Store it manually into a specified location in the array</span>

<span class="sd">    &gt;&gt;&gt; wf[3,4] = evec</span>
<span class="sd">    </span>
<span class="sd">    To access the eigenvectors from the same position</span>

<span class="sd">    &gt;&gt;&gt; print(wf[3,4])</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WFArray.__init__">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">TBModel</span><span class="p">,</span> <span class="n">mesh</span><span class="p">:</span> <span class="n">Mesh</span><span class="p">,</span> <span class="n">nstates</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># TODO: We would like to have a KMesh object associated with the WFArray</span>
        <span class="c1"># this way we can store information about the k-points corresponding to each</span>
        <span class="c1"># point in the WFArray, and also the k-points can be used to impose PBC automatically.</span>
        <span class="c1"># To do this, the user needs to specify the k-points when constructing the WFArray.</span>
        <span class="c1"># Some dimensions of the mesh may be adiabatic parameters, or paths in k-space. Somehow</span>
        <span class="c1"># this should be distinguished from the regular k-mesh.</span>

        <span class="c1"># check that model is of type TBModel</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">TBModel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;model must be of type TBModel&quot;</span><span class="p">)</span>
         <span class="c1"># store model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="c1"># check that mesh is of type Mesh</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">Mesh</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mesh must be of type Mesh&quot;</span><span class="p">)</span>
        
        <span class="c1"># store mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
        
        <span class="c1"># derive mesh dimensions from the Mesh object</span>
        <span class="c1"># mesh.grid has shape (*dims, coord_dim)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># ensure each mesh dimension is at least 2</span>
        <span class="c1"># all dimensions should be 2 or larger, because pbc can be used</span>
        <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Dimension of WFArray object in each direction must be 2 or larger.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># number of electronic states for each k-point</span>
        <span class="k">if</span> <span class="n">nstates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nstates</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">nstate</span>  <span class="c1"># this = norb*nspin = no. of bands</span>
            <span class="c1"># note: &#39;None&#39; means to use the default, which is all bands!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">nstates</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Argument nstates is not an integer.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nstates</span> <span class="o">=</span> <span class="n">nstates</span>  <span class="c1"># set by optional argument</span>

        <span class="c1"># number of spin components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">nspin</span>
        <span class="c1"># number of orbitals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">norb</span>
        <span class="c1"># store orbitals from the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">orb_vecs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pbc_axes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># axes along which periodic boundary conditions are imposed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loop_axes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># axes along which loops are imposed</span>
        <span class="c1"># generate temporary array used later to generate object ._wfs</span>
        <span class="n">wfs_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span><span class="p">)</span>
        <span class="n">wfs_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nstates</span><span class="p">)</span>
        <span class="n">wfs_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">wfs_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfs_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span>

        <span class="c1"># store wavefunctions in the form [kx_index, ky_index,..., state, orb, spin]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">wfs_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nstates</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># key is an index list specifying the grid point of interest</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_mesh</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Key should be an integer or a tuple of length 1!&quot;</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># convert to integer</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Key should be an integer!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Key outside the range!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_mesh</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong dimensionality of key!&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Key should be set of integers!&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Key outside the range!&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The wavefunctions stored in the *WFArray* object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of the wavefunction array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mesh_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The mesh dimensions of the *WFArray* object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dim_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of dimensions of the *WFArray* object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_mesh</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pbc_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The axes along which periodic boundary conditions are imposed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pbc_axes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">loop_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The axes along which loops are imposed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loop_axes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nstates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of states (or bands) stored in the *WFArray* object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nstates</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nspin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of spin components stored in the *WFArray* object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">norb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of orbitals stored in the *WFArray* object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The underlying TBModel object associated with the *WFArray*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">param_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The parameter path (e.g., k-points) along which the model was solved.</span>
<span class="sd">        This is only set if the model was solved along a path using `solve_on_path`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_param_path&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flat_k_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns a flattened version of the k-mesh used in the *WFArray*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_k_mesh_flat&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">k_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the KMesh object associated with the *WFArray*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_k_mesh_square&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">energies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the energies of the states stored in the *WFArray*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_energies&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="WFArray.get_states">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.get_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flatten_spin</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns states stored in the WFArray.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flatten_spin : bool, optional</span>
<span class="sd">            If True, the spin and orbital indices are flattened into a single index and</span>
<span class="sd">            the shape of the returned states will be [nk1, ..., nkd, [n_lambda,] n_state, n_orb * n_spin].</span>
<span class="sd">            If False, the original shape is preserved, [nk1, ..., nkd, [n_lambda,] n_state, n_orb, n_spin].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        states : np.ndarray</span>
<span class="sd">            The wavefunctions stored in the WFArray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># shape is [nk1, ..., nkd, [n_lambda,] n_state, n_orb[, n_spin]</span>
        <span class="n">wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfs</span>

        <span class="c1"># flatten last two axes together to condense spin and orbital indices</span>
        <span class="k">if</span> <span class="n">flatten_spin</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">wfs</span> <span class="o">=</span> <span class="n">wfs</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="n">wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">wfs</span></div>


<div class="viewcode-block" id="WFArray.get_bloch_states">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.get_bloch_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_bloch_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flatten_spin</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns Bloch and cell-periodic states from the WFArray.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flatten_spin : bool, optional</span>
<span class="sd">            If True, the spin and orbital indices are flattened into a single index and</span>
<span class="sd">            the shape of the returned states will be [nk1, ..., nkd, [n_lambda,] n_state, n_orb * n_spin].</span>
<span class="sd">            If False, the original shape is preserved, [nk1, ..., nkd, [n_lambda,] n_state, n_orb, n_spin].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        states : dict</span>
<span class="sd">            A dictionary containing the &quot;bloch&quot; and &quot;cell&quot; states.  The returned dictionary </span>
<span class="sd">            has the following keys:</span>

<span class="sd">            - &quot;bloch&quot;: Bloch states (periodic in k-space) :math:`\psi_{n\mathbf{k}}(\mathbf{r})`</span>

<span class="sd">            - &quot;cell&quot;: Cell-periodic states (periodic in real space) :math:`u_{n\mathbf{k}}(\mathbf{r})`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_states : For obtaining the states stored on the mesh only.</span>

<span class="sd">        :ref:`formalism`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function assumes that the WFArray is defined on a regular k-mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># shape is [nk1, ..., nkd, [n_lambda,] n_state, n_orb[, n_spin]</span>
        <span class="n">u_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfs</span>

        <span class="c1"># make sure that u_wfs is consistent with being defined on a regular k-mesh</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dim_k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;WFArray is initialized for a mesh of dimensions </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but the model has dim_k = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dim_k</span><span class="si">}</span><span class="s2">. Bloch states assumes the&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;WFArray is defined on a regular k-mesh.&quot;</span>
            <span class="p">)</span>

        <span class="n">psi_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_phase</span><span class="p">(</span><span class="n">wfs</span><span class="o">=</span><span class="n">u_wfs</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># flatten last two axes together to condense spin and orbital indices</span>
        <span class="k">if</span> <span class="n">flatten_spin</span><span class="p">:</span>
            <span class="n">u_wfs</span> <span class="o">=</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="n">u_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">psi_wfs</span> <span class="o">=</span> <span class="n">psi_wfs</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="n">psi_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">return_states</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;cell&quot;</span><span class="p">:</span> <span class="n">u_wfs</span><span class="p">,</span>
            <span class="s2">&quot;bloch&quot;</span><span class="p">:</span> <span class="n">psi_wfs</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">return_states</span></div>


<div class="viewcode-block" id="WFArray.get_projectors">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.get_projectors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_projectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_Q</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the band projectors associated with the states in the WFArray.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        The band projectors are defined as the outer product of the wavefunctions:</span>

<span class="sd">        .. math::</span>

<span class="sd">            P_{n\mathbf{k}} = |u_{n\mathbf{k}}(\mathbf{r})\rangle \langle u_{n\mathbf{k}}(\mathbf{r})| \\</span>
<span class="sd">            Q_{n\mathbf{k}} = \mathbb{I} - P_{n\mathbf{k}}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        return_Q : bool, optional</span>
<span class="sd">            If True, the function also returns the orthogonal projector Q.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        P : np.ndarray</span>
<span class="sd">            The band projectors.</span>
<span class="sd">        Q : np.ndarray, optional</span>
<span class="sd">            The orthogonal projectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">(</span><span class="n">flatten_spin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># band projectors</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ni, ...nj -&gt; ...ij&quot;</span><span class="p">,</span> <span class="n">u_wfs</span><span class="p">,</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">)</span> <span class="o">-</span> <span class="n">P</span>

        <span class="k">if</span> <span class="n">return_Q</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span>
        <span class="k">return</span> <span class="n">P</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_k_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve the Hamiltonian on the k-mesh for a given parameter slice.&quot;&quot;&quot;</span>
        <span class="n">dim_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">dim_k</span>
        <span class="n">shape_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">shape_k</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="n">shape_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">shape_param</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape_k</span><span class="p">))</span> <span class="k">if</span> <span class="n">shape_k</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">Np</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape_param</span><span class="p">))</span> <span class="k">if</span> <span class="n">shape_param</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="c1"># Parameter index check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">dim_param</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lambda_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lambda_idx must be provided when mesh has parameter dimensions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lambda_idx</span> <span class="o">&lt;</span> <span class="n">Np</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lambda_idx </span><span class="si">{</span><span class="n">lambda_idx</span><span class="si">}</span><span class="s2"> out of range [0, </span><span class="si">{</span><span class="n">Np</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
            <span class="n">k_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">lambda_idx</span><span class="p">,</span> <span class="p">:</span><span class="n">dim_k</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">dim_param</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">grid</span>
            <span class="c1"># flatten</span>
            <span class="n">k_pts</span> <span class="o">=</span> <span class="n">k_pts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim_k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ignore lambda_idx if no parameter dimensions</span>
            <span class="n">lambda_idx</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">k_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">flat</span>

        <span class="c1"># Solve Hamiltonian</span>
        <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span><span class="n">k_pts</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">evals_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape_k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">,)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nspin</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">evecs_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape_k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">norb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nspin</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evecs_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape_k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">)</span>

        <span class="n">evecs</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">evecs_shape</span><span class="p">)</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="n">evals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">evals_shape</span><span class="p">)</span>

        <span class="c1"># Now set the WFArray at the lambda_idx</span>
        <span class="k">if</span> <span class="n">lambda_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slice_wfs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_k</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">lambda_idx</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_wfs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_k</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">slice_wfs</span><span class="p">]</span> <span class="o">=</span> <span class="n">evecs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">slice_wfs</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span>


    <span class="c1"># TODO: Figure out how to solve over lambda as well</span>
    <span class="c1"># May want to pass model constructor to generate Hamiltonians along lambda </span>
    <span class="c1"># dimension</span>
<div class="viewcode-block" id="WFArray.solve_k_mesh">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.solve_k_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_k_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">auto_detect_pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve the Hamiltonian on the k-mesh for a given parameter slice.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lambda_idx : int, optional</span>
<span class="sd">            The index of the parameter slice to solve for. If None, solves for all slices.</span>

<span class="sd">        auto_detect_pbc : bool, optional</span>
<span class="sd">            If True, automatically detects and imposes periodic boundary conditions (PBC) for the k-mesh.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">dim_k</span>
        <span class="n">shape_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">shape_k</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="n">shape_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">shape_param</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape_k</span><span class="p">))</span> <span class="k">if</span> <span class="n">shape_k</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">Np</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape_param</span><span class="p">))</span> <span class="k">if</span> <span class="n">shape_param</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="c1"># Parameter index check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">dim_param</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lambda_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lambda_idx must be provided when mesh has parameter dimensions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lambda_idx</span> <span class="o">&lt;</span> <span class="n">Np</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lambda_idx </span><span class="si">{</span><span class="n">lambda_idx</span><span class="si">}</span><span class="s2"> out of range [0, </span><span class="si">{</span><span class="n">Np</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
            <span class="n">k_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">lambda_idx</span><span class="p">,</span> <span class="p">:</span><span class="n">dim_k</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">dim_param</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">grid</span>
            <span class="c1"># flatten</span>
            <span class="n">k_pts</span> <span class="o">=</span> <span class="n">k_pts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim_k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ignore lambda_idx if no parameter dimensions</span>
            <span class="n">lambda_idx</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">k_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">flat</span>

        <span class="c1"># Solve Hamiltonian</span>
        <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span><span class="n">k_pts</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">evals_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape_k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">,)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nspin</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">evecs_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape_k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">norb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nspin</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evecs_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape_k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">)</span>

        <span class="n">evecs</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">evecs_shape</span><span class="p">)</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="n">evals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">evals_shape</span><span class="p">)</span>

        <span class="c1"># Now set the WFArray at the lambda_idx</span>
        <span class="k">if</span> <span class="n">lambda_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slice_wfs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_k</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">lambda_idx</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_wfs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_k</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="n">slice_wfs</span><span class="p">]</span> <span class="o">=</span> <span class="n">evecs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">slice_wfs</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span>

        <span class="c1"># auto-detect and impose PBC for each k-component axis</span>
        <span class="k">if</span> <span class="n">auto_detect_pbc</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">grid</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># mesh shape</span>
            <span class="n">dim_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">dim_k</span>
            <span class="k">for</span> <span class="n">mesh_dir</span><span class="p">,</span> <span class="n">k_comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mesh</span><span class="o">.</span><span class="n">k_axes</span><span class="p">):</span>
                <span class="c1"># Take slices along mesh_dir at beginning and end</span>
                <span class="n">slc_first</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">slc_last</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">slc_first</span><span class="p">[</span><span class="n">mesh_dir</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">slc_last</span><span class="p">[</span><span class="n">mesh_dir</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">slc_first</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slc_first</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">k_comp</span><span class="p">,)</span>
                <span class="n">slc_last</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slc_last</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">k_comp</span><span class="p">,)</span>
                <span class="n">vals_first</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">slc_first</span><span class="p">]</span>
                <span class="n">vals_last</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">slc_last</span><span class="p">]</span>

                <span class="c1"># Compare the arrays to detect PBC</span>
                <span class="c1"># Check if the difference is close to 1.0 (wraps BZ)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">vals_last</span> <span class="o">-</span> <span class="n">vals_first</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto-imposing PBC in mesh direction </span><span class="si">{</span><span class="n">mesh_dir</span><span class="si">}</span><span class="s2"> for k-component </span><span class="si">{</span><span class="n">k_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">impose_pbc</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">,</span> <span class="n">k_comp</span><span class="p">)</span></div>



<div class="viewcode-block" id="WFArray.solve_on_path">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.solve_on_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_on_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_arr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the model along a 1D parameter path (e.g., k-points).</span>
<span class="sd">        Stores eigenvectors and eigenvalues along this path.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_arr : array-like, shape (n_points, dim_k)</span>
<span class="sd">            Sequence of points (e.g., k-points) at which to solve the model.</span>
<span class="sd">            Must match the model&#39;s dim_k and the WFArray&#39;s mesh_size[0].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        energies : ndarray, shape (n_points, nstates)</span>
<span class="sd">            Eigenvalues at each point along the path.</span>
<span class="sd">        wfs : ndarray, shape (n_points, nstates, norb[, nspin])</span>
<span class="sd">            Corresponding eigenvectors stored in the WFArray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k_arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># check dimensionality</span>
        <span class="k">if</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dim_k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected k_arr to have shape (n_points, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dim_k</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but got shape </span><span class="si">{</span><span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># check that the number of points matches the mesh size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_points</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;WFArray is initialized for a mesh size of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but k_arr has </span><span class="si">{</span><span class="n">n_points</span><span class="si">}</span><span class="s2"> points.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_path</span> <span class="o">=</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span><span class="n">k_arr</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k_arr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[(</span><span class="n">idx</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>



<div class="viewcode-block" id="WFArray.solve_on_grid">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.solve_on_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_on_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Solve a tight-binding model on a regular mesh of k-points.</span>

<span class="sd">        The regular mesh of k-points covers the entire reciprocal-space unit cell. </span>
<span class="sd">        Both points at the opposite sides of reciprocal-space unit cell are included </span>
<span class="sd">        in the array. The spacing between points is defined by the mesh size specified </span>
<span class="sd">        upon initialization. The end point is ``[start_k[0]+1, start_k[1]+1]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_k : array-like (dim_k,), optional</span>
<span class="sd">            The starting point of the k-mesh in reciprocal space. If not specified,</span>
<span class="sd">            defaults to [0, 0] for 2D systems, [0, 0, 0] for 3D systems, etc. The</span>
<span class="sd">            starting point along each dimension must be in the range [-0.5, 0.5].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gaps : ndarray</span>
<span class="sd">            The minimal direct bandgap between `n`-th and `n+1`-th band on </span>
<span class="sd">            all the k-points in the mesh.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`pythtb.WFArray.impose_pbc`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        One may have to use a dense k-mesh to resolve the highly-dispersive crossings.</span>

<span class="sd">        This function also automatically imposes periodic boundary</span>
<span class="sd">        conditions on the eigenfunctions. See also the discussion in</span>
<span class="sd">        :func:`pythtb.WFArray.impose_pbc`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Solve eigenvectors on a regular grid anchored at ``[-0.5, -0.5]``</span>
<span class="sd">        so that the mesh is defined from ``[-0.5, -0.5]`` to ``[0.5, 0.5]``.</span>

<span class="sd">        &gt;&gt;&gt; wf.solve_on_grid([-0.5, -0.5])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span>
            <span class="n">start_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># check dimensionality</span>
            <span class="k">if</span> <span class="n">start_k</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">start_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected start_k to have shape (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="si">}</span><span class="s2">,), &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but got shape </span><span class="si">{</span><span class="n">start_k</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            
        <span class="c1"># check values</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">start_k</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">start_k</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected start_k to be in the range [-0.5, 0.5], &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">start_k</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        
        <span class="c1"># check dimensionality</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dim_k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;If using solve_on_grid method, dimension of WFArray must equal&quot;</span>
                <span class="s2">&quot;dim_k of the tight-binding model.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check number of states</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">When initializing this object, you specified nstates to be &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;, but&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">this does not match the total number of bands specified in the model,&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">which was &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;.  If you wish to use the solve_on_grid method, do&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">not specify the nstates parameter when initializing this object.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># store start_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_k</span> <span class="o">=</span> <span class="n">start_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">nk</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span>
        <span class="p">)</span>  <span class="c1"># number of k-points in each direction</span>

        <span class="c1"># we use a mesh size of (nk-1) because the last point in each direction will be</span>
        <span class="c1"># the same as the first one, so we only need (nk-1) points</span>
        <span class="n">mesh_size</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nk</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">)</span>
        <span class="n">k_axes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start_k</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">start_k</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">nk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh_size</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># stack into a grid of shape (nk1-1, nk2-1, ..., nkd-1, dim_k)</span>
        <span class="n">k_pts_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">k_axes</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># flatten the grid</span>
        <span class="n">k_pts</span> <span class="o">=</span> <span class="n">k_pts_sq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="p">)</span>

        <span class="c1"># store for later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k_mesh_square</span> <span class="o">=</span> <span class="n">k_pts_sq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k_mesh_flat</span> <span class="o">=</span> <span class="n">k_pts</span>

        <span class="c1"># solve the model on the k-mesh</span>
        <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span><span class="n">k_pts</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># reshape to back into a full (nk1, nk2, ..., nkd, nstate) mesh</span>
        <span class="n">full_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mesh_size</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">,)</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="n">evals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">full_shape</span><span class="p">)</span>
        <span class="n">evecs</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">full_shape</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norb</span><span class="p">,)</span> <span class="o">+</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nspin</span><span class="p">,)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">())</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="o">=</span> <span class="n">evals</span>  <span class="c1"># store energies in the WFArray</span>

        <span class="c1"># reshape to square mesh: (nk1, nk2, ..., nkd-1, nstate, nstate) for evecs</span>

        <span class="c1"># Store all wavefunctions in the WFArray</span>
        <span class="n">idx_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">mesh_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx_arr</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">evecs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># impose periodic boundary conditions along all directions</span>
        <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="p">):</span>
            <span class="c1"># impose periodic boundary conditions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">impose_pbc</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">per</span><span class="p">[</span><span class="nb">dir</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gaps</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">gaps</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WFArray.solve_on_one_point">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.solve_on_one_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_on_one_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpt</span><span class="p">,</span> <span class="n">mesh_indices</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Solve a tight-binding model on a single k-point.</span>

<span class="sd">        Solve a tight-binding model on a single k-point and store the eigenvectors</span>
<span class="sd">        in the *WFArray* object in the location specified by *mesh_indices*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kpt : List specifying desired k-point to solve the model on.</span>

<span class="sd">        mesh_indices : List specifying associated set of mesh indices to assign the wavefunction to.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Solve eigenvectors on a sphere of radius kappa surrounding</span>
<span class="sd">        point `k_0` in 3d k-space and pack into a predefined 2d WFArray</span>

<span class="sd">        &gt;&gt;&gt; n = 10</span>
<span class="sd">        &gt;&gt;&gt; m = 10</span>
<span class="sd">        &gt;&gt;&gt; wf = WFArray(model, [n, m])</span>
<span class="sd">        &gt;&gt;&gt; kappa = 0.1</span>
<span class="sd">        &gt;&gt;&gt; k_0 = [0, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; for i in range(n + 1):</span>
<span class="sd">        &gt;&gt;&gt;     for j in range(m + 1):</span>
<span class="sd">        &gt;&gt;&gt;         theta = np.pi * i / n</span>
<span class="sd">        &gt;&gt;&gt;         phi = 2 * np.pi * j / m</span>
<span class="sd">        &gt;&gt;&gt;         kx = k_0[0] + kappa * np.sin(theta) * np.cos(phi)</span>
<span class="sd">        &gt;&gt;&gt;         ky = k_0[1] + kappa * np.sin(theta) * np.sin(phi)</span>
<span class="sd">        &gt;&gt;&gt;         kz = k_0[2] + kappa * np.cos(theta)</span>
<span class="sd">        &gt;&gt;&gt;         wf.solve_on_one_point([kx, ky, kz], [i, j])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">evec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span><span class="n">kpt</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">mesh_indices</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[(</span><span class="n">mesh_indices</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">evec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mesh_indices</span><span class="p">)]</span> <span class="o">=</span> <span class="n">evec</span></div>



<div class="viewcode-block" id="WFArray.choose_states">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.choose_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">choose_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subset</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Create a new *WFArray* object containing a subset of the</span>
<span class="sd">        states in the original one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : array-like of int </span>
<span class="sd">            State indices to keep.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wf_new : WFArray</span>
<span class="sd">            Identical in all respects except that a subset of states have been kept.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Make new *WFArray* object containing only two states</span>

<span class="sd">        &gt;&gt;&gt; wf_new = wf.choose_states([3, 5])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a full copy of the WFArray</span>
        <span class="n">wf_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subset</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter subset must be a one-dimensional array.&quot;</span><span class="p">)</span>

        <span class="n">wf_new</span><span class="o">.</span><span class="n">_nstates</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span> <span class="o">=</span> <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span> <span class="o">=</span> <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;WFArray object can only handle spinless or spin-1/2 models.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">wf_new</span></div>


<div class="viewcode-block" id="WFArray.empty_like">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.empty_like">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nstates</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a new empty *WFArray* object based on the original.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nstates : int, optional</span>
<span class="sd">            Specifies the number of states (or bands) to be stored in the array.</span>
<span class="sd">            Defaults to the same as the original *WFArray* object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wf_new : WFArray</span>
<span class="sd">            WFArray except that array elements are uninitialized and </span>
<span class="sd">            the number of states may have changed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Make new empty WFArray object containing 6 bands per k-point</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; wf_new=wf.empty_like(nstates=6)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make a full copy of the WFArray</span>
        <span class="n">wf_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nstates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wf_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># modify numer of states (after k indices &amp; before orb and spin)</span>
            <span class="n">wf_shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_mesh</span><span class="p">]</span> <span class="o">=</span> <span class="n">nstates</span>
            <span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">wf_new</span><span class="o">.</span><span class="n">_wfs</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">wf_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wf_new</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change between cell periodic and Bloch wfs by multiplying exp(\pm i k . tau)</span>

<span class="sd">        Assumes that the WFArray was populated using a regular mesh</span>
<span class="sd">        of k-points and none of the states are at the same k-point. This means</span>
<span class="sd">        there should be no adiabatic lambda points in the mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wfsxphase : np.ndarray</span>
<span class="sd">            wfs with orbitals multiplied by phase factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">inverse</span> <span class="k">else</span> <span class="mi">1</span>  <span class="c1"># overall minus if getting cell periodic from Bloch</span>

        <span class="c1"># create a regular mesh of k-points</span>
        <span class="c1"># NOTE: Assumes that the WFArray was populated using a regular mesh</span>
        <span class="c1"># of k-points</span>

        <span class="n">nks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span>
        <span class="n">dim_k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nks</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_k</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dim_k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;WFArray has </span><span class="si">{</span><span class="n">dim_k</span><span class="si">}</span><span class="s2"> k-dimensions, but model has </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dim_k</span><span class="si">}</span><span class="s2">!&quot;</span>
            <span class="p">)</span>
        <span class="c1"># create a mesh of k-points in the range [0, 1) for each k-dimension</span>
        <span class="n">end_pts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">k_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">end_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nk</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="n">nks</span><span class="p">]</span>
        <span class="n">flat_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">k_vals</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">flat_mesh</span> <span class="o">=</span> <span class="n">flat_mesh</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim_k</span><span class="p">)</span>
        <span class="c1"># flat_mesh is now of shape [k_val, dim_k], where k_val is the total number of k-points</span>

        <span class="n">per_dir</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">flat_mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># slice second dimension to only keep only periodic dimensions in orb</span>
        <span class="n">per_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">orb_vecs</span><span class="p">[:,</span> <span class="n">per_dir</span><span class="p">]</span>

        <span class="c1"># compute a list of phase factors: exp(pm i k . tau) of shape [k_val, orbital]</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lam</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">per_orb</span> <span class="o">@</span> <span class="n">flat_mesh</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># reshape phases to have shape: [nk1, nk2, ..., nkd, norb]</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">phases</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">nks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norb</span><span class="p">)</span>

        <span class="c1"># wfs is of shape [nk1, nk2, ..., nkd, nband, norb, nspin]</span>
        <span class="n">wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfs</span>

        <span class="c1"># broadcasting to match dimensions of wfs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># newaxis along state dimension</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">phases</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># newaxis along state and spin dimension</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">phases</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">wfs</span> <span class="o">*</span> <span class="n">phases</span>

<div class="viewcode-block" id="WFArray.impose_pbc">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.impose_pbc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">impose_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dir</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_dir</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Impose periodic boundary conditions on the WFArray.</span>

<span class="sd">        This routine sets the cell-periodic Bloch function</span>
<span class="sd">        at the end of the mesh in direction `k_dir` equal to the first,</span>
<span class="sd">        multiplied by a phase factor, overwriting the previous value.</span>
<span class="sd">        Explicitly, this means we set</span>
<span class="sd">        :math:`u_{n,{\bf k_0+G}}=e^{-i{\bf G}\cdot{\bf r}} u_{n {\bf k_0}}` for the</span>
<span class="sd">        corresponding reciprocal lattice vector :math:`\mathbf{G} = \mathbf{b}_{\texttt{k_dir}}`,</span>
<span class="sd">        where :math:`\mathbf{b}_{\texttt{k_dir}}` is the reciprocal lattice basis vector corresponding to the</span>
<span class="sd">        direction `k_dir`. The state :math:`u_{n{\bf k_0}}` is the state populated in the first element</span>
<span class="sd">        of the mesh along the `mesh_dir` axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh_dir : int</span>
<span class="sd">            Direction of `WFArray` along which you wish to impose periodic boundary conditions.</span>

<span class="sd">        k_dir : int</span>
<span class="sd">            Corresponding to the periodic k-vector direction</span>
<span class="sd">            in the Brillouin zone of the underlying *TBModel*. Since</span>
<span class="sd">            version 1.7.0 this parameter is defined so that it is</span>
<span class="sd">            specified between 0 and *dim_r-1*.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`3site-cycle-nb` : For an example where the periodic boundary </span>
<span class="sd">        condition is applied only along one direction of *WFArray*.</span>

<span class="sd">        :ref:`formalism` : Section 4.4 and equation 4.18</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the *WFArray* object was populated using the</span>
<span class="sd">        :func:`pythtb.WFArray.solve_on_grid` method, this function</span>
<span class="sd">        should not be used since it will be called automatically by</span>
<span class="sd">        the code.</span>

<span class="sd">        This function will impose these periodic boundary conditions along</span>
<span class="sd">        one direction of the array. We are assuming that the k-point</span>
<span class="sd">        mesh increases by exactly one reciprocal lattice vector along</span>
<span class="sd">        this direction. This is currently **not** checked by the code;</span>
<span class="sd">        it is the responsibility of the user. Currently *WFArray*</span>
<span class="sd">        does not store the k-vectors on which the model was solved;</span>
<span class="sd">        it only stores the eigenvectors (wavefunctions).</span>

<span class="sd">        The eigenfunctions :math:`\psi_{n {\bf k}}` are by convention</span>
<span class="sd">        chosen to obey a periodic gauge, i.e.,</span>
<span class="sd">        :math:`\psi_{n,{\bf k+G}}=\psi_{n {\bf k}}` not only up to a</span>
<span class="sd">        phase, but they are also equal in phase. It follows that</span>
<span class="sd">        the cell-periodic Bloch functions are related by</span>
<span class="sd">        :math:`u_{n,{\bf k_0+G}}=e^{-i{\bf G}\cdot{\bf r}} u_{n {\bf k_0}}`.</span>
<span class="sd">        See :download:`notes on tight-binding formalism &lt;/misc/pythtb-formalism.pdf&gt;` </span>
<span class="sd">        section 4.4 and equation 4.18 for more detail.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Imposes periodic boundary conditions along the mesh_dir=0</span>
<span class="sd">        direction of the `WFArray` object, assuming that along that</span>
<span class="sd">        direction the `k_dir=1` component of the k-vector is increased</span>
<span class="sd">        by one reciprocal lattice vector.  This could happen, for</span>
<span class="sd">        example, if the underlying TBModel is two dimensional but</span>
<span class="sd">        `WFArray` is a one-dimensional path along :math:`k_y` direction.</span>

<span class="sd">        &gt;&gt;&gt; wf.impose_pbc(mesh_dir=0, k_dir=1)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">k_dir</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Periodic boundary condition can be specified only along periodic directions!&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mesh_dir should be an integer!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh_dir</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mesh_dir</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;mesh_dir outside the range!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pbc_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">)</span>

        <span class="c1"># Compute phase factors from orbital vectors dotted with G parallel to k_dir</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[:,</span> <span class="n">k_dir</span><span class="p">])</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">phase</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># mesh_dir is the direction of the array along which we impose pbc</span>
        <span class="c1"># and it is also the direction of the k-vector along which we</span>
        <span class="c1"># impose pbc e.g.</span>
        <span class="c1"># mesh_dir=0 corresponds to kx, mesh_dir=1 to ky, etc.</span>
        <span class="c1"># mesh_dir=2 corresponds to lambda, etc.</span>

        <span class="c1">### Define slices in a way that is general for arbitrary dimensions ###</span>
        <span class="c1"># Example: mesh_dir = 2 (2 defines the axis in Python counting)</span>
        <span class="c1"># add one for Python counting and one for ellipses</span>
        <span class="n">slc_lft</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mesh_dir</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># e.g., [:, :, :, :]</span>
        <span class="n">slc_rt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mesh_dir</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># e.g., [:, :, :, :]</span>
        <span class="c1"># last element along mesh_dir axis</span>
        <span class="n">slc_lft</span><span class="p">[</span><span class="n">mesh_dir</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># e.g., [:, :, -1, :]</span>
        <span class="c1"># first element along mesh_dir axis</span>
        <span class="n">slc_rt</span><span class="p">[</span><span class="n">mesh_dir</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># e.g., [:, :, 0, :]</span>
        <span class="c1"># take all components of remaining axes with ellipses</span>
        <span class="n">slc_lft</span><span class="p">[</span><span class="n">mesh_dir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">Ellipsis</span>  <span class="c1"># e.g., [:, :, -1, ...]</span>
        <span class="n">slc_rt</span><span class="p">[</span><span class="n">mesh_dir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">Ellipsis</span>  <span class="c1"># e.g., [:, :, 0, ...]</span>

        <span class="c1"># Set the last point along mesh_dir axis equal to first</span>
        <span class="c1"># multiplied by the phase factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc_lft</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc_rt</span><span class="p">)]</span> <span class="o">*</span> <span class="n">phase</span></div>


<div class="viewcode-block" id="WFArray.impose_loop">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.impose_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">impose_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dir</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Impose a loop condition along a given mesh direction.</span>

<span class="sd">        This routine can be used to set the</span>
<span class="sd">        eigenvectors equal (with equal phase), by replacing the last</span>
<span class="sd">        eigenvector with the first one along the `mesh_dir` direction</span>
<span class="sd">        (for each band).</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh_dir: int</span>
<span class="sd">            Direction of `WFArray` along which you wish to</span>
<span class="sd">            impose periodic boundary conditions.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`pythtb.WFArray.impose_pbc`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine should not be used if the first and last points</span>
<span class="sd">        are related by a reciprocal lattice vector; in that case,</span>
<span class="sd">        :func:`pythtb.WFArray.impose_pbc` should be used instead.</span>

<span class="sd">        It is assumed that the first and last points along the</span>
<span class="sd">        `mesh_dir` direction correspond to the same Hamiltonian (this</span>
<span class="sd">        is **not** checked).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Suppose the WFArray object is three-dimensional</span>
<span class="sd">        corresponding to `(kx, ky, lambda)` where `(kx, ky)` are</span>
<span class="sd">        wavevectors of a 2D insulator and lambda is an</span>
<span class="sd">        adiabatic parameter that goes around a closed loop.</span>
<span class="sd">        Then to insure that the states at the ends of the lambda</span>
<span class="sd">        path are equal (with equal phase) in preparation for</span>
<span class="sd">        computing Berry phases in lambda for given `(kx, ky)`,</span>
<span class="sd">        do </span>

<span class="sd">        &gt;&gt;&gt; wf.impose_loop(mesh_dir = 2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mesh_dir must be an integer.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh_dir</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mesh_dir</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;mesh_dir must be between 0 and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">mesh_dir</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_loop_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_dir</span><span class="p">)</span>

        <span class="n">slc_lft</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mesh_dir</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># e.g., [:, :, :, :]</span>
        <span class="n">slc_rt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mesh_dir</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># e.g., [:, :, :, :]</span>

        <span class="n">slc_lft</span><span class="p">[</span><span class="n">mesh_dir</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># e.g., [:, :, -1, :]</span>
        <span class="n">slc_rt</span><span class="p">[</span><span class="n">mesh_dir</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># e.g., [:, :, 0, :]</span>
        <span class="n">slc_lft</span><span class="p">[</span><span class="n">mesh_dir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">Ellipsis</span>  <span class="c1"># e.g., [:, :, -1, ...]</span>
        <span class="n">slc_rt</span><span class="p">[</span><span class="n">mesh_dir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">Ellipsis</span>  <span class="c1"># e.g., [:, :, 0, ...]</span>
        <span class="c1"># set the last point in the mesh_dir direction equal to the first one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc_lft</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc_rt</span><span class="p">)]</span></div>


<div class="viewcode-block" id="WFArray.position_matrix">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.position_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_idx</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Position matrix for a given k-point and set of states.</span>

<span class="sd">        Position operator is defined in reduced coordinates.</span>
<span class="sd">        The returned object :math:`X` is</span>

<span class="sd">        .. math::</span>

<span class="sd">          X_{m n {\bf k}}^{\alpha} = \langle u_{m {\bf k}} \vert</span>
<span class="sd">          r^{\alpha} \vert u_{n {\bf k}} \rangle</span>

<span class="sd">        Here :math:`r^{\alpha}` is the position operator along direction</span>
<span class="sd">        :math:`\alpha` that is selected by `dir`.</span>

<span class="sd">        This routine can be used to compute the position matrix for a</span>
<span class="sd">        given k-point and set of states (which can be all states, or</span>
<span class="sd">        a specific subset).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_idx: array-like of int </span>
<span class="sd">            Set of integers specifying the k-point of interest in the mesh.</span>
<span class="sd">        occ: array-like, &#39;all&#39;</span>
<span class="sd">            List of states to be included (can be &#39;all&#39; to include all states).</span>
<span class="sd">        dir: int</span>
<span class="sd">            Direction along which to compute the position matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos_mat : np.ndarray</span>
<span class="sd">            Position operator matrix :math:`X_{m n}` as defined above. </span>
<span class="sd">            This is a square matrix with size determined by number of bands</span>
<span class="sd">            given in `evec` input array.  First index of `pos_mat` corresponds to</span>
<span class="sd">            bra vector (:math:`m`) and second index to ket (:math:`n`).</span>

<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`pythtb.TBModel.position_matrix`</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The only difference in :func:`pythtb.TBModel.position_matrix` is that, </span>
<span class="sd">        in addition to specifying `dir`, one also has to specify `k_idx` (k-point of interest) </span>
<span class="sd">        and `occ` (list of states to be included, which can optionally be &#39;all&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check for special case of parameter occ</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">occ</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">range</span><span class="p">)):</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">occ</span><span class="p">)</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;occ must be a list, numpy array, tuple, or &#39;all&#39; defining &quot;</span>
                <span class="s2">&quot;band indices of itnterest.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">occ</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\n\nParameter occ must be a one-dimensional array or string &quot;All&quot;.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="n">evec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k_idx</span><span class="p">)][</span><span class="n">occ</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="WFArray.position_expectation">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.position_expectation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_expectation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_idx</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Position expectation value for a given k-point and set of states.</span>

<span class="sd">        These elements :math:`X_{n n}` can be interpreted as an</span>
<span class="sd">        average position of n-th Bloch state ``evec[n]`` along</span>
<span class="sd">        direction `dir`. </span>

<span class="sd">        This routine can be used to compute the position expectation value for a</span>
<span class="sd">        given k-point and set of states (which can be all states, or</span>
<span class="sd">        a specific subset). </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_idx: array-like of int</span>
<span class="sd">            Set of integers specifying the k-point of interest in the mesh.</span>
<span class="sd">        occ: array-like, &#39;all&#39;</span>
<span class="sd">            List of states to be included (can be &#39;all&#39; to include all states).</span>
<span class="sd">        dir: int</span>
<span class="sd">            Direction along which to compute the position expectation value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos_exp : np.ndarray</span>
<span class="sd">            Diagonal elements of the position operator matrix :math:`X`.</span>
<span class="sd">            Length of this vector is determined by number of bands given in *evec* input</span>
<span class="sd">            array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`pythtb.TBModel.position_expectation`</span>
<span class="sd">        :ref:`haldane-hwf-nb` : For an example.</span>
<span class="sd">        position_matrix : For definition of matrix :math:`X`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The only difference in :func:`pythtb.TBModel.position_expectation` is that,</span>
<span class="sd">        in addition to specifying *dir*, one also has to specify *k_idx* (k-point of interest)</span>
<span class="sd">        and *occ* (list of states to be included, which can optionally be &#39;all&#39;).</span>

<span class="sd">        Generally speaking these centers are _not_</span>
<span class="sd">        hybrid Wannier function centers (which are instead</span>
<span class="sd">        returned by :func:`position_hwf`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check for special case of parameter occ</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">occ</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">range</span><span class="p">)):</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">occ</span><span class="p">)</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;occ must be a list, numpy array, tuple, or &#39;all&#39; defining &quot;</span>
                <span class="s2">&quot;band indices of itnterest.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">occ</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\n\nParameter occ must be a one-dimensional array or string &quot;all&quot;.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="n">evec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k_idx</span><span class="p">)][</span><span class="n">occ</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">position_expectation</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="WFArray.position_hwf">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.position_hwf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_hwf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_idx</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">hwf_evec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;wavefunction&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Eigenvalues and eigenvectors of the position operator in a given basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_idx: array-like of int</span>
<span class="sd">            Set of integers specifying the k-point of interest in the mesh.</span>
<span class="sd">        occ: array-like, &#39;all&#39;</span>
<span class="sd">            List of states to be included (can be &#39;all&#39; to include all states).</span>
<span class="sd">        dir: int</span>
<span class="sd">            Direction along which to compute the position operator.</span>
<span class="sd">        hwf_evec: bool, optional</span>
<span class="sd">            Default is `False`. If `True`, return the eigenvectors along with eigenvalues</span>
<span class="sd">            of the position operator.</span>
<span class="sd">        basis: {&quot;orbital&quot;, &quot;wavefunction&quot;, &quot;bloch&quot;}, optional</span>
<span class="sd">            The basis in which to compute the position operator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hwfc : np.ndarray</span>
<span class="sd">            Eigenvalues of the position operator matrix :math:`X`</span>
<span class="sd">            (also called hybrid Wannier function centers). </span>
<span class="sd">            Length of this vector equals number of bands given in *evec* input</span>
<span class="sd">            array.  Hybrid Wannier function centers are ordered in ascending order.</span>
<span class="sd">            Note that in general `n`-th hwfc does not correspond to `n`-th electronic</span>
<span class="sd">            state `evec`.</span>

<span class="sd">        hwf : np.ndarray</span>
<span class="sd">            Eigenvectors of the position operator matrix :math:`X`.</span>
<span class="sd">            (also called hybrid Wannier functions).  These are returned only if</span>
<span class="sd">            parameter ``hwf_evec=True``.</span>

<span class="sd">            The shape of this array is ``[h,x]`` or ``[h,x,s]`` depending on value of</span>
<span class="sd">            `basis` and `nspin`.  </span>
<span class="sd">            </span>
<span class="sd">            - If `basis` is &quot;bloch&quot; then `x` refers to indices of</span>
<span class="sd">              Bloch states `evec`.  </span>
<span class="sd">            - If `basis` is &quot;orbital&quot; then `x` (or `x` and `s`)</span>
<span class="sd">              correspond to orbital index (or orbital and spin index if `nspin` is 2).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`haldane-hwf-nb` : For an example.</span>
<span class="sd">        position_matrix : For the definition of the matrix :math:`X`.</span>
<span class="sd">        position_expectation : For the position expectation value.</span>
<span class="sd">        :func:`pythtb.TBModel.position_hwf`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Similar to :func:`pythtb.TBModel.position_hwf`, except that</span>
<span class="sd">        in addition to specifying *dir*, one also has to specify</span>
<span class="sd">        *k_idx*, the k-point of interest, and *occ*, a list of states to</span>
<span class="sd">        be included (typically the occupied states).</span>

<span class="sd">        For backwards compatibility the default value of *basis* here is different</span>
<span class="sd">        from that in :func:`pythtb.TBModel.position_hwf`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for special case of parameter occ</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">occ</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">range</span><span class="p">)):</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">occ</span><span class="p">)</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;occ must be a list, numpy array, tuple, or &#39;all&#39; defining &quot;</span>
                <span class="s2">&quot;band indices of itnterest.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">occ</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\n\nParameter occ must be a one-dimensional array or string &quot;all&quot;.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="n">evec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k_idx</span><span class="p">)][</span><span class="n">occ</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">position_hwf</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">hwf_evec</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span></div>


<div class="viewcode-block" id="WFArray.get_links">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.get_links">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dirs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the overlap links (unitary matrices) for the wavefunctions.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        The overlap links for the wavefunctions in the `WFArray` object</span>
<span class="sd">        along a given direction are defined as the unitary part of the overlap</span>
<span class="sd">        between the wavefunctions and their neighbors in the forward direction along each</span>
<span class="sd">        mesh directions. Specifcally, the overlap matrices are computed as</span>

<span class="sd">        .. math::</span>

<span class="sd">            M_{nm}^{\mu}(\mathbf{k}) = \langle u_{nk} | u_{m, k + \delta k_{\mu}} \rangle</span>

<span class="sd">        where :math:`\mu` is the direction along which the link is computed, and</span>
<span class="sd">        :math:`\delta k_{\mu}` is the shift in the wavevector along that direction. The</span>
<span class="sd">        :math:`k` here could be a point in an arbitrary parameter mesh. The unitary link that</span>
<span class="sd">        is returned by the function is obtained through the singular value decomposition</span>
<span class="sd">        (SVD) of the overlap matrix :math:`M^{\mu}(\mathbf{k}) = V^{\mu} \Sigma^{\mu} (W^{\mu})^\dagger`</span>
<span class="sd">        as,</span>

<span class="sd">        .. math::</span>

<span class="sd">            U^{\mu}(\mathbf{k}) = V^{\mu} (W^{\mu})^\dagger</span>

<span class="sd">        .. warning:: </span>
<span class="sd">            The neighbor at the boundary is defined with periodic boundary conditions by default.</span>
<span class="sd">            In most cases, this means that the last point in the mesh of :math:`U^{\mu}(\mathbf{k})`</span>
<span class="sd">            along each direction should be disregarded (see Notes for further details).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state_idx : int or list of int</span>
<span class="sd">            Index or indices of the states for which to compute the links.</span>
<span class="sd">            If an integer is provided, only that state will be considered.</span>
<span class="sd">            If a list is provided, links for all specified states will be computed.</span>
<span class="sd">        dirs : list of int, optional</span>
<span class="sd">            List of directions along which to compute the links.</span>
<span class="sd">            If not provided, links will be computed for all directions in the mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        U_forward (np.ndarray):</span>
<span class="sd">            Array of shape [dim, nk1, nk2, ..., nkd, n_states, n_states]</span>
<span class="sd">            where dim is the number of dimensions of the mesh,</span>
<span class="sd">            (nk1, nk2, ..., nkd) are the sizes of the mesh in each dimension, </span>
<span class="sd">            and n_states is the number of states in the *WFArray* object. The first </span>
<span class="sd">            axis corresponds to :math:`\mu`, the last two axes are the matrix elements,</span>
<span class="sd">            and the remaining axes are the mesh points.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The last points in the mesh of `U_forward` should be treated carefully. Periodic boundary</span>
<span class="sd">        conditions are always implied here, so that the 0&#39;th wavefunction is the forward neighbor of</span>
<span class="sd">        the last wavefunction (-1&#39;st element) along each direction. If the `WFArray` mesh has already</span>
<span class="sd">        been defined with periodic boundary conditions, with either :func:`impose_pbc` or :func:`impose_loop`,</span>
<span class="sd">        then the last points are identified with the first points. This means the overlap links at the boundary</span>
<span class="sd">        should be disregarded, since the overlap is not between neighbors. If the last and first wavefunctions </span>
<span class="sd">        are not neighbors, then the forward neighbor at the boundary is undefined and the value </span>
<span class="sd">        of :math:`U_{nk}^{\mu}` at the boundary can again be disregarded. The only time these points should not be </span>
<span class="sd">        disregarded is when the last and first wavefunctions are truly neighbors, which would only happen if</span>
<span class="sd">        the wavefunctions on the mesh were manually populated that way.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">(</span><span class="n">flatten_spin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># State selection</span>
        <span class="k">if</span> <span class="n">state_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="c1"># If state_idx is a list or array, select those states</span>
                <span class="n">state_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># If state_idx is a single integer, convert to array</span>
                <span class="n">state_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">state_idx</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;state_idx must be an integer, list, or numpy array.&quot;</span><span class="p">)</span>

            <span class="n">wfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">wfs</span><span class="p">,</span> <span class="n">state_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dirs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If no specific directions are provided, compute links for all directions</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span><span class="p">))</span>

        <span class="n">U_forward</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
            <span class="c1"># print(f&quot;Computing links for direction mu={mu}&quot;)</span>
            <span class="n">wfs_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">wfs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>

            <span class="c1"># &lt;u_nk| u_m k+delta_mu&gt;</span>
            <span class="n">ovr_mu</span> <span class="o">=</span> <span class="n">wfs</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">wfs_shifted</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">U_forward_mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ovr_mu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">V</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Wh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">ovr_mu</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">U_forward_mu</span> <span class="o">=</span> <span class="n">V</span> <span class="o">@</span> <span class="n">Wh</span>
            <span class="n">U_forward</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">U_forward_mu</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U_forward</span><span class="p">)</span></div>


<div class="viewcode-block" id="WFArray.wilson_loop">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.wilson_loop">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wilson_loop</span><span class="p">(</span><span class="n">wfs_loop</span><span class="p">,</span> <span class="n">evals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Wilson loop unitary matrix</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        </span>
<span class="sd">        Compute Wilson loop unitary matrix and its eigenvalues for multiband Berry phases.</span>
<span class="sd">        The Wilson loop is a geometric quantity that characterizes the topology of the</span>
<span class="sd">        band structure. It is defined as the product of the overlap matrices between</span>
<span class="sd">        neighboring wavefunctions in the loop. Specifically, it is given by</span>

<span class="sd">        .. math::</span>

<span class="sd">            U_{Wilson} = \prod_{n} U_{n}</span>

<span class="sd">        where :math:`U_{n}` is the unitary part of the overlap matrix between neighboring wavefunctions</span>
<span class="sd">        in the loop, and the index :math:`n` labels the position in the loop </span>
<span class="sd">        (see :func:`get_links` for more details).</span>

<span class="sd">        Multiband Berry phases always returns numbers between :math:`-\pi` and :math:`\pi`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wfs_loop : np.ndarray</span>
<span class="sd">            Has format [loop_idx, band, orbital(, spin)] and loop has to be one dimensional.</span>
<span class="sd">            Assumes that first and last loop-point are the same. Therefore if</span>
<span class="sd">            there are n wavefunctions in total, will calculate phase along n-1</span>
<span class="sd">            links only!</span>
<span class="sd">        berry_evals : bool, optional</span>
<span class="sd">            If berry_evals is True then will compute phases for</span>
<span class="sd">            individual states, these corresponds to 1d hybrid Wannier</span>
<span class="sd">            function centers. Otherwise just return one number, Berry phase.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            If berry_evals is True then will return phases for individual states.</span>
<span class="sd">            If berry_evals is False then will return one number, the Berry phase.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`berry_loop`</span>
<span class="sd">        :func:`get_links`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check that wfs_loop has appropriate shape</span>
        <span class="k">if</span> <span class="n">wfs_loop</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">wfs_loop</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;wfs_loop must be a 3D or 4D array with shape [loop_idx, band, orbital(, spin)]&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if there is a spin axis, then flatten</span>
        <span class="n">is_spin</span> <span class="o">=</span> <span class="n">wfs_loop</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">wfs_loop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">is_spin</span><span class="p">:</span>
            <span class="c1"># flatten spin axis</span>
            <span class="n">wfs_loop</span> <span class="o">=</span> <span class="n">wfs_loop</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">wfs_loop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wfs_loop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">ovr_mats</span> <span class="o">=</span> <span class="n">wfs_loop</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">wfs_loop</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">V</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Wh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">ovr_mats</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">U_link</span> <span class="o">=</span> <span class="n">V</span> <span class="o">@</span> <span class="n">Wh</span>
        <span class="n">U_wilson</span> <span class="o">=</span> <span class="n">U_link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">U_link</span><span class="p">)):</span>
            <span class="n">U_wilson</span> <span class="o">=</span> <span class="n">U_wilson</span> <span class="o">@</span> <span class="n">U_link</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># calculate phases of all eigenvalues</span>
        <span class="k">if</span> <span class="n">evals</span><span class="p">:</span>
            <span class="n">evals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">U_wilson</span><span class="p">)</span>  <span class="c1"># Wilson loop eigenvalues</span>
            <span class="n">eval_pha</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span>  <span class="c1"># Multiband  Berrry phases</span>
            <span class="k">return</span> <span class="n">U_wilson</span><span class="p">,</span> <span class="n">eval_pha</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">U_wilson</span></div>


<div class="viewcode-block" id="WFArray.berry_loop">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.berry_loop">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">berry_loop</span><span class="p">(</span><span class="n">wfs_loop</span><span class="p">,</span> <span class="n">evals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Berry phase along a one-dimensional loop of wavefunctions.</span>

<span class="sd">        The Berry phase is computed as the logarithm of the determinant</span>
<span class="sd">        of the product of the overlap matrices between neighboring</span>
<span class="sd">        wavefunctions in the loop. In otherwords, the Berry phase is</span>
<span class="sd">        given by the formula:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi = -\text{Im} \ln \det U_{\rm Wilson}</span>

<span class="sd">        where :math:`U` is the Wilson loop unitary matrix obtained from</span>
<span class="sd">        :func:`wilson_loop`. The Berry phase is returned as a</span>
<span class="sd">        single number, which is the total Berry phase for the loop.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wfs_loop : np.ndarray</span>
<span class="sd">            Wavefunctions in the loop, with shape `[loop_idx, band, orbital, spin]`. </span>
<span class="sd">            The first and last points in the loop are assumed to be the same.</span>
<span class="sd">        evals : bool, optional</span>
<span class="sd">            Default is `False`. If `True`, will return the eigenvalues</span>
<span class="sd">            of the Wilson loop unitary matrix instead of the total Berry phase.</span>
<span class="sd">            The eigenvalues correspond to the &quot;maximally localized Wannier centers&quot; or</span>
<span class="sd">            &quot;Wilson loop eigenvalues&quot;. If False, will return the total</span>
<span class="sd">            Berry phase for the loop.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray, float:</span>
<span class="sd">            If evals is True, returns the eigenvalues of the Wilson loop</span>
<span class="sd">            unitary matrix, which are the Berry phases for each band.</span>
<span class="sd">            If evals is False, returns the total Berry phase for the loop,</span>
<span class="sd">            which is a single number.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`berry_phase`</span>
<span class="sd">        :func:`get_links`</span>
<span class="sd">        :func:`wilson_loop`</span>
<span class="sd">        :ref:`formalism` : Section 4.5</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The loop is assumed to be one-dimensional, meaning that the first </span>
<span class="sd">        and last points in the loop are assumed to be the same, and the wavefunctions</span>
<span class="sd">        at these points are also assumed to be the same. The wavefunctions in the loop</span>
<span class="sd">        should be ordered such that the first point corresponds to the first wavefunction,</span>
<span class="sd">        the second point to the second wavefunction, and so on, up to the last point,</span>
<span class="sd">        which corresponds to the last wavefunction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">U_wilson</span> <span class="o">=</span> <span class="n">WFArray</span><span class="o">.</span><span class="n">wilson_loop</span><span class="p">(</span><span class="n">wfs_loop</span><span class="p">,</span> <span class="n">evals</span><span class="o">=</span><span class="n">evals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">evals</span><span class="p">:</span>
            <span class="n">hwf_centers</span> <span class="o">=</span> <span class="n">U_wilson</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">hwf_centers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">berry_phase</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">U_wilson</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">berry_phase</span></div>


<div class="viewcode-block" id="WFArray.berry_phase">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.berry_phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">berry_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">occ</span><span class="o">=</span><span class="s2">&quot;All&quot;</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">contin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">berry_evals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Berry phase along a given array direction.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Computes the Berry phase along a given array direction</span>
<span class="sd">        and for a given set of states. These are typically the</span>
<span class="sd">        occupied Bloch states, but can also include unoccupied</span>
<span class="sd">        states if desired. </span>
<span class="sd">        </span>
<span class="sd">        By default, the function returns the Berry phase traced</span>
<span class="sd">        over the specified set of bands, but optionally the individual</span>
<span class="sd">        phases of the eigenvalues of the global unitary rotation</span>
<span class="sd">        matrix (corresponding to &quot;maximally localized Wannier</span>
<span class="sd">        centers&quot; or &quot;Wilson loop eigenvalues&quot;) can be requested</span>
<span class="sd">        by setting the parameter *berry_evals* to `True`.</span>

<span class="sd">        For a one-dimensional WFArray (i.e., a single string), the</span>
<span class="sd">        computed Berry phases are always chosen to be between :math:`-\pi` </span>
<span class="sd">        and :math:`\pi`. For a higher dimensional WFArray, the Berry phase </span>
<span class="sd">        is computed for each one-dimensional string of points, and an array of</span>
<span class="sd">        Berry phases is returned. The Berry phase for the first string</span>
<span class="sd">        (with lowest index) is always constrained to be between :math:`-\pi` and</span>
<span class="sd">        :math:`\pi`. The range of the remaining phases depends on the value of</span>
<span class="sd">        the input parameter `contin`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        occ : array-like, &quot;all&quot;</span>
<span class="sd">            Optional array of indices of states to be included</span>
<span class="sd">            in the subsequent calculations, typically the indices of</span>
<span class="sd">            bands considered occupied. If &#39;all&#39;, all states are selected.</span>
<span class="sd">            Default is all bands.</span>

<span class="sd">        dir : int</span>
<span class="sd">            Index of WFArray direction along which Berry phase is</span>
<span class="sd">            computed. This parameters needs not be specified for</span>
<span class="sd">            a one-dimensional WFArray.</span>

<span class="sd">        contin : bool, optional</span>
<span class="sd">            If True then the branch choice of the Berry phase (which is indeterminate</span>
<span class="sd">            modulo :math:`2\pi`) is made so that neighboring strings (in the</span>
<span class="sd">            direction of increasing index value) have as close as</span>
<span class="sd">            possible phases. The phase of the first string (with lowest</span>
<span class="sd">            index) is always constrained to be between :math:`-\pi` and :math:`\pi`.</span>
<span class="sd">            If False, the Berry phase for every string is constrained to be</span>
<span class="sd">            between :math:`-\pi` and :math:`\pi`. The default value is True.</span>

<span class="sd">        berry_evals : bool, optional</span>
<span class="sd">            If True then will compute and return the phases of the eigenvalues of the</span>
<span class="sd">            product of overlap matrices. (These numbers correspond also</span>
<span class="sd">            to hybrid Wannier function centers.) These phases are either</span>
<span class="sd">            forced to be between :math:`-\pi` and :math:`\pi` (if *contin* is *False*) or</span>
<span class="sd">            they are made to be continuous (if *contin* is True).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pha :</span>
<span class="sd">            If *berry_evals* is False (default value) then</span>
<span class="sd">            returns the Berry phase for each string. For a</span>
<span class="sd">            one-dimensional WFArray this is just one number. For a</span>
<span class="sd">            higher-dimensional `WFArray` *pha* contains one phase for</span>
<span class="sd">            each one-dimensional string in the following format. For</span>
<span class="sd">            example, if *WFArray* contains k-points on mesh with</span>
<span class="sd">            indices `[i,j,k]` and if direction along which Berry phase</span>
<span class="sd">            is computed is *dir=1* then *pha* will be two dimensional</span>
<span class="sd">            array with indices `[i,k]`, since Berry phase is computed</span>
<span class="sd">            along second direction. If *berry_evals* is True then for</span>
<span class="sd">            each string returns phases of all eigenvalues of the</span>
<span class="sd">            product of overlap matrices. In the convention used for</span>
<span class="sd">            previous example, *pha* in this case would have indices</span>
<span class="sd">            `[i,k,n]` where *n* refers to index of individual phase of</span>
<span class="sd">            the product matrix eigenvalue.</span>

<span class="sd">        See Also</span>
<span class="sd">        ---------</span>
<span class="sd">        :ref:`haldane-bp-nb` : For an example</span>
<span class="sd">        :ref:`cone-nb` : For an example</span>
<span class="sd">        :ref:`3site-cycle-nb` : For an example</span>
<span class="sd">        :func:`berry_loop` : For a function that computes Berry phase in a 1d loop.</span>
<span class="sd">        :ref:`formalism` : Sec. 4.5 for the discretized formula used to compute Berry phase.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For an array of size *N* in direction $dir$, the Berry phase</span>
<span class="sd">        is computed from the *N-1* inner products of neighboring</span>
<span class="sd">        eigenfunctions. This corresponds to an &quot;open-path Berry</span>
<span class="sd">        phase&quot; if the first and last points have no special</span>
<span class="sd">        relation. If they correspond to the same physical</span>
<span class="sd">        Hamiltonian, and have been properly aligned in phase using</span>
<span class="sd">        :func:`pythtb.WFArray.impose_pbc` or :func:`pythtb.WFArray.impose_loop`,</span>
<span class="sd">        then a closed-path Berry phase will be computed.</span>

<span class="sd">        In the case *occ* should range over all occupied bands,</span>
<span class="sd">        the occupied and unoccupied bands should be well separated in energy; </span>
<span class="sd">        it is the responsibility of the user to check that this is satisfied.</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        Computes Berry phases along second direction for three lowest</span>
<span class="sd">        occupied states. For example, if wf is threedimensional, then</span>
<span class="sd">        ``pha[2, 3]`` would correspond to Berry phase of string of states</span>
<span class="sd">        along ``wf[2, :, 3]``</span>

<span class="sd">        &gt;&gt;&gt; pha = wf.berry_phase([0, 1, 2], 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get wavefunctions in the array, flattening spin if present</span>
        <span class="c1"># wfs is of shape [nk1, nk2, ..., nkd, nstate, nstate]</span>
        <span class="n">wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">(</span><span class="n">flatten_spin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Check for special case of parameter occ</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">occ</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occ</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">range</span><span class="p">)):</span>
            <span class="n">occ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">occ</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;occ must be a list, numpy array, tuple, or &#39;all&#39; defining &quot;</span>
                <span class="s2">&quot;band indices of itnterest.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">occ</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Parameter occ must be a one-dimensional array or &quot;all&quot;.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="c1"># number of mesh dimensions is total dims minus band and orbital axes</span>
        <span class="n">mesh_axes</span> <span class="o">=</span> <span class="n">wfs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="c1"># Validate dir parameter</span>
        <span class="k">if</span> <span class="nb">dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mesh_axes</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If dir is not specified, the mesh must be one-dimensional.&quot;</span>
                <span class="p">)</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">dir</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">&gt;=</span> <span class="n">mesh_axes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dir must be between 0 and number of mesh dimensions - 1&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare wavefunctions: select occupied bands and bring loop dimension first</span>
        <span class="n">wf</span> <span class="o">=</span> <span class="n">wfs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">wf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># shape: (N_loop, *rest, nbands)</span>
        <span class="n">N_loop</span><span class="p">,</span> <span class="o">*</span><span class="n">rest_shape</span><span class="p">,</span> <span class="n">nbands</span><span class="p">,</span> <span class="n">norb</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Flatten redundant param dimensions intermediately</span>
        <span class="n">wf_flat</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">N_loop</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbands</span><span class="p">,</span> <span class="n">norb</span>
        <span class="p">)</span>  <span class="c1"># shape: (N_loop, rest_shape, nbands, norb)</span>

        <span class="c1"># Compute Berry phase for each slice along other dimensions</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop over all other parameter values other than the loop dimension</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wf_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">slice_wf</span> <span class="o">=</span> <span class="n">wf_flat</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">berry_loop</span><span class="p">(</span><span class="n">slice_wf</span><span class="p">,</span> <span class="n">evals</span><span class="o">=</span><span class="n">berry_evals</span><span class="p">))</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">contin</span><span class="p">:</span>
            <span class="c1"># Make phases continuous</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="WFArray.berry_flux">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.berry_flux">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">berry_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">abelian</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Berry flux tensor.</span>

<span class="sd">        .. versionremoved:: 2.0.0</span>
<span class="sd">            The `individual_phases` parameter has been removed.</span>

<span class="sd">        The Berry flux tensor is a measure of the geometric phase acquired by</span>
<span class="sd">        the wavefunction as it is adiabatically transported around a closed loop</span>
<span class="sd">        in parameter space. The flux is computed around the small plaquettes in</span>
<span class="sd">        the parameter mesh, using the product of overlap matrices around the loops.</span>
<span class="sd">        The Berry flux is simply the integral of the Berry curvature around the plaquette</span>
<span class="sd">        loop. The (non-Abelian) Berry flux tensor is defined as </span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathcal{F}_{\mu\nu}(\mathbf{k}) = </span>
<span class="sd">            \mathrm{Im}\ln\det[U_{\mu}(\mathbf{k}) U_{\nu}(\mathbf{k} + \hat{\mu}) </span>
<span class="sd">            U_{\mu}^{-1}(\mathbf{k} + \hat{\nu}) U_{\nu}^{-1}(\mathbf{k})].</span>
<span class="sd">        </span>
<span class="sd">        The Berry curvature can be approximated by the flux by simply dividing by the</span>
<span class="sd">        area of the plaquette, approximating the flux as a constant over the small loop.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \Omega_{\mu\nu}(\mathbf{k}) \approx \frac{\mathcal{F}_{\mu\nu}(\mathbf{k})}{A_{\mu\nu}},</span>

<span class="sd">        where :math:`A_{\mu\nu}` is the area of the plaquette in parameter space. The</span>
<span class="sd">        Abelian Berry flux is defined as the trace over the band indices of the non-Abelian</span>
<span class="sd">        Berry flux tensor.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathcal{F}_{\mu\nu}(\mathbf{k}) = \sum_{n} (\mathcal{F}_{\mu\nu}(\mathbf{k}))_{n, n}.</span>

<span class="sd">        In the case of a 2-dimensional *WFArray* array calculates the</span>
<span class="sd">        Berry curvature over the entire plane.  In higher dimensional case</span>
<span class="sd">        it will compute flux over all 2-dimensional slices of a </span>
<span class="sd">        higher-dimensional *WFArray*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state_idx : array_like, optional</span>
<span class="sd">            Optional array of indices of states to be included</span>
<span class="sd">            in the subsequent calculations, typically the indices of</span>
<span class="sd">            bands considered occupied. If not specified, or None, all bands are</span>
<span class="sd">            included.</span>

<span class="sd">        plane : array_like, optional</span>
<span class="sd">            Array or tuple of two indices defining the axes in the</span>
<span class="sd">            WFArray mesh which the Berry flux is computed over. By default,</span>
<span class="sd">            all directions are considered, and the full Berry flux tensor is</span>
<span class="sd">            returned.</span>

<span class="sd">        abelian : bool, optional</span>
<span class="sd">            If *True* then the Berry flux is computed</span>
<span class="sd">            using the abelian formula, which corresponds to the band-traced</span>
<span class="sd">            non-Abelian Berry curvature. If *False* then the non-Abelian Berry</span>
<span class="sd">            flux tensor is computed. Default value is *True*.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flux : ndarray</span>
<span class="sd">            The Berry flux tensor, which is an array of general shape</span>
<span class="sd">            `[dim_mesh, dim_mesh, *flux_shape, n_states, n_states]`. The</span>
<span class="sd">            shape will depend on the parameters passed to the function.</span>

<span class="sd">            If plane is `None` (default), then the first two axes</span>
<span class="sd">            `(dim_mesh, dim_mesh)` correspond to the plane directions, otherwise,</span>
<span class="sd">            these axes are absent.</span>

<span class="sd">            If `abelian` is `False` then the last two axes are the band indices</span>
<span class="sd">            running over the selected `state_idx` indices.</span>
<span class="sd">            If `abelian` is `True` (default) then the last two axes are absent, and</span>
<span class="sd">            the returned flux is a scalar value, not a matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Computes Berry curvature of first three bands in 2D model</span>

<span class="sd">        &gt;&gt;&gt; flux = wf.berry_flux([0, 1, 2]) # shape: (dim1, dim2, nk1, nk2)</span>
<span class="sd">        &gt;&gt;&gt; flux = wf.berry_flux([0, 1, 2], plane=(0, 1)) # shape: (nk1, nk2)</span>
<span class="sd">        &gt;&gt;&gt; flux = wf.berry_flux([0, 1, 2], plane=(0, 1), abelian=False) # shape: (nk1, nk2, n_states, n_states)</span>

<span class="sd">        3D model example</span>

<span class="sd">        &gt;&gt;&gt; flux = wf.berry_flux([0, 1, 2], plane=(0, 1)) # shape: (nk1, nk2, nk3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate state_idx</span>
        <span class="k">if</span> <span class="n">state_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">state_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state_idx</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;state_idx must be a one-dimensional array.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">state_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">state_idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;state_idx must be between 0 and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;state_idx must be None, a list, tuple, or numpy array.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;state_idx cannot be empty.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">state_idx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;state_idx must be sorted in ascending order.&quot;</span><span class="p">)</span>

        <span class="n">n_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_idx</span><span class="p">)</span>  <span class="c1"># Number of states considered</span>
        <span class="n">dim_mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_mesh</span>  <span class="c1"># Total dimensionality of adiabatic space: d</span>
        <span class="n">n_param</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size</span>
        <span class="p">)</span>  <span class="c1"># Number of points in adiabatic mesh: (nk1, nk2, ..., nkd)</span>

        <span class="c1"># Validate plane</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;plane must be None, a list, tuple, or numpy array.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;plane must contain exactly two directions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">dim_mesh</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">plane</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plane indices must be between 0 and </span><span class="si">{</span><span class="n">dim_mesh</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Plane indices must be different.&quot;</span><span class="p">)</span>

        <span class="c1"># Unique axes for periodic boundary conditions and loops</span>
        <span class="c1"># pbc_axes = list(set(self._pbc_axes + self._loop_axes))</span>
        <span class="n">flux_shape</span> <span class="o">=</span> <span class="n">n_param</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_mesh</span><span class="p">):</span>
            <span class="n">flux_shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># Remove last link in each periodic direction</span>

        <span class="c1"># Initialize the Berry flux array</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">dim_mesh</span><span class="p">,</span> <span class="n">dim_mesh</span><span class="p">,</span> <span class="o">*</span><span class="n">flux_shape</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">abelian</span>
                <span class="k">else</span> <span class="p">(</span><span class="n">dim_mesh</span><span class="p">,</span> <span class="n">dim_mesh</span><span class="p">,</span> <span class="o">*</span><span class="n">flux_shape</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">berry_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_mesh</span><span class="p">))</span>
            <span class="n">plane_idxs</span> <span class="o">=</span> <span class="n">dim_mesh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">plane</span>  <span class="c1"># Unpack plane directions</span>

            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">flux_shape</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">abelian</span> <span class="k">else</span> <span class="p">(</span><span class="o">*</span><span class="n">flux_shape</span><span class="p">,)</span>
            <span class="n">berry_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
            <span class="n">plane_idxs</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># U_forward: Overlaps &lt;u_{nk} | u_{n, k+delta k_mu}&gt;</span>
        <span class="n">U_forward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_links</span><span class="p">(</span><span class="n">state_idx</span><span class="o">=</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">dirs</span><span class="o">=</span><span class="n">dirs</span><span class="p">)</span>

        <span class="c1"># Compute Berry flux for each pair of states</span>
        <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">plane_idxs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">plane_idxs</span><span class="p">):</span>
                <span class="c1"># print(f&quot;Computing flux in plane: mu={mu}, nu={nu}&quot;)</span>
                <span class="n">U_mu</span> <span class="o">=</span> <span class="n">U_forward</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span>
                <span class="n">U_nu</span> <span class="o">=</span> <span class="n">U_forward</span><span class="p">[</span><span class="n">nu</span><span class="p">]</span>

                <span class="c1"># Shift the links along the mu and nu directions</span>
                <span class="n">U_nu_shift_mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">U_nu</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
                <span class="n">U_mu_shift_nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">U_mu</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">nu</span><span class="p">)</span>

                <span class="c1"># Wilson loops: W = U_{mu}(k_0) U_{nu}(k_0+delta_mu) U^{-1}_{mu}(k_0+delta_mu+delta_nu) U^{-1}_{nu}(k_0)</span>
                <span class="n">U_wilson</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">U_mu</span><span class="p">,</span> <span class="n">U_nu_shift_mu</span><span class="p">),</span>
                        <span class="n">U_mu_shift_nu</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                    <span class="p">),</span>
                    <span class="n">U_nu</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="c1"># Remove edge loop, if pbc or loop is imposed then this is an extra plaquette that isn&#39;t wanted</span>
                <span class="c1"># without pbc or loop, this loop has no physical meaning</span>
                <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_mesh</span><span class="p">):</span>
                    <span class="n">U_wilson</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">U_wilson</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">abelian</span><span class="p">:</span>
                    <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">U_wilson</span><span class="p">)</span>
                    <span class="n">angles</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span>
                    <span class="n">angles_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                        <span class="s2">&quot;...i, ij -&gt; ...ij&quot;</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="n">eigvecs_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">eigvecs</span><span class="p">)</span>
                    <span class="n">phases_plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">eigvecs</span><span class="p">,</span> <span class="n">angles_diag</span><span class="p">),</span> <span class="n">eigvecs_inv</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">det_U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">U_wilson</span><span class="p">)</span>
                    <span class="n">phases_plane</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">det_U</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">plane</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Store the Berry flux in a 2D array for each pair of directions</span>
                    <span class="n">berry_flux</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span> <span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">phases_plane</span>
                    <span class="n">berry_flux</span><span class="p">[</span><span class="n">nu</span><span class="p">,</span> <span class="n">mu</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">phases_plane</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">berry_flux</span> <span class="o">=</span> <span class="n">phases_plane</span><span class="o">.</span><span class="n">real</span>

        <span class="k">return</span> <span class="n">berry_flux</span></div>


<div class="viewcode-block" id="WFArray.chern_num">
<a class="viewcode-back" href="../../generated/pythtb.WFArray.html#pythtb.WFArray.chern_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">chern_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">state_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the Chern number in the specified plane.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        The Chern number is computed as the integral of the Berry flux</span>
<span class="sd">        over the specified plane, divided by :math:`2 \pi`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            C = \frac{1}{2\pi} \sum_{\mathbf{k}_{\mu}, \mathbf{k}_{\nu}} F_{\mu\nu}(\mathbf{k}).</span>

<span class="sd">        The plane :math:`(\mu, \nu)` is specified by `plane`, a tuple of two indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plane : tuple</span>
<span class="sd">            A tuple of two indices specifying the plane in which the Chern number is computed.</span>
<span class="sd">            The indices should be between 0 and the number of mesh dimensions minus 1. </span>
<span class="sd">            If None, the Chern number is computed for the first two dimensions of the mesh.</span>

<span class="sd">        state_idx : array-like, optional array</span>
<span class="sd">            Indices of states to be included in the Chern number calculation.</span>
<span class="sd">            If None, all states are included. None by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chern : np.ndarray, float</span>
<span class="sd">            In the two-dimensional case, the result</span>
<span class="sd">            will be a floating point approximation of the integer Chern number</span>
<span class="sd">            for that plane. In a higher-dimensional space, the Chern number</span>
<span class="sd">            is computed for each 2D slice of the higher-dimensional space.</span>
<span class="sd">            E.g., the shape of the returned array is `(nk3, ..., nkd)` if the plane is </span>
<span class="sd">            `(0, 1)`, where `(nk3, ..., nkd)` are the sizes of the mesh in the remaining</span>
<span class="sd">            dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Suppose we have a `WFArray` mesh in three-dimensional space</span>
<span class="sd">        of shape `(nk1, nk2, nk3)`. We can compute the Chern number for the</span>
<span class="sd">        `(0, 1)` plane as follows:</span>

<span class="sd">        &gt;&gt;&gt; wfs = WFArray(model, [10, 11, 12])</span>
<span class="sd">        &gt;&gt;&gt; wfs.solve_on_grid()</span>
<span class="sd">        &gt;&gt;&gt; chern = wfs.chern_num(plane=(0, 1), state_idx=np.arange(n_occ))</span>
<span class="sd">        &gt;&gt;&gt; print(chern.shape)</span>
<span class="sd">        (12,)  # shape of the Chern number array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">)</span>  <span class="c1"># assume half-filled occupied</span>

        <span class="c1"># shape of the Berry flux array: (nk1, nk2, ..., nkd)</span>
        <span class="n">berry_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">berry_flux</span><span class="p">(</span><span class="n">state_idx</span><span class="o">=</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="n">plane</span><span class="p">,</span> <span class="n">abelian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># shape of chern (if plane is (0,1)): (nk3, ..., nkd)</span>
        <span class="n">chern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">berry_flux</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">plane</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">chern</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">Bloch</span><span class="p">(</span><span class="n">WFArray</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">TBModel</span><span class="p">,</span> <span class="o">*</span><span class="n">param_dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Class for storing and manipulating Bloch like wavefunctions.</span>

<span class="sd">        Wavefunctions are defined on a semi-full reciprocal space mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_dims</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">param_dims</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">model</span><span class="o">.</span><span class="n">dim_k</span>
        <span class="p">),</span> <span class="s2">&quot;Number of dimensions must be &gt;= number of reciprocal space dimensions&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">:</span> <span class="n">TBModel</span> <span class="o">=</span> <span class="n">model</span>
        <span class="c1"># model attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">norb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nspin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">dim_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nks</span> <span class="o">=</span> <span class="n">param_dims</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span><span class="p">]</span>
        <span class="c1"># set k_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">set_k_mesh</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">)</span>
        <span class="c1"># stores k-points on a uniform mesh, calculates nearest neighbor points given the model lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="p">:</span> <span class="n">Mesh</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">k_mesh</span>

        <span class="c1"># adiabatic dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim_lam</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_dims</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_lambda</span> <span class="o">=</span> <span class="n">param_dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span> <span class="p">:]</span>

        <span class="c1"># Total adiabatic parameter space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_adia</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_lam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_adia</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lambda</span><span class="p">)</span>

        <span class="c1"># periodic boundary conditions assumed True unless specified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc_lam</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># axes indexes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_param</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spin_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orb_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spin_axis</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orb_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>

        <span class="c1"># wavefunction shapes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_lam</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lambda</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lambda</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span><span class="p">)</span>

        <span class="c1"># self.set_Bloch_ham()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">u_wfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u_wfs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">psi_wfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psi_wfs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_wf_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dict_axes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;wf shape&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span><span class="p">,</span>
            <span class="s2">&quot;Number of axes&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span><span class="p">),</span>
            <span class="s2">&quot;k-axes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_axes</span><span class="p">,</span>
            <span class="s2">&quot;lambda-axes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_axes</span><span class="p">,</span>
            <span class="s2">&quot;spin-axis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_axis</span><span class="p">,</span>
            <span class="s2">&quot;orbital axis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb_axis</span><span class="p">,</span>
            <span class="s2">&quot;state axis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_axis</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dict_axes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_pbc_lam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc_lam</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_Bloch_ham</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_fxn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lambda_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">H_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">(</span>
                <span class="n">k_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">flat_mesh</span>
            <span class="p">)</span>  <span class="c1"># [Nk, norb, norb]</span>
            <span class="c1"># [nk1, nk2, ..., norb, norb]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_k</span> <span class="o">=</span> <span class="n">H_k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">nk</span> <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">],</span> <span class="o">*</span><span class="n">H_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">return</span>

        <span class="n">lambda_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lambda_vals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">lambda_ranges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lambda_vals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">lambda_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">lambda_ranges</span><span class="p">)</span>
        <span class="n">dim_lambda</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_keys</span><span class="p">)</span>

        <span class="n">n_kpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">Nk</span>
        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span>
        <span class="n">n_spin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_spin</span>
        <span class="n">n_states</span> <span class="o">=</span> <span class="n">n_orb</span> <span class="o">*</span> <span class="n">n_spin</span>

        <span class="c1"># Initialize storage for wavefunctions and energies</span>
        <span class="k">if</span> <span class="n">n_spin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">H_kl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_kpts</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_spin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">H_kl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_kpts</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">,</span> <span class="n">n_spin</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">,</span> <span class="n">n_spin</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param_set</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">lambda_shape</span><span class="p">)):</span>
            <span class="c1"># kwargs for model_fxn with specified parameter values</span>
            <span class="n">param_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">lambda_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">lambda_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">param_set</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="c1"># Generate the model with modified parameters</span>
            <span class="n">modified_model</span><span class="p">:</span> <span class="n">TBModel</span> <span class="o">=</span> <span class="n">model_fxn</span><span class="p">(</span><span class="o">**</span><span class="n">param_dict</span><span class="p">)</span>

            <span class="n">H_kl</span><span class="p">[</span><span class="n">param_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_model</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">(</span><span class="n">k_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">flat_mesh</span><span class="p">)</span>

        <span class="c1"># Reshape for compatibility with existing Berry curvature methods</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">dim_lambda</span><span class="p">,)</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span><span class="p">))</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">dim_lambda</span><span class="p">,)</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span><span class="p">))</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">H_kl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">H_kl</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">,</span> <span class="n">n_spin</span><span class="p">)</span>
        <span class="n">H_kl</span> <span class="o">=</span> <span class="n">H_kl</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">H_k</span> <span class="o">=</span> <span class="n">H_kl</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">solve_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_fxn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lambda_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves for the eigenstates of the Bloch Hamiltonian defined by the model over a semi-full</span>
<span class="sd">        k-mesh, e.g. in 3D reduced coordinates {k = [kx, ky, kz] | k_i in [0, 1)}.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_fxn (function, optional):</span>
<span class="sd">                A function that returns a model given a set of parameters.</span>
<span class="sd">            param_vals (dict, optional):</span>
<span class="sd">                Dictionary of parameter values for adiabatic evoltuion. Each key corresponds to</span>
<span class="sd">                a varying parameter and the values are arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lambda_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># compute eigenstates and eigenenergies on full k_mesh</span>
            <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">flat_mesh</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">eigvecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">eigvals</span> <span class="o">=</span> <span class="n">eigvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">eigvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_wfs</span><span class="p">(</span><span class="n">eigvecs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">eigvals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_energy_eigstate</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>

        <span class="n">lambda_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lambda_vals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">lambda_ranges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lambda_vals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">lambda_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">lambda_ranges</span><span class="p">)</span>
        <span class="n">dim_lambda</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_keys</span><span class="p">)</span>

        <span class="n">n_kpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">Nk</span>
        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">norb</span>
        <span class="n">n_spin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nspin</span>
        <span class="n">n_states</span> <span class="o">=</span> <span class="n">n_orb</span> <span class="o">*</span> <span class="n">n_spin</span>

        <span class="c1"># Initialize storage for wavefunctions and energies</span>
        <span class="k">if</span> <span class="n">n_spin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">u_wfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_kpts</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_spin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">u_wfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_kpts</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">,</span> <span class="n">n_spin</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span>
            <span class="p">)</span>

        <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_kpts</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param_set</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">lambda_shape</span><span class="p">)):</span>
            <span class="n">param_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">lambda_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">lambda_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">param_set</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="c1"># Generate the model with modified parameters</span>
            <span class="n">modified_model</span> <span class="o">=</span> <span class="n">model_fxn</span><span class="p">(</span><span class="o">**</span><span class="n">param_dict</span><span class="p">)</span>

            <span class="c1"># Solve for eigenstates</span>
            <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">modified_model</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">flat_mesh</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Store results</span>
            <span class="n">energies</span><span class="p">[</span><span class="n">param_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigvals</span>
            <span class="n">u_wfs</span><span class="p">[</span><span class="n">param_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigvecs</span>

        <span class="c1"># Reshape for compatibility with existing Berry curvature methods</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim_lambda</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">dim_lambda</span><span class="p">,)</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span><span class="p">))</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">dim_lambda</span><span class="p">,)</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span><span class="p">))</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim_lambda</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">u_wfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">u_wfs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">,</span> <span class="n">n_spin</span><span class="p">)</span>
        <span class="n">u_wfs</span> <span class="o">=</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">energies</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">lambda_shape</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_wfs</span><span class="p">(</span><span class="n">u_wfs</span><span class="p">,</span> <span class="n">cell_periodic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">energies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_energy_eigstate</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_nbr_projector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_Q</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_P_nbr&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;Need to call `solve_model` or `set_wfs` to initialize Bloch states&quot;</span>
        <span class="k">if</span> <span class="n">return_Q</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P_nbr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q_nbr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P_nbr</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;energies&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;Need to call `solve_model` to initialize energies&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_Bloch_Ham</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the Bloch Hamiltonian of the model defined over the semi-full k-mesh.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;H_k&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_k</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_Bloch_ham</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_k</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_overlap_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns overlap matrix.</span>

<span class="sd">        Overlap matrix defined as M_{n,m,k,b} = &lt;u_{n, k} | u_{m, k+b}&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_M&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;Need to call `solve_model` or `set_wfs` to initialize overlap matrix&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_wfs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">wfs</span><span class="p">,</span> <span class="n">cell_periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">spin_flattened</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">set_projectors</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Bloch and cell-periodic eigenstates as class attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            wfs (np.ndarray):</span>
<span class="sd">                Bloch (or cell-periodic) eigenstates defined on a semi-full k-mesh corresponding</span>
<span class="sd">                to nks passed during class instantiation. The mesh is assumed to exlude the</span>
<span class="sd">                endpoints, e.g. in reduced coordinates {k = [kx, ky, kz] | k_i in [0, 1)}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">spin_flattened</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span> <span class="o">=</span> <span class="n">wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span> <span class="o">=</span> <span class="n">wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state_axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_lam</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lambda</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lambda</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span><span class="p">)</span>

        <span class="n">wfs</span> <span class="o">=</span> <span class="n">wfs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wf_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cell_periodic</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_u_wfs</span> <span class="o">=</span> <span class="n">wfs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psi_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_phase</span><span class="p">(</span><span class="n">wfs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psi_wfs</span> <span class="o">=</span> <span class="n">wfs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_u_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_phase</span><span class="p">(</span><span class="n">wfs</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_lam</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">set_projectors</span><span class="p">:</span>
            <span class="c1"># overlap matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_self_overlap_mat</span><span class="p">()</span>
            <span class="c1"># band projectors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_projectors</span><span class="p">()</span>

    <span class="c1"># TODO: allow for projectors onto subbands</span>
    <span class="c1"># TODO: possibly get rid of nbr by storing boundary states</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_projectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">num_nnbrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">num_nnbrs</span>
        <span class="n">nnbr_idx_shell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nnbr_idx_shell</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">u_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">(</span><span class="n">flatten_spin</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s2">&quot;Cell periodic&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">()[</span><span class="s2">&quot;Cell periodic&quot;</span><span class="p">]</span>

        <span class="c1"># band projectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ni, ...nj -&gt; ...ij&quot;</span><span class="p">,</span> <span class="n">u_wfs</span><span class="p">,</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P</span>

        <span class="c1"># NOTE: lambda friendly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_P_nbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_P</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_nnbrs</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Q_nbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_P_nbr</span><span class="p">)</span>

        <span class="c1"># NOTE: not lambda friendly</span>
        <span class="c1"># self._P_nbr = np.zeros((*nks, num_nnbrs, self._n_orb*self._nspin, self._n_orb*self._nspin), dtype=complex)</span>
        <span class="c1"># self._Q_nbr = np.zeros((*nks, num_nnbrs, self._n_orb*self._nspin, self._n_orb*self._nspin), dtype=complex)</span>

        <span class="c1"># TODO need shell to iterate over extra lambda dims also, shift accordingly</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nnbr_idx_shell</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># nearest neighbors</span>
            <span class="c1"># accounting for phase across the BZ boundary</span>
            <span class="n">states_pbc</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u_wfs</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="o">-</span><span class="n">idx_vec</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k_axes</span><span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">bc_phase</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_P_nbr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;...ni, ...nj -&gt; ...ij&quot;</span><span class="p">,</span> <span class="n">states_pbc</span><span class="p">,</span> <span class="n">states_pbc</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q_nbr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_orb</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P_nbr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="p">)</span>

        <span class="k">return</span>

    <span class="c1"># TODO: allow for subbands and possible lamda dim</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_self_overlap_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the overlap matrix of the cell periodic eigenstates.</span>

<span class="sd">        Overlap matrix of the form</span>

<span class="sd">        M_{m,n}^{k, k+b} = &lt; u_{m, k} | u_{n, k+b} &gt;</span>

<span class="sd">        Assumes that the last u_wf along each periodic direction corresponds to the</span>
<span class="sd">        next to last k-point in the mesh (excludes endpoints).</span>

<span class="sd">        Returns:</span>
<span class="sd">            M (np.array):</span>
<span class="sd">                Overlap matrix with shape [*nks, num_nnbrs, n_states, n_states]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Assumes only one shell for now</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">idx_shell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">get_k_shell</span><span class="p">(</span><span class="n">N_sh</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">report</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">idx_shell</span> <span class="o">=</span> <span class="n">idx_shell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bc_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">bc_phase</span>

        <span class="c1"># TODO: Not lambda friendly</span>
        <span class="c1"># overlap matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_shell</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_states</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">u_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">(</span><span class="n">flatten_spin</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s2">&quot;Cell periodic&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">()[</span><span class="s2">&quot;Cell periodic&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx_vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_shell</span><span class="p">):</span>  <span class="c1"># nearest neighbors</span>
            <span class="c1"># introduce phases to states when k+b is across the BZ boundary</span>
            <span class="n">states_pbc</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span>
                    <span class="n">u_wfs</span><span class="p">,</span>
                    <span class="n">shift</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="o">-</span><span class="n">idx_vec</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">dim</span><span class="p">)],</span>
                <span class="p">)</span>
                <span class="o">*</span> <span class="n">bc_phase</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="n">M</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;...mj, ...nj -&gt; ...mn&quot;</span><span class="p">,</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">states_pbc</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">M</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">berry_curv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dirs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">state_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">non_abelian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delta_lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">return_flux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">Kubo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">nks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nks</span>  <span class="c1"># Number of mesh points per direction</span>
        <span class="n">n_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lambda</span>
        <span class="n">dim_k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nks</span><span class="p">)</span>  <span class="c1"># Number of k-space dimensions</span>
        <span class="n">dim_lam</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_lambda</span><span class="p">)</span>  <span class="c1"># Number of adiabatic dimensions</span>
        <span class="n">dim_total</span> <span class="o">=</span> <span class="n">dim_k</span> <span class="o">+</span> <span class="n">dim_lam</span>  <span class="c1"># Total number of dimensions</span>

        <span class="k">if</span> <span class="n">dim_k</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Berry curvature only defined for dim_k &gt;= 2.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Kubo</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_energy_eigstate</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must be energy eigenstate to use Kubo formula.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_u_wfs&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;energies&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must diagonalize model first to set wavefunctions and energies.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">state_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Berry curvature in Kubo formula is for all occupied bands. Using half filling for occupied bands.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">dim_lam</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">delta_lam</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Adiabatic dimensions not yet supported for Kubo formula.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">return_flux</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Kubo formula doesn&#39;t support flux. Will return dimensionful Berry curvature only.&quot;</span>
                <span class="p">)</span>

            <span class="n">u_wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">(</span><span class="n">flatten_spin</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s2">&quot;Cell periodic&quot;</span><span class="p">]</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span>
            <span class="c1"># flatten k_dims</span>
            <span class="n">u_wfs</span> <span class="o">=</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="n">energies</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">energies</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">n_states</span> <span class="o">=</span> <span class="n">u_wfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">n_states</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nstate</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Wavefunctions must be defined for all bands, not just a subset.&quot;</span>
                <span class="p">)</span>

            <span class="n">k_mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">flat_mesh</span>
            <span class="n">occ_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_states</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">abelian</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">non_abelian</span>
            <span class="k">if</span> <span class="n">dirs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dirs</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
                <span class="n">b_curv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">berry_curvature</span><span class="p">(</span>
                    <span class="n">k_mesh</span><span class="p">,</span>
                    <span class="n">evals</span><span class="o">=</span><span class="n">energies</span><span class="p">,</span>
                    <span class="n">evecs</span><span class="o">=</span><span class="n">u_wfs</span><span class="p">,</span>
                    <span class="n">occ_idxs</span><span class="o">=</span><span class="n">occ_idx</span><span class="p">,</span>
                    <span class="n">abelian</span><span class="o">=</span><span class="n">abelian</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">b_curv</span> <span class="o">=</span> <span class="n">b_curv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">b_curv</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">b_curv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b_curv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">berry_curvature</span><span class="p">(</span>
                    <span class="n">k_mesh</span><span class="p">,</span>
                    <span class="n">evals</span><span class="o">=</span><span class="n">energies</span><span class="p">,</span>
                    <span class="n">evecs</span><span class="o">=</span><span class="n">u_wfs</span><span class="p">,</span>
                    <span class="n">occ_idxs</span><span class="o">=</span><span class="n">occ_idx</span><span class="p">,</span>
                    <span class="n">abelian</span><span class="o">=</span><span class="n">abelian</span><span class="p">,</span>
                    <span class="n">dirs</span><span class="o">=</span><span class="n">dirs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">b_curv</span> <span class="o">=</span> <span class="n">b_curv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">nks</span><span class="p">,</span> <span class="o">*</span><span class="n">b_curv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>

            <span class="k">return</span> <span class="n">b_curv</span>

        <span class="n">Berry_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">berry_flux_plaq</span><span class="p">(</span><span class="n">state_idx</span><span class="o">=</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">non_abelian</span><span class="o">=</span><span class="n">non_abelian</span><span class="p">)</span>
        <span class="n">Berry_curv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Berry_flux</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">Berry_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Number of dimensions in parameter space</span>
        <span class="n">recip_lat_vecs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_recip_lat</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># Expressed in cartesian (x,y,z) coordinates</span>

        <span class="n">dks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim_total</span><span class="p">,</span> <span class="n">dim_total</span><span class="p">))</span>
        <span class="n">dks</span><span class="p">[:</span><span class="n">dim_k</span><span class="p">,</span> <span class="p">:</span><span class="n">dim_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">recip_lat_vecs</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nks</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_lam</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">dks</span><span class="p">[</span><span class="n">dim_k</span><span class="p">:,</span> <span class="n">dim_k</span><span class="p">:],</span> <span class="n">delta_lam</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lambda</span><span class="p">))</span>

        <span class="c1"># Divide by area elements for the (mu, nu)-plane</span>
        <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dks</span><span class="p">[</span><span class="n">mu</span><span class="p">],</span> <span class="n">dks</span><span class="p">[</span><span class="n">nu</span><span class="p">]])</span>
                <span class="c1"># area_element = np.prod([np.linalg.norm(dk[i]), np.linalg.norm(dk[j])])</span>
                <span class="n">area_element</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

                <span class="c1"># Divide flux by the area element to get approx curvature</span>
                <span class="n">Berry_curv</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span> <span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">Berry_flux</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span> <span class="n">nu</span><span class="p">]</span> <span class="o">/</span> <span class="n">area_element</span>
                <span class="n">Berry_curv</span><span class="p">[</span><span class="n">nu</span><span class="p">,</span> <span class="n">mu</span><span class="p">]</span> <span class="o">=</span> <span class="n">Berry_flux</span><span class="p">[</span><span class="n">nu</span><span class="p">,</span> <span class="n">mu</span><span class="p">]</span> <span class="o">/</span> <span class="n">area_element</span>

        <span class="k">if</span> <span class="n">dirs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Berry_curv</span><span class="p">,</span> <span class="n">Berry_flux</span> <span class="o">=</span> <span class="n">Berry_curv</span><span class="p">[</span><span class="n">dirs</span><span class="p">],</span> <span class="n">Berry_flux</span><span class="p">[</span><span class="n">dirs</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_flux</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Berry_curv</span><span class="p">,</span> <span class="n">Berry_flux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Berry_curv</span>

    <span class="c1"># TODO allow for subbands</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">trace_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P</span>
        <span class="n">Q_nbr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q_nbr</span>

        <span class="n">nks</span> <span class="o">=</span> <span class="n">Q_nbr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">num_nnbrs</span> <span class="o">=</span> <span class="n">Q_nbr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">w_b</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(</span><span class="n">N_sh</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">T_kb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">*</span><span class="n">nks</span><span class="p">,</span> <span class="n">num_nnbrs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nbr_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nnbrs</span><span class="p">):</span>  <span class="c1"># nearest neighbors</span>
            <span class="n">T_kb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">nbr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span>
                <span class="n">P</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Q_nbr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">nbr_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">2</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">w_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">T_kb</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO allow for subbands</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">omega_til</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span>
        <span class="n">w_b</span><span class="p">,</span> <span class="n">k_shell</span><span class="p">,</span> <span class="n">idx_shell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">get_weights</span><span class="p">(</span><span class="n">N_sh</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">w_b</span> <span class="o">=</span> <span class="n">w_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">k_shell</span> <span class="o">=</span> <span class="n">k_shell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">nks</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">nks</span><span class="p">)</span>
        <span class="n">k_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nks</span><span class="p">))])</span>

        <span class="n">diag_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">log_diag_M_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">diag_M</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">abs_diag_M_sq</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">diag_M</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">r_n</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">Nk</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">log_diag_M_imag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">k_axes</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">k_shell</span>

        <span class="n">Omega_tilde</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">Nk</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">w_b</span>
            <span class="o">*</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="o">-</span><span class="n">log_diag_M_imag</span> <span class="o">-</span> <span class="n">k_shell</span> <span class="o">@</span> <span class="n">r_n</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">abs_diag_M_sq</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Omega_tilde</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">interp_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">O_k</span><span class="p">,</span> <span class="n">k_path</span><span class="p">,</span> <span class="n">plaq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">k_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">square_mesh</span><span class="p">)</span>
        <span class="n">k_idx_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">idx_arr</span>
        <span class="n">nks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span>
        <span class="n">dim_k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nks</span><span class="p">)</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">nks</span><span class="p">])</span>

        <span class="n">supercell</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">product</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">((</span><span class="n">nk</span> <span class="o">-</span> <span class="n">nk</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">((</span><span class="n">nk</span> <span class="o">-</span> <span class="n">nk</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="n">nks</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plaq</span><span class="p">:</span>
            <span class="c1"># shift by half a mesh point to get the center of the plaquette</span>
            <span class="n">k_mesh</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">nk</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="n">nks</span><span class="p">])</span>

        <span class="c1"># Fourier transform to real space</span>
        <span class="n">O_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">supercell</span><span class="p">),</span> <span class="o">*</span><span class="n">O_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim_k</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">supercell</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k_idx</span> <span class="ow">in</span> <span class="n">k_idx_arr</span><span class="p">:</span>
                <span class="n">R_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">k_mesh</span><span class="p">[</span><span class="n">k_idx</span><span class="p">],</span> <span class="n">R_vec</span><span class="p">))</span>
                <span class="n">O_R</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">O_k</span><span class="p">[</span><span class="n">k_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">phase</span> <span class="o">/</span> <span class="n">Nk</span>

        <span class="c1"># interpolate to arbitrary k</span>
        <span class="n">O_k_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">O_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim_k</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k_idx</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k_path</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">supercell</span><span class="p">):</span>
                <span class="n">R_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">R_vec</span><span class="p">))</span>
                <span class="n">O_k_interp</span><span class="p">[</span><span class="n">k_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">O_R</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">phase</span>

        <span class="k">return</span> <span class="n">O_k_interp</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">interp_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_path</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">H_k_proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_proj_ham</span><span class="p">()</span>
        <span class="n">H_k_interp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_op</span><span class="p">(</span><span class="n">H_k_proj</span><span class="p">,</span> <span class="n">k_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_eigvecs</span><span class="p">:</span>
            <span class="n">u_k_interp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_u_wfs</span><span class="p">,</span> <span class="n">k_path</span><span class="p">)</span>
            <span class="n">eigvals_interp</span><span class="p">,</span> <span class="n">eigvecs_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">H_k_interp</span><span class="p">)</span>
            <span class="n">eigvecs_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;...ij, ...ik -&gt; ...jk&quot;</span><span class="p">,</span> <span class="n">u_k_interp</span><span class="p">,</span> <span class="n">eigvecs_interp</span>
            <span class="p">)</span>
            <span class="n">eigvecs_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">eigvecs_interp</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">eigvals_interp</span><span class="p">,</span> <span class="n">eigvecs_interp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eigvals_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">H_k_interp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">eigvals_interp</span>

    <span class="c1"># TODO allow for subbands</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_proj_ham</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;H_k_proj&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_Bloch_ham</span><span class="p">()</span>
        <span class="n">H_k_proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_wfs</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_k</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_wfs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H_k_proj</span>
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2025, Trey Cole, Sinisa Coh, and David Vanderbilt.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>