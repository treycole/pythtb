
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pythtb.tb_model &#8212; PythTB Docs</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css?v=7f9a90b1" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=1a152b8d" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=7f41d439"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=cbcfbdad"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pythtb/tb_model';</script>
    <script defer="defer" src="../../_static/custom-icons.js?v=7518156e"></script>
    <script src="https://unpkg.com/thebe@latest/lib/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">PythTB Docs</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../about.html">
    About
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../install.html">
    Install
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../CHANGELOG.html">
    Changelog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../formalism.html">
    Formalism
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../resources.html">
    Resources
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../citation.html">
    Citation
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/treycole/pythtb" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pythtb/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../about.html">
    About
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../install.html">
    Install
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../CHANGELOG.html">
    Changelog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../formalism.html">
    Formalism
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../resources.html">
    Resources
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../citation.html">
    Citation
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/treycole/pythtb" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pythtb/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">pythtb.tb_model</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pythtb.tb_model</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_bands</span><span class="p">,</span> <span class="n">plot_tb_model</span><span class="p">,</span> <span class="n">plot_tb_model_3d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">k_path</span><span class="p">,</span> <span class="n">k_uniform_mesh</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_is_int</span><span class="p">,</span> <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">,</span> <span class="n">is_Hermitian</span>

<span class="c1"># set up logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;TBModel&quot;</span><span class="p">]</span>

<span class="n">SIGMA0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">SIGMAX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">SIGMAY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">SIGMAZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">deprecated</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to mark a function as deprecated.</span>
<span class="sd">    Raises a FutureWarning with the given message when the function is called.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2"> is deprecated and will be removed in a future release: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">decorator</span>


<div class="viewcode-block" id="TBModel">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TBModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tight-binding model constructor.</span>

<span class="sd">    This class contains the tight-binding model information. </span>
<span class="sd">    It is designed to handle various aspects of tight-binding models, including the lattice structure, </span>
<span class="sd">    orbital positions, and periodic boundary conditions. It will also provide methods for constructing</span>
<span class="sd">    the Hamiltonian matrix and diagonalizing the tight-binding model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim_k : int</span>
<span class="sd">        Dimensionality of reciprocal space, i.e., specifies how</span>
<span class="sd">        many directions are considered to be periodic.</span>

<span class="sd">    dim_r : int</span>
<span class="sd">        Dimensionality of real space, i.e., specifies how many</span>
<span class="sd">        real space lattice vectors there are and how many coordinates are</span>
<span class="sd">        needed to specify the orbital coordinates.</span>

<span class="sd">    lat : array_like, optional</span>
<span class="sd">        Array containing lattice vectors in Cartesian coordinates</span>
<span class="sd">        (in arbitrary units). By default, lattice vectors are an identity matrix. </span>

<span class="sd">    orb : int, array_like, optional</span>
<span class="sd">        Array containing reduced coordinates of all</span>
<span class="sd">        tight-binding orbitals. If ``orb`` is an integer code will assume</span>
<span class="sd">        that there are these many orbitals all at the origin of the unit cell.  </span>
<span class="sd">        By default ``orb=1`` and the code will assume a single orbital at the origin.</span>

<span class="sd">    per : array_like, optional</span>
<span class="sd">        Specifies the indices of lattice vectors which are considered to be periodic.</span>
<span class="sd">        By default, all lattice vectors are assumed to be periodic. If ``dim_k`` is smaller than ``dim_r``, </span>
<span class="sd">        then by default the first ``dim_k`` vectors are considered to be periodic.</span>

<span class="sd">        In the example below, only the vector ``[0.0,2.0]`` is considered to be periodic </span>
<span class="sd">        (since ``per=[1]``). </span>

<span class="sd">    nspin : {1, 2}, optional</span>
<span class="sd">        Number of explicit spin components assumed for each</span>
<span class="sd">        orbital in ``orb``. Allowed values of ``nspin`` are ``1`` and ``2``. If</span>
<span class="sd">        ``nspin=1`` then the model is spinless, if ``nspin=2`` then it</span>
<span class="sd">        is explicitly a spinfull model and each orbital is assumed to</span>
<span class="sd">        have two spin components. Default value of this parameter is</span>
<span class="sd">        ``nspin=1``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Parameter ``dim_r`` can be larger than ``dim_k``! For example,</span>
<span class="sd">    a polymer is a three-dimensional molecule (one needs three</span>
<span class="sd">    coordinates to specify orbital positions), but it is periodic</span>
<span class="sd">    along only one direction. For a polymer, therefore, we should</span>
<span class="sd">    have ``dim_k=1`` and ``dim_r=3``. See the :ref:`trestle-nb`</span>
<span class="sd">    or :ref:`buckled-layer-nb` examples.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Creates model that is two-dimensional in real space but only</span>
<span class="sd">    one-dimensional in reciprocal space. The first lattice vector has coordinates</span>
<span class="sd">    ``[1, 1/2]`` while the second  one has coordinates ``[0, 2]``.</span>
<span class="sd">    The second lattice vector is chosen to be periodic (since ``per=[1]``).</span>
<span class="sd">    Three orbital coordinates are specified in reduced units. The first orbital</span>
<span class="sd">    is defined with reduced coordinates ``[0.2, 0.3]``. Its Cartesian coordinates</span>
<span class="sd">    are therefore 0.2 times the first lattice vector plus 0.3 times the second lattice </span>
<span class="sd">    vector.</span>

<span class="sd">    &gt;&gt;&gt; from pythtb import TBModel</span>
<span class="sd">    &gt;&gt;&gt; tb = TBModel(</span>
<span class="sd">    ...        dim_k=1, dim_r=2,</span>
<span class="sd">    ...        lat=[[1, 1/2], [0, 2]],</span>
<span class="sd">    ...        orb=[[0.2, 0.3], [0.1, 0.1], [0.2, 0.2]],</span>
<span class="sd">    ...        per=[1]</span>
<span class="sd">    ...    )</span>
<span class="sd">    &gt;&gt;&gt; print(tb)</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TBModel.__init__">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim_k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dim_r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orb</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">per</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nspin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">):</span>

        <span class="c1"># Dimensionality of real space</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_r</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Argument dim_r must be an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_r</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument dim_r must be less than 4.&quot;</span><span class="p">)</span>

        <span class="c1"># Dimensionality of k-space</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_k</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Argument dim_k must be an integer.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_k</span> <span class="o">&gt;</span> <span class="n">dim_r</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument dim_k must be less than dim_r.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span> <span class="o">=</span> <span class="n">dim_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">=</span> <span class="n">dim_k</span>

        <span class="c1"># initialize lattice vectors</span>
        <span class="c1"># shape: (dim_r, dim_r)</span>
        <span class="c1"># idx: (lattice direction, cartesian components)</span>
        <span class="c1"># default: None implies unit matrix</span>
        <span class="k">if</span> <span class="n">lat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim_r</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Lattice vectors not specified. Using identity matrix.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lat</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim_r</span><span class="p">,</span> <span class="n">dim_r</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Wrong lat array dimensions. Must have shape (dim_r, dim_r).&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span> <span class="o">=</span> <span class="n">lat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Lattice vectors must be a list or numpy array.&quot;</span><span class="p">)</span>

        <span class="c1"># check that volume is not zero and that have right handed system</span>
        <span class="k">if</span> <span class="n">dim_r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">det_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">det_lat</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lattice vectors need to form right handed system.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">det_lat</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Volume of unit cell is zero.&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize orbitals defined in reduced coordinates</span>
        <span class="c1"># shape: (norb, dim_r)</span>
        <span class="c1"># idx: (orbital, reduced components)</span>
        <span class="c1"># default: 1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orb</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">=</span> <span class="n">orb</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">orb</span><span class="p">,</span> <span class="n">dim_r</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Orbital positions is an integer. Assuming </span><span class="si">{</span><span class="n">orb</span><span class="si">}</span><span class="s2"> orbitals at the origin&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orb</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">orb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Orbtial array must have two axes; the first for orbital, the second for reduced unit values.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">orb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim_r</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of components along second axes of orbital array must match real space dimension.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">orb</span>  <span class="c1"># orbital vectors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># number of orbitals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Orbital vectors must be array-type or an integer.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Specifying which dimensions are periodic.</span>
        <span class="k">if</span> <span class="n">per</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Periodic directions not specified. Using the first dim_k directions.&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_per</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">per</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">per</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">per</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of periodic directions must equal the k-space dimension, dim_k.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_per</span> <span class="o">=</span> <span class="n">per</span>

        <span class="c1"># Validate number of spin components</span>
        <span class="k">if</span> <span class="n">nspin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nspin must be 1 or 2&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>

        <span class="c1"># Number of electronic states at each k-point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>

        <span class="c1"># By default, assume model did not come from w90 object and that</span>
        <span class="c1"># position operator is diagonal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Initialize onsite energies to zero</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="c1"># The onsite energies and hoppings are not specified</span>
        <span class="c1"># when creating a &#39;TBModel&#39; object.  They are speficied</span>
        <span class="c1"># subsequently by separate function calls defined below.</span>

        <span class="c1"># remember which onsite energies user has specified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Initialize hoppings to empty list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span> <span class="o">=</span> <span class="p">[]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the ``TBModel`` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            String representation of the TBModel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;pythtb.TBModel(dim_r=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="si">}</span><span class="s2">, dim_k=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;norb=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="si">}</span><span class="s2">, nspin=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the ``TBModel`` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            String representation of the TBModel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare two TBModel objects for equality.</span>

<span class="sd">        Compares structural parameters, arrays, and hoppings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : TBModel</span>
<span class="sd">            Another TBModel instance to compare.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the models are equal, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TBModel</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="c1"># Compare simple attributes</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_dim_r</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_dim_k</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_nspin</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_norb</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_per</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Compare numpy arrays</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_lat</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_orb</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Compare hoppings list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">):</span>
            <span class="n">amp1</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="o">*</span><span class="n">R1</span> <span class="o">=</span> <span class="n">h1</span>
            <span class="n">amp2</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="o">*</span><span class="n">R2</span> <span class="o">=</span> <span class="n">h2</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="o">!=</span> <span class="n">i2</span> <span class="ow">or</span> <span class="n">j1</span> <span class="o">!=</span> <span class="n">j2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">amp1</span><span class="p">,</span> <span class="n">amp2</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">R1</span> <span class="ow">and</span> <span class="n">R2</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">R1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">R2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">R1</span> <span class="ow">or</span> <span class="n">R2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="TBModel.display">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.display">[docs]</a>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The &#39;display&#39; method is deprecated and will be removed in a future release. Use &#39;print(model)&#39; or &#39;model.report(show=True)&#39; instead.&quot;</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            `display` has been deprecated, it is recommended to use `print(model)` or `model.report(show=True)` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.report">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.report">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">short</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print or return a report about the tight-binding model.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">            The `short` parameter was added to control the verbosity of the report.</span>
<span class="sd">            The `show` parameter was added to control whether to print the report or return it as a string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        show : bool, optional</span>
<span class="sd">            If True, prints the report to stdout. If False, returns the report as a string.</span>
<span class="sd">        short : bool, optional</span>
<span class="sd">            If True, print only a short summary. If False, print full details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or None</span>
<span class="sd">            Returns the report string if `show` is False, otherwise prints and returns None.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The report includes lattice vectors, orbital positions, site energies, hoppings, and hopping distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;----------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;       Tight-binding model report       </span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;----------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;r-space dimension           = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;k-space dimension           = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;number of spin components   = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;periodic directions         = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;number of orbitals          = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;number of electronic states = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_nstate</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

        <span class="c1"># Print Lattice and Orbital Vectors</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">short</span><span class="p">:</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;float_kind&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">0</span><span class="si">:</span><span class="s2">^7.0f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">^7.3f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">}</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Lattice vectors (Cartesian):&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">):</span>
                <span class="c1"># print(f&quot;  # {i} ===&gt; {np.array2string(vec, formatter=formatter, separator=&#39;, &#39;)}&quot;)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;  # </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> ===&gt; </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">,</span><span class="w"> </span><span class="n">separator</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Orbital vectors (dimensionless):&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">orb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">):</span>
                <span class="c1"># print(f&quot;  # {i} ===&gt; {np.array2string(orb, formatter=formatter, separator=&#39;, &#39;)}&quot;)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;  # </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> ===&gt; </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">orb</span><span class="p">,</span><span class="w"> </span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">,</span><span class="w"> </span><span class="n">separator</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Print Site Energies</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Site energies:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">energy_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">site</span><span class="si">:</span><span class="s2">^7.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">energy_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>

                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  # </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> ===&gt; </span><span class="si">{</span><span class="n">energy_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Hoppings:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hopping</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">):</span>
                <span class="n">out_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  &lt; </span><span class="si">{</span><span class="n">hopping</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">^1</span><span class="si">}</span><span class="s2"> | H | </span><span class="si">{</span><span class="n">hopping</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">^1</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot; + [&quot;</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                        <span class="n">out_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">^5.1f</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;] &gt;  ===&gt; &quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">out_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hopping</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">^7.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">out_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_str</span><span class="p">)</span>

            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Hopping distances:&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hopping</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">):</span>
                <span class="n">hop_from</span> <span class="o">=</span> <span class="n">hopping</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">hop_to</span> <span class="o">=</span> <span class="n">hopping</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="n">pos_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">hopping</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
                <span class="n">pos_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">hopping</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>

                <span class="n">out_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  | pos(</span><span class="si">{</span><span class="n">hop_from</span><span class="si">:</span><span class="s2">^1</span><span class="si">}</span><span class="s2">) - pos(</span><span class="si">{</span><span class="n">hop_to</span><span class="si">:</span><span class="s2">^1</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">pos_j</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>

                    <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot; + [&quot;</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">Rv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                        <span class="n">out_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Rv</span><span class="si">:</span><span class="s2">^5.1f</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hopping</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;]&quot;</span>

                <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pos_j</span> <span class="o">-</span> <span class="n">pos_i</span><span class="p">)</span>

                <span class="n">out_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;) | = </span><span class="si">{</span><span class="n">distance</span><span class="si">:</span><span class="s2">^7.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_periodic_H</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H_flat</span><span class="p">,</span> <span class="n">k_vals</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform Hamiltonian to periodic gauge so that :math:`H(\mathbf{k}+\mathbf{G}) = H(\mathbf{k})`.</span>

<span class="sd">        If `nspin`= 2, `H_flat` should only be flat along k and NOT spin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        H_flat : np.ndarray</span>
<span class="sd">            Hamiltonian flattened along the k-direction, shape (Nk, nstate, nstate[, nspin]).</span>
<span class="sd">        k_vals : np.ndarray</span>
<span class="sd">            Array of k-point values, shape (Nk, dim_k).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Hamiltonian in periodic gauge, shape (Nk, nstate, nstate[, nspin]).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The transformation applies phase factors to ensure periodicity in reciprocal space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orb_vecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_orb_vecs</span><span class="p">()</span>  <span class="c1"># reduced units</span>
        <span class="n">orb_vec_diff</span> <span class="o">=</span> <span class="n">orb_vecs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">orb_vecs</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No periodic directions in k-space. Returning H_flat unchanged.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">H_flat</span>
        <span class="n">orb_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">orb_vec_diff</span><span class="p">,</span> <span class="n">k_vals</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">H_per_flat</span> <span class="o">=</span> <span class="n">H_flat</span> <span class="o">*</span> <span class="n">orb_phase</span>
        <span class="k">return</span> <span class="n">H_per_flat</span>

    <span class="c1"># Property decorators for read-only access to model attributes</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dim_r</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The dimensionality of real space.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dim_k</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The dimensionality of reciprocal space (periodic directions).</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nspin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of spin components.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">per</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Periodic directions as a list of indices.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Each index corresponds to a lattice vector in the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">norb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of tight-binding orbitals in the model.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nstate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of electronic states in the model is ``norb * nspin``.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nstate</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lat_vecs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lattice vectors in Cartesian coordinates with shape ``(dim_r, dim_r)``.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orb_vecs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Orbital vectors in reduced coordinates with shape ``(norb, dim_r)``.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">site_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;On-site energies for each orbital. </span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Shape is ``(norb,)`` for spinless models, ``(norb, 2, 2)`` for spinful models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hoppings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of hopping dictionaries for the model.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Each hopping is represented as a dictionary with keys:</span>
<span class="sd">            - &#39;amplitude&#39;: hopping amplitude (complex or matrix)</span>
<span class="sd">            - &#39;from_orbital&#39;: index of starting orbital</span>
<span class="sd">            - &#39;to_orbital&#39;: index of ending orbital</span>
<span class="sd">            - &#39;lattice_vector&#39;: (optional) lattice vector displacement</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)</span>
        <span class="n">formatted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="n">raw</span><span class="p">:</span>
            <span class="n">amp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="n">R</span> <span class="o">=</span> <span class="n">hop</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;amplitude&quot;</span><span class="p">:</span> <span class="n">amp</span><span class="p">,</span>
                <span class="s2">&quot;from_orbital&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                <span class="s2">&quot;to_orbital&quot;</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">R</span><span class="p">:</span>
                <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;lattice_vector&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">formatted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">formatted</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">assume_position_operator_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the position operator is diagonal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span>

    <span class="nd">@assume_position_operator_diagonal</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">assume_position_operator_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;assume_position_operator_diagonal must be a boolean.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="TBModel.copy">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TBModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a deep copy of the TBModel object.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TBModel</span>
<span class="sd">            A deep copy of the model.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tb2 = tb.copy()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.clear_hoppings">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.clear_hoppings">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear_hoppings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear all hoppings in the model.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is useful for resetting the model to a state without any hoppings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cleared all hoppings.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.clear_onsite">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.clear_onsite">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear_onsite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear all on-site energies in the model.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is useful for resetting the model to a state without any on-site energies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cleared all on-site energies.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.get_num_orbitals">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.get_num_orbitals">[docs]</a>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Use &#39;norb&#39; property instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">           Use &#39;norb&#39; property instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">norb</span></div>


<div class="viewcode-block" id="TBModel.get_orb">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.get_orb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_orb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return orbital positions.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">            Added support for Cartesian coordinates with the `cartesian` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cartesian : bool, optional</span>
<span class="sd">            If True, returns orbital positions in Cartesian coordinates.</span>
<span class="sd">            If False, returns reduced coordinates (default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Array of orbital positions, shape (norb, dim_r).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb_vecs</span>
        <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">orbs</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat_vecs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">orbs</span></div>


<div class="viewcode-block" id="TBModel.get_lat">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.get_lat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_lat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return lattice vectors in Cartesian coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Lattice vectors, shape (dim_r, dim_r).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat_vecs</span></div>


    <span class="c1"># TODO: Fix to work with systems where not all lattice vectors are periodic</span>
<div class="viewcode-block" id="TBModel.get_recip_lat">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.get_recip_lat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_recip_lat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reciprocal lattice vectors in Cartesian coordinates.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Reciprocal lattice vectors, shape (dim_k, dim_r). If not defined, returns zeros.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Only defined when dim_k == dim_r.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Reciprocal lattice vectors are not defined for zero-dimensional k-space.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Reciprocal lattice vectors are not defined for systems where k-space and real-space dimensions differ.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">))</span>

        <span class="c1"># Calculate the reciprocal lattice vectors</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat_vecs</span>  <span class="c1"># shape (dim_r, dim_r)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lattice vectors are not linearly independent.&quot;</span><span class="p">)</span>
        <span class="c1"># Calculate the inverse of the lattice matrix</span>
        <span class="n">A_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># shape (dim_r, dim_r)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">A_inv</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># shape (dim_k, dim_k)</span>
        <span class="k">return</span> <span class="n">b</span></div>


<div class="viewcode-block" id="TBModel.get_recip_vol">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.get_recip_vol">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_recip_vol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the volume of the reciprocal lattice.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        The volume is defined as the absolute value of the determinant</span>
<span class="sd">        of the reciprocal lattice vectors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Volume of the reciprocal lattice.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Only defined when `dim_k` = `dim_r`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">recip_lat_vecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_recip_lat</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Reciprocal volume is not defined for zero-dimensional k-space.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Reciprocal volume is not defined for systems where k-space and real-space dimensions differ.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">recip_lat_vecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span>
            <span class="ow">or</span> <span class="n">recip_lat_vecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Reciprocal lattice vectors must have shape (dim_k, dim_r).&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">recip_lat_vecs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reciprocal lattice vectors are not linearly independent.&quot;</span><span class="p">)</span>
        <span class="c1"># Calculate the volume of the reciprocal lattice</span>
        <span class="c1"># The volume is the absolute value of the determinant of the reciprocal lattice vectors</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">recip_lat_vecs</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="TBModel.set_k_mesh">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.set_k_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_k_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nks</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up a uniform k-space mesh for the model.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nks : array_like</span>
<span class="sd">            Number of k-points along each periodic direction (length must be equal to dim_k).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of mesh points does not match the number of periodic directions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tb.set_k_mesh([10, 10])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.mesh2</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mesh</span>

        <span class="n">dim_k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nks</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_k</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;K-space dimensions do not match specified mesh numbers. Must be a number&quot;</span>
                <span class="s2">&quot;for each dimension.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;k_mesh&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">nks</span> <span class="o">==</span> <span class="n">nks</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Mesh already set and &#39;nks&#39; are the same as specified. Doing nothing.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">nks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nks</span> <span class="o">=</span> <span class="n">nks</span></div>


<div class="viewcode-block" id="TBModel.get_k_mesh">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.get_k_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_k_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the k-space mesh.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flat : bool, optional</span>
<span class="sd">            If True, returns the flat mesh (1D array of k-points of shape (Nk, dim_k)).</span>
<span class="sd">            If False, returns the square mesh (multi-dimensional array of k-points).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray </span>
<span class="sd">            Array of k-points in the mesh.</span>
<span class="sd">            If flat, shape is (Nk, dim_k). Otherwise, shape is (nk1, nk2, ..., dim_k).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NameError</span>
<span class="sd">            If the k-mesh has not been initialized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;k_mesh&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                <span class="s2">&quot;No k_mesh attribute. Must use &#39;set_k_mesh&#39; first to generate uniform mesh.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">flat_mesh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mesh</span><span class="o">.</span><span class="n">square_mesh</span></div>


<div class="viewcode-block" id="TBModel.set_onsite">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.set_onsite">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_onsite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onsite_en</span><span class="p">,</span> <span class="n">ind_i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define on-site energies for tight-binding orbitals.</span>

<span class="sd">        You can set the energy for a single orbital (by specifying `ind_i`), or for all</span>
<span class="sd">        orbitals at once (by passing a list/array to `onsite_en`).</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Using &#39;reset&#39; for `mode` is deprecated, use &#39;set&#39; instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        onsite_en : float, array-like, np.ndarray of shape ``(2, 2)``</span>
<span class="sd">            If `ind_i` is unspecified or None, `onsite_en` must be a list/array of length `norb`.</span>
<span class="sd">            Otherwise, it may be a single value or a 2x2 matrix in the spinful case.</span>

<span class="sd">            For spinless models (``nspin=1``):</span>
<span class="sd">                - Real scalar or list/array of real scalars (one per orbital).</span>
<span class="sd">            For spinful models (``nspin=2``):</span>
<span class="sd">                - Scalar: interpreted as :math:`a I` for both spin components.</span>
<span class="sd">                - 4-vector ``[a, b, c, d]``: interpreted as :math:`a I + b \\sigma_x + c \\sigma_y + d \\sigma_z`: </span>
<span class="sd">                    </span>
<span class="sd">                    .. math::</span>
<span class="sd">                        \\begin{bmatrix}</span>
<span class="sd">                            a + d &amp; b - i c \\\\</span>
<span class="sd">                            b + i c &amp; a - d</span>
<span class="sd">                        \\end{bmatrix}</span>

<span class="sd">                - Full 2x2 Hermitian matrix.</span>

<span class="sd">        ind_i : int, optional</span>
<span class="sd">            Index of tight-binding orbital to update. If None, all orbitals are updated and</span>
<span class="sd">            an array of the same shape as `onsite_en` is expected.</span>
<span class="sd">        mode : {&#39;set&#39;, &#39;add&#39;}, optional</span>
<span class="sd">            Specifies how `onsite_en` is used</span>
<span class="sd">            - &quot;set&quot;: On-site energy is set to the value of `onsite_en`. (Default)</span>
<span class="sd">            - &quot;add&quot;: Adds to the previous value of on-site energy.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If called multiple times with &quot;add&quot;, values are accumulated.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tb.set_onsite([0.0, 1.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; tb.set_onsite(100.0, 1, mode=&quot;add&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tb.set_onsite(0.0, 1, mode=&quot;set&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tb.set_onsite([2.0, 3.0, 4.0], mode=&quot;set&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle deprecated &#39;reset&#39; mode</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;reset&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;reset&#39; mode is deprecated as of v2.0. Use &#39;set&#39; instead to set the onsite energy.&quot;</span>
                <span class="s2">&quot;This will be removed in a future version.&quot;</span>
            <span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;set&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_Hermitian</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Onsite terms should be real, or in case where it is a matrix, Hermitian.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">block</span>

        <span class="c1"># prechecks</span>
        <span class="k">if</span> <span class="n">ind_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># when ind_i is not specified, onsite_en should be a list or array</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;When ind_i is not specified, onsite_en must be a list or array.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># the number of onsite energies must match the number of orbitals,</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;List of onsite energies must include a value for every orbital.&quot;</span>
                <span class="p">)</span>

            <span class="n">processed</span> <span class="o">=</span> <span class="p">[</span><span class="n">process</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">onsite_en</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ind_i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ind_i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Index ind_i is not within the range of number of orbitals.&quot;</span>
                <span class="p">)</span>
            <span class="n">processed</span> <span class="o">=</span> <span class="p">[</span><span class="n">process</span><span class="p">(</span><span class="n">onsite_en</span><span class="p">)]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind_i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;set&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">processed</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Onsite energy for site </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> was already set; resetting to the specified values.&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;add&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">processed</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">block</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mode should be either &#39;set&#39; or &#39;add&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.set_hop">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.set_hop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_hop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hop_amp</span><span class="p">,</span>
        <span class="n">ind_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ind_j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ind_R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;set&quot;</span><span class="p">,</span>
        <span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define hopping parameters between tight-binding orbitals.</span>

<span class="sd">        In the notation of tight-binding formalism, this function specifies:</span>

<span class="sd">        .. math::</span>
<span class="sd">            H_{ij}(\\mathbf{R}) = \\langle \\phi_{\\mathbf{0},i} | H | \\phi_{\\mathbf{R},j} \\rangle</span>

<span class="sd">        where :math:`\\langle \\phi_{\\mathbf{0},i} |` is the i-th orbital in the home unit cell,</span>
<span class="sd">        and :math:`| \\phi_{\\mathbf{R},j} \\rangle` is the j-th orbital in a cell shifted by lattice vector :math:`\\mathbf{R}`.</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Using &#39;reset&#39; for `mode` is deprecated, use &#39;set&#39; instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hop_amp : scalar, array-like, np.ndarray of shape ``(2, 2)``</span>
<span class="sd">            For spinless models (`nspin=1`):</span>
<span class="sd">                - Real scalar or list/array of real scalars (one per orbital).</span>
<span class="sd">            For spinful models (`nspin=2`):</span>
<span class="sd">                - Scalar: interpreted as :math:`a I` for both spin components.</span>
<span class="sd">                - 4-vector ``[a, b, c, d]``: interpreted as :math:`a I + b \sigma_x + c \sigma_y + d \sigma_z`:</span>

<span class="sd">                    .. math::</span>
<span class="sd">                        \\begin{bmatrix}</span>
<span class="sd">                            a + d &amp; b - i c \\\\</span>
<span class="sd">                            b + i c &amp; a - d</span>
<span class="sd">                        \\end{bmatrix}</span>

<span class="sd">                - Full 2x2 Hermitian matrix.</span>
<span class="sd">        ind_i : int</span>
<span class="sd">            Index of bra orbital (in home unit cell).</span>
<span class="sd">        ind_j : int</span>
<span class="sd">            Index of ket orbital (in cell shifted by `ind_R`).</span>
<span class="sd">        ind_R : array-like of int, optional</span>
<span class="sd">            Lattice vector in reduced coordinates pointing to the unit cell</span>
<span class="sd">            where the ket orbital is located. Must have length `dim_r`. If model is non-periodic,</span>
<span class="sd">            can be omitted.</span>
<span class="sd">        mode : {&#39;set&#39;, &#39;add&#39;}, optional</span>
<span class="sd">            Specifies how `hop_amp` is used</span>
<span class="sd">                - &quot;set&quot;: Set the hopping term to the value of `hop_amp`. (Default)</span>
<span class="sd">                - &quot;add&quot;: Add `hop_amp` to the previous value.</span>
<span class="sd">        allow_conjugate_pair : bool, optional</span>
<span class="sd">            If True, allows specification of both a hopping and its conjugate pair.</span>
<span class="sd">            If False, prevents double-counting.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Strictly speaking, this term specifies hopping amplitude for hopping from site j+R to site i, not vice-versa.</span>
<span class="sd">        There is no need to specify hoppings in both :math:`i \\rightarrow j+\\mathbf{R}` and</span>
<span class="sd">        :math:`j \\rightarrow i-\\mathbf{R}` directions, since the latter is included automatically as</span>

<span class="sd">        .. math::</span>
<span class="sd">            H_{ji}(-\\mathbf{R}) = \\left[ H_{ij}(\\mathbf{R}) \\right]^*</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tb.set_hop(0.3+0.4j, 0, 2, [0, 1])</span>
<span class="sd">        &gt;&gt;&gt; tb.set_hop(0.1+0.2j, 0, 2, [0, 1], mode=&quot;set&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tb.set_hop(100.0, 0, 2, [0, 1], mode=&quot;add&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#### Prechecks and formatting ####</span>
        <span class="c1"># deprecation warning</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;reset&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;reset&#39; mode is deprecated as of v2.0. Use &#39;set&#39; instead to set the hopping term.&quot;</span>
                <span class="s2">&quot;This will be removed in a future version.&quot;</span>
            <span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;set&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind_R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify ind_R when we have a periodic direction.&quot;</span><span class="p">)</span>
        <span class="c1"># make sure ind_i and ind_j are not out of scope</span>
        <span class="k">if</span> <span class="n">ind_i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ind_i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index ind_i is not within range of number of orbitals.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ind_j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ind_j</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index ind_j is not within range of number of orbitals.&quot;</span><span class="p">)</span>

        <span class="c1"># if necessary convert from integer to array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind_R</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If dim_k is not 1, should not use integer for ind_R. Instead use list.&quot;</span>
                <span class="p">)</span>
            <span class="n">tmpR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">tmpR</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_R</span>
            <span class="n">ind_R</span> <span class="o">=</span> <span class="n">tmpR</span>
        <span class="c1"># check length of ind_R</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind_R</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">ind_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ind_R</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Length of input ind_R vector must equal dim_r, even if dim_k &lt; dim_r.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">ind_R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;ind_R is not of correct type. Should be array-type or integer.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Do not allow onsite hoppings to be specified here</span>
        <span class="k">if</span> <span class="n">ind_i</span> <span class="o">==</span> <span class="n">ind_j</span><span class="p">:</span>
            <span class="c1"># not extended</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Do not use set_hop for onsite terms. Use set_onsite instead.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># hopping within unit cell</span>
            <span class="k">elif</span> <span class="n">ind_R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ind_R</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Do not use set_hop for onsite terms. Use set_onsite instead.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># make sure that if &lt;i|H|j+R&gt; is specified that &lt;j|H|i-R&gt; is not!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_conjugate_pair</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ind_i</span> <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ind_j</span> <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n</span>
<span class="s2">                            Following matrix element was already implicitely specified:</span>
<span class="s2">                            i=</span><span class="si">{</span><span class="n">ind_i</span><span class="si">}</span><span class="s2">, j=</span><span class="si">{</span><span class="n">ind_j</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">                            Remember, specifying &lt;i|H|j&gt; automatically specifies &lt;j|H|i&gt;.  For</span>
<span class="s2">                            consistency, specify all hoppings for a given bond in the same</span>
<span class="s2">                            direction. Alternatively, see the documentation on the</span>
<span class="s2">                            &#39;allow_conjugate_pair&#39; flag.)</span>
<span class="s2">                            &quot;&quot;&quot;</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ind_R</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n</span>
<span class="s2">                            Following matrix element was already implicitely specified:</span>
<span class="s2">                            i=</span><span class="si">{</span><span class="n">ind_i</span><span class="si">}</span><span class="s2">, j=</span><span class="si">{</span><span class="n">ind_j</span><span class="si">}</span><span class="s2">, R=</span><span class="si">{</span><span class="n">ind_R</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">                            Remember,specifying &lt;i|H|j+R&gt; automatically specifies &lt;j|H|i-R&gt;.  For</span>
<span class="s2">                            consistency, specify all hoppings for a given bond in the same</span>
<span class="s2">                            direction.  (Or, alternatively, see the documentation on the</span>
<span class="s2">                            &#39;allow_conjugate_pair&#39; flag.)</span>
<span class="s2">                            &quot;&quot;&quot;</span>
                        <span class="p">)</span>

        <span class="c1"># convert to 2x2 matrix if needed</span>
        <span class="n">hop_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_val_to_block</span><span class="p">(</span><span class="n">hop_amp</span><span class="p">)</span>
        <span class="c1"># hopping term parameters to be stored</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_hop</span> <span class="o">=</span> <span class="p">[</span><span class="n">hop_use</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind_i</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind_j</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_hop</span> <span class="o">=</span> <span class="p">[</span><span class="n">hop_use</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind_i</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind_j</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">)]</span>

        <span class="c1"># see if there is a hopping term with same i,j,R</span>
        <span class="n">use_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">iih</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">):</span>
            <span class="n">same_ijR</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">ind_i</span> <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ind_j</span> <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">same_ijR</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">]):</span>
                    <span class="n">same_ijR</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># if they are the same then store index of site at which they are the same</span>
            <span class="k">if</span> <span class="n">same_ijR</span><span class="p">:</span>
                <span class="n">use_index</span> <span class="o">=</span> <span class="n">iih</span>

        <span class="c1"># specifying hopping terms from scratch, can be called only once</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;set&quot;</span><span class="p">:</span>
            <span class="c1"># make sure we specify things only once</span>
            <span class="k">if</span> <span class="n">use_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Hopping for </span><span class="si">{</span><span class="n">ind_i</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">ind_j</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">ind_R</span><span class="si">}</span><span class="s2"> was already set to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">use_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Resetting to </span><span class="si">{</span><span class="n">hop_amp</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">use_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_hop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hop</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;add&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">use_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_hop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Wrong value of mode parameter. Should be either `set` or `add`.&quot;</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_val_to_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert input value to appropriate matrix block for onsite or hopping.</span>

<span class="sd">        For nspin=1, returns the value (should be real or complex scalar).</span>
<span class="sd">        For nspin=2:</span>
<span class="sd">            - Scalar: returns a 2x2 matrix proportional to the identity.</span>
<span class="sd">            - Array with up to four elements: returns a 2x2 matrix as</span>
<span class="sd">              :math:`a I + b \sigma_x + c \sigma_y + d \sigma_z`.</span>
<span class="sd">            - 2x2 matrix: returns the matrix as is.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        val : float, complex, list, np.ndarray</span>
<span class="sd">            Value to convert.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float, complex, or np.ndarray</span>
<span class="sd">            Matrix block for onsite or hopping.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If input is not a valid format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># spinless case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For spinless case, value must be a scalar.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="c1"># spinful case: construct 2x2 matrix</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">paulis</span> <span class="o">=</span> <span class="p">[</span><span class="n">SIGMA0</span><span class="p">,</span> <span class="n">SIGMAX</span><span class="p">,</span> <span class="n">SIGMAY</span><span class="p">,</span> <span class="n">SIGMAZ</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="c1"># scalar -&gt; identity</span>
            <span class="k">return</span> <span class="n">coeffs</span> <span class="o">*</span> <span class="n">SIGMA0</span>
        <span class="k">elif</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
            <span class="n">block</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">val</span> <span class="o">*</span> <span class="n">paulis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">coeffs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;For spinful models, value should be a scalar, length-4 iterable, or 2x2 array.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">block</span>

<div class="viewcode-block" id="TBModel.get_velocity">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.get_velocity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_pts</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the velocity operator</span>

<span class="sd">        The velocity operator is defined via the commutator :math:`v_k = \\partial_k H_k` for an array of k-points.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_pts : array of shape (Nk, dim_k)</span>
<span class="sd">            Array of k-points in reduced coordinates.</span>
<span class="sd">        cartesian : bool, optional</span>
<span class="sd">            If True, use Cartesian coordinates for the velocity operator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vel : array of shape (dim_k, Nk, norb, norb)</span>
<span class="sd">            Velocity operators at each k-point. First axis indexes the cartesian direction if `cartesian` is True.</span>
<span class="sd">            Otherwise, it indexes the reduced direction.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The velocity operator is defined via the derivative of the Hamiltonian</span>
<span class="sd">        with respect to k, i.e.,</span>

<span class="sd">        .. math::</span>
<span class="sd">            v_k = \\frac{\\partial H(k)}{\\partial k}</span>

<span class="sd">        The imaginary number is omitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span>

        <span class="k">if</span> <span class="n">k_pts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if kpnt is just a number then convert it to an array</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k_pts</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">dim_k</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;k_pts should be a 2D array of shape (n_kpts, dim_k).&quot;</span>
                    <span class="p">)</span>
                <span class="n">k_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">k_pts</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k_pts</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">k_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k_pts</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim_k</span><span class="p">:</span>
                        <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;If &#39;k_pts&#39; is a single k-point, it must be of shape dim_k.&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Reshape to (1, dim_k)</span>
                        <span class="n">k_arr</span> <span class="o">=</span> <span class="n">k_arr</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;k_pts should be a list or numpy array, or possibly a number for 1d k-space.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># check that k-vector is of corect size</span>
            <span class="k">if</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim_k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k_arr should be a 2D array of shape (n_kpts, dim_k).&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;k_pts should not be None for velocity operator.&quot;</span><span class="p">)</span>

        <span class="n">norb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>
        <span class="n">nspin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span>
        <span class="n">orb_red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">)</span>  <span class="c1"># shape (norb, dim_r)</span>
        <span class="n">hoppings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span>

        <span class="n">i_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hoppings</span><span class="p">])</span>
        <span class="n">j_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hoppings</span><span class="p">])</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hoppings</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="c1"># Precompute delta_r for all hoppings</span>
        <span class="n">orb_i</span> <span class="o">=</span> <span class="n">orb_red</span><span class="p">[</span><span class="n">i_indices</span><span class="p">]</span>  <span class="c1"># Shape: (n_hoppings, dim_r)</span>
        <span class="n">orb_j</span> <span class="o">=</span> <span class="n">orb_red</span><span class="p">[</span><span class="n">j_indices</span><span class="p">]</span>  <span class="c1"># Shape: (n_hoppings, dim_r)</span>

        <span class="n">ind_Rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hoppings</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">delta_r</span> <span class="o">=</span> <span class="n">ind_Rs</span> <span class="o">-</span> <span class="n">orb_i</span> <span class="o">+</span> <span class="n">orb_j</span>  <span class="c1"># Shape: (n_hoppings, dim_r)</span>
        <span class="n">delta_r_per</span> <span class="o">=</span> <span class="n">delta_r</span><span class="p">[:,</span> <span class="n">per</span><span class="p">]</span>  <span class="c1"># Shape: (n_hoppings, dim_k)</span>

        <span class="c1"># # Compute phase factors for all k-points and hoppings</span>
        <span class="n">k_dot_r</span> <span class="o">=</span> <span class="n">k_arr</span> <span class="o">@</span> <span class="n">delta_r_per</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Shape: (n_kpts, n_hoppings)</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k_dot_r</span><span class="p">)</span>  <span class="c1"># Shape: (n_kpts, n_hoppings)</span>
        <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
            <span class="n">deriv_phase</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">delta_r_per</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lat</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">T</span><span class="p">[</span>
                <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">phases</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deriv_phase</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">delta_r_per</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">phases</span><span class="p">[</span>
                <span class="kc">None</span><span class="p">,</span> <span class="o">...</span>
            <span class="p">]</span>

        <span class="n">n_hops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hoppings</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">T_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_hops</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">norb</span><span class="p">),</span> <span class="nb">complex</span><span class="p">)</span>
            <span class="n">T_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_hops</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">norb</span><span class="p">),</span> <span class="nb">complex</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hops</span><span class="p">)</span>
            <span class="n">T_f</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">i_indices</span><span class="p">,</span> <span class="n">j_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">amps</span>
            <span class="n">T_r</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">j_indices</span><span class="p">,</span> <span class="n">i_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">amps</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># spinful: each amp is a 22 block</span>
            <span class="n">T_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_hops</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">complex</span><span class="p">)</span>
            <span class="n">T_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">T_f</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_hops</span><span class="p">):</span>
                <span class="n">T_f</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">i_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:,</span> <span class="n">j_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">amps</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
                <span class="n">T_r</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">j_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:,</span> <span class="n">i_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">amps</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># compute forward contribution into vel array</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">deriv_phase</span><span class="p">,</span> <span class="n">T_f</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># compute reverse contribution in temporary buffer</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">deriv_phase</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">T_r</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># add in-place to avoid extra allocation</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vel</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">vel</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vel</span></div>


<div class="viewcode-block" id="TBModel.hamiltonian">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.hamiltonian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_pts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the Bloch Hamiltonian for an array of k-points in reduced coordinates.</span>

<span class="sd">        The Hamiltonian is computed in tight-binding convention I, which includes phase factors</span>
<span class="sd">        associated with orbital positions in the hopping terms:</span>

<span class="sd">        .. math::</span>

<span class="sd">            H_{ij}(k) = \\sum_{\\mathbf{R}} t_{ij}(\mathbf{R}) \\exp[i \\mathbf{k} \\cdot (\\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{R})]</span>

<span class="sd">        where :math:`t_{ij}(R)` is the hopping amplitude from orbital j to i through lattice vector :math:`\\mathbf{R}`.</span>
<span class="sd">        </span>
<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_pts : (Nk, dim_k) array, optional</span>
<span class="sd">            Array of k-points in reduced coordinates.</span>
<span class="sd">            If `None`, the Hamiltonian is computed at a single point (`dim_k = 0`),</span>
<span class="sd">            corresponding to a finite sample.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ham : np.ndarray </span>
<span class="sd">            Array of Bloch-Hamiltonian matrices defined on the specified k-points. The Hamiltonian is Hermitian by construction.</span>

<span class="sd">            - If `dim_k` &gt; 0: shape is (n_kpts, n_orb, n_orb) for spinless models, or (n_kpts, n_orb, 2, n_orb, 2) </span>
<span class="sd">              for spinful models.</span>

<span class="sd">            - If `dim_k` = 0: shape is (n_orb, n_orb) for spinless or (n_orb, 2, n_orb, 2) for spinful models.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In convention I, the Hamiltonian satisfies:</span>

<span class="sd">        .. math::</span>

<span class="sd">            H(k) \\neq H(k + G), \\quad \\text{but instead} \\quad H(k) = U H(k + G) U^{\\dagger}</span>

<span class="sd">        where :math:`G` is a reciprocal lattice vector and :math:`U` is a unitary transformation</span>
<span class="sd">        relating the two. </span>
<span class="sd">        </span>
<span class="sd">        Finite difference estimates of :math:`\\partial_{k_\\mu} H(k)` may not be accurate at</span>
<span class="sd">        boundaries due to the gauge discontinuity inherent in convention I.        </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cache invariant data to avoid repeated conversions</span>
        <span class="n">dim_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span>
        <span class="n">norb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>
        <span class="n">nspin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span>
        <span class="n">orb_red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">)</span>  <span class="c1"># shape (norb, dim_r)</span>
        <span class="n">orb_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">norb</span><span class="p">)</span>
        <span class="n">site_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">)</span>
        <span class="n">hoppings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span>

        <span class="k">if</span> <span class="n">k_pts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if kpnt is just a number then convert it to an array</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k_pts</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">dim_k</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;k_pts should be a 2D array of shape (n_kpts, dim_k).&quot;</span>
                    <span class="p">)</span>
                <span class="n">k_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">k_pts</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k_pts</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">k_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k_pts</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim_k</span><span class="p">:</span>
                        <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;If &#39;k_pts&#39; is a single k-point, it must be of shape dim_k.&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Reshape to (1, dim_k)</span>
                        <span class="n">k_arr</span> <span class="o">=</span> <span class="n">k_arr</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;k_pts should be a list or numpy array, or possibly a number for 1d k-space.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># check that k-vector is of corect size</span>
            <span class="k">if</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim_k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k_arr should be a 2D array of shape (n_kpts, dim_k).&quot;</span><span class="p">)</span>

            <span class="n">n_kpts</span> <span class="o">=</span> <span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ham</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_kpts</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">norb</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">ham</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_kpts</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid spin value.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim_k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must provide a list of k-vectors for the Bloch Hamiltonian of extended systems.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># finite sample</span>
                <span class="k">if</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ham</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">norb</span><span class="p">,</span> <span class="n">norb</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">ham</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid spin value.&quot;</span><span class="p">)</span>

        <span class="n">hop_amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hoppings</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">i_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hoppings</span><span class="p">])</span>
        <span class="n">j_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hoppings</span><span class="p">])</span>
        <span class="n">n_hops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hoppings</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ham</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">norb</span><span class="p">,</span> <span class="n">norb</span><span class="p">),</span> <span class="nb">complex</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="p">(</span><span class="n">i_indices</span><span class="p">,</span> <span class="n">j_indices</span><span class="p">),</span> <span class="n">hop_amps</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="p">(</span><span class="n">j_indices</span><span class="p">,</span> <span class="n">i_indices</span><span class="p">),</span> <span class="n">hop_amps</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">site_energies</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">ham</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_hops</span><span class="p">):</span>
                    <span class="n">ham</span><span class="p">[</span><span class="n">i_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:,</span> <span class="n">j_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">hop_amps</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
                    <span class="n">ham</span><span class="p">[</span><span class="n">j_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:,</span> <span class="n">i_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">hop_amps</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

                <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orb_idxs</span><span class="p">:</span>
                    <span class="n">ham</span><span class="p">[</span><span class="n">orb</span><span class="p">,</span> <span class="p">:,</span> <span class="n">orb</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">site_energies</span><span class="p">[</span><span class="n">orb</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ham</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute phase factors for all k-points and hoppings</span>
            <span class="n">orb_i</span> <span class="o">=</span> <span class="n">orb_red</span><span class="p">[</span><span class="n">i_indices</span><span class="p">]</span>  <span class="c1"># Shape: (n_hoppings, dim_r)</span>
            <span class="n">orb_j</span> <span class="o">=</span> <span class="n">orb_red</span><span class="p">[</span><span class="n">j_indices</span><span class="p">]</span>  <span class="c1"># Shape: (n_hoppings, dim_r)</span>
            <span class="n">ind_Rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hoppings</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="n">delta_r</span> <span class="o">=</span> <span class="n">ind_Rs</span> <span class="o">-</span> <span class="n">orb_i</span> <span class="o">+</span> <span class="n">orb_j</span>  <span class="c1"># Shape: (n_hoppings, dim_r)</span>
            <span class="n">delta_r_per</span> <span class="o">=</span> <span class="n">delta_r</span><span class="p">[:,</span> <span class="n">per</span><span class="p">]</span>  <span class="c1"># Shape: (n_hoppings, dim_k)</span>

            <span class="n">k_dot_r</span> <span class="o">=</span> <span class="n">k_arr</span> <span class="o">@</span> <span class="n">delta_r_per</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Shape: (n_kpts, n_hoppings)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k_dot_r</span><span class="p">)</span>  <span class="c1"># Shape: (n_kpts, n_hoppings)</span>

            <span class="k">if</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">T_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_hops</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">norb</span><span class="p">),</span> <span class="nb">complex</span><span class="p">)</span>
                <span class="n">T_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_hops</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">norb</span><span class="p">),</span> <span class="nb">complex</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_hops</span><span class="p">)</span>
                <span class="n">T_f</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">i_indices</span><span class="p">,</span> <span class="n">j_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">hop_amps</span>
                <span class="n">T_r</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">j_indices</span><span class="p">,</span> <span class="n">i_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">hop_amps</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">T_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_hops</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">complex</span><span class="p">)</span>
                <span class="n">T_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_hops</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_hops</span><span class="p">):</span>
                    <span class="n">T_f</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">i_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:,</span> <span class="n">j_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">hop_amps</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
                    <span class="n">T_r</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">j_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:,</span> <span class="n">i_indices</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">hop_amps</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

            <span class="n">ham</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="n">T_f</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">ham_hc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">phases</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">T_r</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">ham_hc</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ham</span><span class="p">)</span>

            <span class="c1"># fill diagonal elements with onsite energies</span>
            <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orb_idxs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ham</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">orb</span><span class="p">,</span> <span class="n">orb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">site_energies</span><span class="p">[</span><span class="n">orb</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">ham</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">orb</span><span class="p">,</span> <span class="p">:,</span> <span class="n">orb</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">site_energies</span><span class="p">[</span><span class="n">orb</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ham</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_periodic_H</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H_flat</span><span class="p">,</span> <span class="n">k_vals</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies periodic boundary conditions to the Hamiltonian.</span>
<span class="sd">        This function modifies the Hamiltonian by multiplying it with a phase factor</span>
<span class="sd">        that depends on the orbital positions and the k-values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orb_vecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_orb</span><span class="p">()</span>
        <span class="n">orb_vec_diff</span> <span class="o">=</span> <span class="n">orb_vecs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">orb_vecs</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c1"># orb_phase = np.exp(1j * 2 * np.pi * np.einsum(&#39;ijm, ...m-&gt;...ij&#39;, orb_vec_diff, k_vals))</span>
        <span class="n">orb_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">orb_vec_diff</span><span class="p">,</span> <span class="n">k_vals</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">H_per_flat</span> <span class="o">=</span> <span class="n">H_flat</span> <span class="o">*</span> <span class="n">orb_phase</span>
        <span class="k">return</span> <span class="n">H_per_flat</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sol_ham</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ham</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_spin_ax</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solves Hamiltonian and returns eigenvectors, eigenvalues&quot;&quot;&quot;</span>

        <span class="c1"># shape(ham): (Nk, n_orb, n_orb), (Nk, n_orb, n_spin, n_orb, n_spin)</span>
        <span class="c1"># or in finite cases (n_orb, n_orb), (n_orb, n_spin, n_orb, n_spin)</span>
        <span class="c1"># flatten spin axes</span>
        <span class="k">if</span> <span class="n">ham</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># have k points</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">ham</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstate</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape_evecs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ham</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norb</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">shape_evecs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ham</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nstate</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norb</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">ham</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span><span class="p">:</span>
            <span class="c1"># must be a finite sample, no k-points</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstate</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape_evecs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norb</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">shape_evecs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Hamiltonian has wrong shape.&quot;</span><span class="p">)</span>

        <span class="n">ham_use</span> <span class="o">=</span> <span class="n">ham</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">new_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ham_use</span><span class="p">,</span> <span class="n">ham_use</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Hamiltonian matrix is not Hermitian.&quot;</span><span class="p">)</span>

        <span class="c1"># solve matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_eigvecs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">ham_use</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">eval</span><span class="p">,</span> <span class="n">evec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">ham_use</span><span class="p">)</span>
            <span class="c1"># transpose matrix eig since otherwise it is confusing</span>
            <span class="c1"># now eig[i,:] is eigenvector for eval[i]-th eigenvalue</span>
            <span class="n">evec</span> <span class="o">=</span> <span class="n">evec</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keep_spin_ax</span><span class="p">:</span>
                <span class="n">evec</span> <span class="o">=</span> <span class="n">evec</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape_evecs</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">eval</span><span class="p">,</span> <span class="n">evec</span>

<div class="viewcode-block" id="TBModel.solve_ham">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.solve_ham">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_ham</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_spin_ax</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Diagonalize the Hamiltonian </span>
<span class="sd">        </span>
<span class="sd">        Solve for eigenvalues and optionally eigenvectors of the tight-binding model</span>
<span class="sd">        at a list of one-dimensional k-vectors.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">            Merged :func:`solve_all` and :func:`solve_one` into this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_list : array_like, optional</span>
<span class="sd">            One-dimensional list or array of k-vectors, each given in reduced coordinates.</span>
<span class="sd">            Shape should be (Nk, dim_k), where dim_k is the number of periodic directions.</span>
<span class="sd">            Should not be specified for systems with zero-dimensional reciprocal space.</span>

<span class="sd">        return_eigvecs : bool, optional</span>
<span class="sd">            If True, both eigenvalues and eigenvectors are returned.</span>
<span class="sd">            If False (default), only eigenvalues are returned.</span>

<span class="sd">        keep_spin_ax : bool, optional</span>
<span class="sd">            If True (default), the spin axes are kept in the output eigenvectors.</span>
<span class="sd">            If False, the spin axes are flattened.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eval : {(Nk, nstate), (nstate)} np.ndarray </span>
<span class="sd">            Array of eigenvalues. Shape is:</span>
<span class="sd">            - (Nk, nbnd) for periodic systems</span>
<span class="sd">            - (nbnd,) for zero-dimensional (molecular) systems</span>

<span class="sd">        evec : {(Nk, nstate, nstate), (nstate, nstate), (Nk, nstate, norb, 2), (nstate, norb, 2)} np.ndarray, optional</span>
<span class="sd">            Array of eigenvectors (if `return_eigvecs=True`). The ordering of bands matches that in `eval`.</span>

<span class="sd">            Eigenvectors :code:`evec[k, n, j]` correspond to the coefficient</span>
<span class="sd">            :math:`C^{n \mathbf{k}}_j` in the expansion in orbital basis.</span>

<span class="sd">            For spinless models:</span>
<span class="sd">            - Shape is (Nk, nbnd, norb)</span>
<span class="sd">            For spinful models:</span>
<span class="sd">            - Shape is (Nk, nbnd, norb, 2)</span>
<span class="sd">            In zero-dimensional systems:</span>
<span class="sd">            - (nbnd, n_orb) or (nbnd, n_orb, 2)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function uses the convention described in section 3.1 of the</span>
<span class="sd">        :download:`pythtb notes on tight-binding formalism &lt;/misc/pythtb-formalism.pdf&gt;`.</span>
<span class="sd">        The returned wavefunctions correspond to the cell-periodic part</span>
<span class="sd">        :math:`u_{n \mathbf{k}}(\mathbf{r})` and not the full Bloch function</span>
<span class="sd">        :math:`\Psi_{n \mathbf{k}}(\mathbf{r})`.</span>

<span class="sd">        In many cases, using the :class:`pythtb.wf_array.WFArray` class offers a more</span>
<span class="sd">        elegant interface for handling eigenstates on a regular k-mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Solve for eigenvalues at several k-points:</span>

<span class="sd">        &gt;&gt;&gt; eval = tb.solve_ham([[0.0, 0.0], [0.0, 0.2], [0.0, 0.5]])</span>

<span class="sd">        Solve for eigenvalues and eigenvectors:</span>

<span class="sd">        &gt;&gt;&gt; eval, evec = tb.solve_ham([[0.0, 0.0], [0.0, 0.2]], return_eigvecs=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Ham</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">(</span><span class="n">k_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_eigvecs</span><span class="p">:</span>
            <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol_ham</span><span class="p">(</span>
                <span class="n">Ham</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="n">return_eigvecs</span><span class="p">,</span> <span class="n">keep_spin_ax</span><span class="o">=</span><span class="n">keep_spin_ax</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">eigvals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong shape of eigvals&quot;</span><span class="p">)</span>
                <span class="c1"># if only one k_point, remove that redundant axis (reproduces solve_one)</span>
                <span class="k">if</span> <span class="n">eigvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eigvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sol_ham</span><span class="p">(</span><span class="n">Ham</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="n">return_eigvecs</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">eigvals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong shape of eigvals&quot;</span><span class="p">)</span>
                <span class="c1"># if only one k_point, remove that redundant axis (reproduces solve_one)</span>
                <span class="k">if</span> <span class="n">eigvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">eigvals</span></div>


<div class="viewcode-block" id="TBModel.solve_one">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.solve_one">[docs]</a>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;use .solve_ham() instead (since v2.0).&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eig_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Use .solve_ham() instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span>
            <span class="n">k_list</span><span class="o">=</span><span class="n">k_list</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">,</span> <span class="n">keep_spin_ax</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.solve_all">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.solve_all">[docs]</a>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;use .solve_ham() instead (since v2.0).&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eig_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Use .solve_ham() instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span>
            <span class="n">k_list</span><span class="o">=</span><span class="n">k_list</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="n">eig_vectors</span><span class="p">,</span> <span class="n">keep_spin_ax</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.cut_piece">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.cut_piece">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cut_piece</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">fin_dir</span><span class="p">,</span> <span class="n">glue_edgs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TBModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cut a (d-1)-dimensional piece out of a d-dimensional tight-binding model.</span>
<span class="sd">        </span>
<span class="sd">        Constructs a (d-1)-dimensional tight-binding model out of a</span>
<span class="sd">        d-dimensional one by repeating the unit cell a given number of</span>
<span class="sd">        times along one of the periodic lattice vectors. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num : int</span>
<span class="sd">            How many times to repeat the unit cell.</span>

<span class="sd">        fin_dir : int</span>
<span class="sd">            Index of the real space lattice vector along</span>
<span class="sd">            which you no longer wish to maintain periodicity.</span>

<span class="sd">        glue_edgs : bool, optional</span>
<span class="sd">            If True, allow hoppings from one edge to the other of a cut model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fin_model : TBModel</span>
<span class="sd">            Object of type :class:`pythtb.TBModel` representing a cutout</span>
<span class="sd">            tight-binding model. </span>

<span class="sd">        See Also</span>
<span class="sd">        ---------</span>
<span class="sd">        :ref:`haldane-fin-nb` : For an example</span>
<span class="sd">        :ref:`haldane-edge-nb` : For an example</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Orbitals in `fin_model` are numbered so that the `i`-th orbital of the `n`-th unit </span>
<span class="sd">          cell has index ``i + norb * n`` (here `norb` is the number of orbitals in the original model).</span>
<span class="sd">        - The real-space lattice vectors of the returned model are the same as those of</span>
<span class="sd">          the original model; only the dimensionality of reciprocal space</span>
<span class="sd">          is reduced.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Construct two-dimensional model B out of three-dimensional model A</span>

<span class="sd">        &gt;&gt;&gt; A = TBModel(3, 3, ...)</span>

<span class="sd">        model A by repeating model along second lattice vector ten times</span>

<span class="sd">        &gt;&gt;&gt; B = A.cut_piece(10, 1)</span>

<span class="sd">        Further cut two-dimensional model B into one-dimensional model</span>
<span class="sd">        A by repeating unit cell twenty times along third lattice</span>
<span class="sd">        vector and allow hoppings from one edge to the other</span>

<span class="sd">        &gt;&gt;&gt; C = B.cut_piece(20, 2, glue_edgs=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Model is already finite&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument num not an integer&quot;</span><span class="p">)</span>

        <span class="c1"># check value of num</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Argument num must be positive!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">glue_edgs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Can&#39;t have num=1 and glueing of the edges!&quot;</span><span class="p">)</span>

        <span class="c1"># generate orbitals of a finite model</span>
        <span class="n">fin_orb</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">onsite</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># store also onsite energies</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>  <span class="c1"># go over all cells in finite direction</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>  <span class="c1"># go over all orbitals in one cell</span>
                <span class="c1"># make a copy of j-th orbital</span>
                <span class="n">orb_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="c1"># change coordinate along finite direction</span>
                <span class="n">orb_tmp</span><span class="p">[</span><span class="n">fin_dir</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="c1"># add to the list</span>
                <span class="n">fin_orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orb_tmp</span><span class="p">)</span>
                <span class="c1"># do the onsite energies at the same time</span>
                <span class="n">onsite</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">onsite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">onsite</span><span class="p">)</span>
        <span class="n">fin_orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fin_orb</span><span class="p">)</span>

        <span class="c1"># generate periodic directions of a finite model</span>
        <span class="n">fin_per</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span>
        <span class="c1"># find if list of periodic directions contains the one you</span>
        <span class="c1"># want to make finite</span>
        <span class="k">if</span> <span class="n">fin_per</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">fin_dir</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Can not make model finite along this direction!&quot;</span><span class="p">)</span>
        <span class="c1"># remove index which is no longer periodic</span>
        <span class="n">fin_per</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fin_dir</span><span class="p">)</span>

        <span class="c1"># generate object of TBModel type that will correspond to a cutout</span>
        <span class="n">fin_model</span> <span class="o">=</span> <span class="n">TBModel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">),</span>
            <span class="n">fin_orb</span><span class="p">,</span>
            <span class="n">fin_per</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># remember if came from w90</span>
        <span class="n">fin_model</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span>
        <span class="p">)</span>

        <span class="c1"># now put all onsite terms for the finite model</span>
        <span class="n">fin_model</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="n">onsite</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;set&quot;</span><span class="p">)</span>

        <span class="c1"># put all hopping terms</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>  <span class="c1"># go over all cells in finite direction</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)):</span>  <span class="c1"># go over all hoppings in one cell</span>
                <span class="c1"># amplitude of the hop is the same</span>
                <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># lattice vector of the hopping</span>
                <span class="n">ind_R</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="c1"># store by how many cells is the hopping in finite direction</span>
                <span class="n">jump_fin</span> <span class="o">=</span> <span class="n">ind_R</span><span class="p">[</span><span class="n">fin_dir</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">fin_model</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ind_R</span><span class="p">[</span><span class="n">fin_dir</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># one of the directions now becomes finite</span>

                <span class="c1"># index of &quot;from&quot; and &quot;to&quot; hopping indices</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>
                <span class="c1">#   have to compensate  for the fact that ind_R in finite direction</span>
                <span class="c1">#   will not be used in the finite model</span>
                <span class="n">hj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">jump_fin</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>

                <span class="c1"># decide whether this hopping should be added or not</span>
                <span class="n">to_add</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># if edges are not glued then neglect all jumps that spill out</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">glue_edgs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">hj</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hj</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">*</span> <span class="n">num</span><span class="p">:</span>
                        <span class="n">to_add</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># if edges are glued then do mod division to wrap up the hopping</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hj</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hj</span><span class="p">)</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span>

                <span class="c1"># add hopping to a finite model</span>
                <span class="k">if</span> <span class="n">to_add</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fin_model</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">fin_model</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span>
                            <span class="n">amp</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">hj</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fin_model</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span>
                            <span class="n">amp</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">hj</span><span class="p">,</span> <span class="n">ind_R</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>

        <span class="k">return</span> <span class="n">fin_model</span></div>


<div class="viewcode-block" id="TBModel.reduce_dim">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.reduce_dim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reduce_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_k</span><span class="p">,</span> <span class="n">value_k</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TBModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduces dimensionality of the model by taking a reciprocal-space slice</span>

<span class="sd">        This function returns a d-1 dimensional tight-binding model obtained</span>
<span class="sd">        by constraining one of k-vector components in :math:`{\\cal H}_{\\bf</span>
<span class="sd">        k}` to be a constant.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remove_k : int</span>
<span class="sd">            Which reciprocal space unit vector component</span>
<span class="sd">            you wish to keep constant.</span>

<span class="sd">        value_k : float</span>
<span class="sd">            Value of the k-vector component to which you are</span>
<span class="sd">            constraining this model. Must be given in reduced coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        red_tb : :class:`pythtb.TBModel`</span>
<span class="sd">            Reduced tight-binding model.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Reduces dimensionality of the model by taking a reciprocal-space</span>
<span class="sd">        slice of the Bloch Hamiltonian :math:`{\\cal H}_{\\bf k}`. The Bloch</span>
<span class="sd">        Hamiltonian (defined in :download:`notes on tight-binding</span>
<span class="sd">        formalism &lt;/misc/pythtb-formalism.pdf&gt;` in section 3.1 equation 3.7) of a</span>
<span class="sd">        d-dimensional model is a function of d-dimensional k-vector.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------- </span>
<span class="sd">        Constrains second k-vector component to equal 0.3</span>

<span class="sd">        &gt;&gt;&gt; red_tb = tb.reduce_dim(1, 0.3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Can not reduce dimensionality even further!&quot;</span><span class="p">)</span>
        <span class="c1"># make a copy</span>
        <span class="n">red_tb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># make one of the directions not periodic</span>
        <span class="n">red_tb</span><span class="o">.</span><span class="n">_per</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">remove_k</span><span class="p">)</span>
        <span class="n">red_tb</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">red_tb</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span>
        <span class="c1"># check that really removed one and only one direction</span>
        <span class="k">if</span> <span class="n">red_tb</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Specified wrong dimension to reduce!&quot;</span><span class="p">)</span>

        <span class="c1"># specify hopping terms from scratch</span>
        <span class="n">red_tb</span><span class="o">.</span><span class="n">_hoppings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># set all hopping parameters for this value of value_k</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)):</span>
            <span class="n">hop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">amp</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">hop</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">hop</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ind_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hop</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># vector from one site to another</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">red_tb</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">red_tb</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># take only r-vector component along direction you are not making periodic</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="p">[</span><span class="n">remove_k</span><span class="p">]</span>
            <span class="c1"># Calculate the part of hopping phase, only for this direction</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="mf">2.0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">value_k</span> <span class="o">*</span> <span class="n">rv</span><span class="p">))</span>
            <span class="c1"># store modified version of the hop</span>
            <span class="c1"># Since we are getting rid of one dimension, it could be that now</span>
            <span class="c1"># one of the hopping terms became onsite term because one direction</span>
            <span class="c1"># is no longer periodic</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_R</span><span class="p">[</span><span class="n">red_tb</span><span class="o">.</span><span class="n">_per</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">ind_R</span><span class="p">[</span><span class="n">remove_k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># in this case this is really an onsite term</span>
                    <span class="n">red_tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="n">amp</span> <span class="o">*</span> <span class="n">phase</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># in this case must treat both R and -R because that term would</span>
                    <span class="c1"># have been counted twice without dimensional reduction</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">red_tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span>
                            <span class="n">amp</span> <span class="o">*</span> <span class="n">phase</span> <span class="o">+</span> <span class="p">(</span><span class="n">amp</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">i</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">red_tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span>
                            <span class="n">amp</span> <span class="o">*</span> <span class="n">phase</span> <span class="o">+</span> <span class="p">(</span><span class="n">amp</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">i</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span>
                        <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># just in case make the R vector zero along the reduction dimension</span>
                <span class="n">ind_R</span><span class="p">[</span><span class="n">remove_k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># add hopping term</span>
                <span class="n">red_tb</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span>
                    <span class="n">amp</span> <span class="o">*</span> <span class="n">phase</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ind_R</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">red_tb</span></div>


<div class="viewcode-block" id="TBModel.change_nonperiodic_vector">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.change_nonperiodic_vector">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">change_nonperiodic_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">np_dir</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
        <span class="n">new_latt_vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
        <span class="n">to_home</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
        <span class="n">to_home_warning</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TBModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change non-periodic lattice vector </span>

<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">            Parameter `to_home_supress_warning` has been renamed to `to_home_warning`.</span>
<span class="sd">            Note: this change inverts the meaning of the boolean parameter.</span>
<span class="sd">        </span>
<span class="sd">        Returns tight-binding model :class:`pythtb.TBModel` in which one of</span>
<span class="sd">        the non-periodic &quot;lattice vectors&quot; is changed.  Non-periodic vectors are those </span>
<span class="sd">        elements of `lat` that are not listed as periodic with the `per` parameter.</span>

<span class="sd">        The returned object has modified reduced coordinates of orbitals, </span>
<span class="sd">        consistent with the new choice of `lat`. Therefore, the actual </span>
<span class="sd">        (Cartesian) coordinates of orbitals in original and returned :class:`pythtb.TBModel`</span>
<span class="sd">        are the same.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        np_dir : int</span>
<span class="sd">            Index of nonperiodic lattice vector to change.</span>

<span class="sd">        new_latt_vec : array_like, optional</span>
<span class="sd">            The new nonperiodic lattice vector. If None (default), the new</span>
<span class="sd">            nonperiodic lattice vector is the same as the original one except</span>
<span class="sd">            that all components in the periodic space have been projected out</span>
<span class="sd">            (so that the new nonperiodic vector is perpendicular to all</span>
<span class="sd">            periodic vectors).</span>

<span class="sd">        to_home : bool, optional</span>
<span class="sd">            If ``True`` (default), shift all orbitals to the home cell along</span>
<span class="sd">            non-periodic directions.</span>

<span class="sd">        to_home_warning : bool, optional</span>
<span class="sd">            If ``True`` (default), code will print a warning message whenever</span>
<span class="sd">            returned object has an orbital with at least one reduced coordinate</span>
<span class="sd">            smaller than 0 or larger than 1 along a non-periodic direction. If</span>
<span class="sd">            ``False`` the warning message will not be printed.</span>

<span class="sd">            Note that this parameter has no effect on the model; it only determines whether a</span>
<span class="sd">            warning message is printed or not. </span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        nnp_tb : :class:`pythtb.TBModel`</span>
<span class="sd">            An equivalent tight-binding model with</span>
<span class="sd">            one redefined nonperiodic lattice vector.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        per</span>
<span class="sd">        :ref:`boron-nitride-nb` : For an example.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This function is especially useful after using function cut_piece to create slabs, rods, or ribbons.</span>
<span class="sd">        - By default, the new non-periodic vector is constructed</span>
<span class="sd">          from the original by removing all components in the periodic</span>
<span class="sd">          space. This ensures that the Berry phases computed in the</span>
<span class="sd">          periodic space correspond to the usual expectations.</span>
<span class="sd">        - For example, after this change, the Berry phase computed for a</span>
<span class="sd">          ribbon depends only on the location of the Wannier center</span>
<span class="sd">          in the extended direction, not on its location in the</span>
<span class="sd">          transverse direction. Alternatively, the new nonperiodic</span>
<span class="sd">          vector can be set explicitly via the `new_latt_vec` parameter.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Modify slab model so that nonperiodic third vector is perpendicular to the slab</span>

<span class="sd">        &gt;&gt;&gt; nnp_tb = tb.change_nonperiodic_vector(2)</span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that selected direction is nonperiodic</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">per</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">np_dir</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Selected direction </span><span class="si">{</span><span class="n">np_dir</span><span class="si">}</span><span class="s2"> is not nonperiodic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_latt_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># construct new nonperiodic lattice vector</span>
            <span class="n">per_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">direc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
                <span class="n">per_temp</span><span class="p">[</span><span class="n">direc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">direc</span><span class="p">]</span>
            <span class="c1"># find projection coefficients onto space of periodic vectors</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">per_temp</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">np_dir</span><span class="p">],</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">projec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>
            <span class="c1"># subtract off to get new nonperiodic vector</span>
            <span class="n">np_lattice_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">np_dir</span><span class="p">]</span> <span class="o">-</span> <span class="n">projec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># new_latt_vec is passed as argument</span>
            <span class="c1"># check shape and convert to numpy array</span>
            <span class="n">np_lattice_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_latt_vec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np_lattice_vec</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nonperiodic vector has wrong length&quot;</span><span class="p">)</span>

        <span class="c1"># define new set of lattice vectors</span>
        <span class="n">np_lat</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
        <span class="n">np_lat</span><span class="p">[</span><span class="n">np_dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">np_lattice_vec</span>

        <span class="c1"># convert reduced vector in original lattice to reduced vector in new cell lattice</span>
        <span class="n">np_orb</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">:</span>  <span class="c1"># go over all orbitals</span>
            <span class="n">orb_cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">orb</span><span class="p">)</span>
            <span class="c1"># convert to reduced coordinates</span>
            <span class="n">np_orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">orb_cart</span><span class="p">))</span>

        <span class="c1"># create new TBModel object to be returned</span>
        <span class="n">nnp_tb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># update lattice vectors and orbitals</span>
        <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np_lat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np_orb</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np_orb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb_vecs</span><span class="p">)</span>

        <span class="c1"># double check that everything went as planned</span>

        <span class="c1"># is the new vector perpendicular to all periodic directions?</span>
        <span class="k">if</span> <span class="n">new_latt_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="p">[</span><span class="n">np_dir</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mf">1.0e-6</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                        </span><span class="sd">&quot;&quot;&quot;\n\nThis shouldn&#39;t happen.  New nonperiodic vector </span>
<span class="sd">                        is not perpendicular to periodic vectors!?&quot;&quot;&quot;</span>
                    <span class="p">)</span>
        <span class="c1"># are cartesian coordinates of orbitals the same in two cases?</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">cart_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">cart_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cart_old</span> <span class="o">-</span> <span class="n">cart_new</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.0e-6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;\n\nThis shouldn&#39;t happen. New choice of nonperiodic vector</span>
<span class="sd">                        somehow changed Cartesian coordinates of orbitals.&quot;&quot;&quot;</span>
                <span class="p">)</span>
        <span class="c1"># check that volume of the cell is not zero</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">nnp_tb</span><span class="o">.</span><span class="n">_lat</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0e-6</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Lattice with new choice of nonperiodic vector has zero volume?!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># put orbitals to home cell if asked for</span>
        <span class="k">if</span> <span class="n">to_home</span><span class="p">:</span>
            <span class="n">nnp_tb</span><span class="o">.</span><span class="n">_shift_to_home</span><span class="p">(</span><span class="n">to_home_warning</span><span class="p">)</span>

        <span class="c1"># return new tb model</span>
        <span class="k">return</span> <span class="n">nnp_tb</span></div>


<div class="viewcode-block" id="TBModel.make_supercell">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.make_supercell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_supercell</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sc_red_lat</span><span class="p">,</span>
        <span class="n">return_sc_vectors</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">to_home</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">to_home_warning</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TBModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make model on a super-cell.</span>

<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">            Parameter `to_home_supress_warning` has been renamed to `to_home_warning`.</span>
<span class="sd">            Note: this change inverts the meaning of the boolean parameter.</span>

<span class="sd">        Constructs a :class:`pythtb.TBModel` representing a super-cell </span>
<span class="sd">        of the current object. This function can be used together with :func:`cut_piece`</span>
<span class="sd">        in order to create slabs with arbitrary surfaces.</span>

<span class="sd">        By default all orbitals will be shifted to the home cell after</span>
<span class="sd">        unit cell has been created. That way all orbitals will have</span>
<span class="sd">        reduced coordinates between 0 and 1. If you wish to avoid this</span>
<span class="sd">        behavior, you need to set, *to_home* argument to *False*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sc_red_lat : array-like</span>
<span class="sd">          Super-cell lattice vectors in terms of reduced coordinates</span>
<span class="sd">          of the original tight-binding model. Shape must be</span>
<span class="sd">          ``(dim_r, dim_r)``. First index in the array specifies super-cell vector,</span>
<span class="sd">          while second index specifies coordinate of that super-cell vector. </span>
<span class="sd">          </span>
<span class="sd">          If `dim_k` &lt; `dim_r` then still need to specify full array with</span>
<span class="sd">          size ``(dim_r, dim_r)`` for consistency, but non-periodic</span>
<span class="sd">          directions must have 0 on off-diagonal elements and 1 on</span>
<span class="sd">          diagonal.</span>

<span class="sd">        return_sc_vectors : bool, optional</span>
<span class="sd">            Default value is ``False``. If ``True`` returns also lattice vectors</span>
<span class="sd">            inside the super-cell. Internally, super-cell tight-binding model will</span>
<span class="sd">            have orbitals repeated in the same order in which these</span>
<span class="sd">            super-cell vectors are given, but if argument `to_home`</span>
<span class="sd">            is set ``True`` (which it is by default) then additionally,</span>
<span class="sd">            orbitals will be shifted to the home cell.</span>

<span class="sd">        to_home : bool, optional</span>
<span class="sd">            Default value is ``True``. If ``True`` will shift all orbitals</span>
<span class="sd">            to the home cell along non-periodic directions.</span>

<span class="sd">        to_home_warning : bool, optional</span>
<span class="sd">            Default value is ``True``. If ``True`` prints warning messages</span>
<span class="sd">            about orbitals being outside the home cell (reduced coordinate larger</span>
<span class="sd">            than 1 or smaller than 0 along non-periodic direction). </span>

<span class="sd">            Note that setting this parameter to *True* or *False* has no effect on </span>
<span class="sd">            resulting coordinates of the model. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sc_tb : :class:`pythtb.TBModel`</span>
<span class="sd">            Tight-binding model in a super-cell.</span>

<span class="sd">        sc_vectors : :class:`numpy.ndarray`, optional</span>
<span class="sd">          Super-cell vectors, returned only if</span>
<span class="sd">          `return_sc_vectors` is set to ``True`` (default value is</span>
<span class="sd">          ``False``).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The super-cell is constructed by repeating the original unit cell</span>
<span class="sd">        according to the specified super-cell lattice vectors. The resulting</span>
<span class="sd">        model will have a larger Brillouin zone and may exhibit different</span>
<span class="sd">        electronic properties compared to the original model.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create super-cell out of 2d tight-binding model ``tb``</span>

<span class="sd">        &gt;&gt;&gt; sc_tb = tb.make_supercell([[2, 1], [-1, 2]])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Can&#39;t make super cell for model without periodic directions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Must have at least one periodic direction to make a super-cell&quot;</span>
            <span class="p">)</span>

        <span class="c1"># convert array to numpy array</span>
        <span class="n">use_sc_red_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sc_red_lat</span><span class="p">)</span>

        <span class="c1"># checks on super-lattice array</span>
        <span class="k">if</span> <span class="n">use_sc_red_lat</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Dimension of sc_red_lat array must be dim_r*dim_r&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_sc_red_lat</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">sc_red_lat array elements must be integers&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_sc_red_lat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Diagonal elements of sc_red_lat for non-periodic directions must equal 1.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">((</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">))</span>
                    <span class="ow">and</span> <span class="n">use_sc_red_lat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Off-diagonal elements of sc_red_lat for non-periodic directions must equal 0.&quot;</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0e-6</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Super-cell lattice vectors length/area/volume too close to zero, or zero.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Super-cell lattice vectors need to form right handed system.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># converts reduced vector in original lattice to reduced vector in super-cell lattice</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">to_red_sc</span><span class="p">(</span><span class="n">red_vec_orig</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">red_vec_orig</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># conservative estimate on range of search for super-cell vectors</span>
        <span class="n">max_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span>

        <span class="c1"># candidates for super-cell vectors</span>
        <span class="n">sc_cands</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_R</span><span class="p">,</span> <span class="n">max_R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># find all vectors inside super-cell</span>
        <span class="c1"># store them here</span>
        <span class="n">sc_vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eps_shift</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0e-8</span>
        <span class="p">)</span>  <span class="c1"># shift of the grid, so to avoid double counting</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">sc_cands</span><span class="p">:</span>
            <span class="c1"># compute reduced coordinates of this candidate vector in the super-cell frame</span>
            <span class="n">tmp_red</span> <span class="o">=</span> <span class="n">to_red_sc</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># check if in the interior</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tmp_red</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">eps_shift</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">eps_shift</span><span class="p">:</span>
                    <span class="n">inside</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">inside</span><span class="p">:</span>
                <span class="n">sc_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span>
        <span class="c1"># number of times unit cell is repeated in the super-cell</span>
        <span class="n">num_sc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_vec</span><span class="p">)</span>

        <span class="c1"># check that found enough super-cell vectors</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">))))</span> <span class="o">!=</span> <span class="n">num_sc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Super-cell generation failed! Wrong number of super-cell vectors found.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># cartesian vectors of the super lattice</span>
        <span class="n">sc_cart_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">use_sc_red_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>

        <span class="c1"># orbitals of the super-cell tight-binding model</span>
        <span class="n">sc_orb</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cur_sc_vec</span> <span class="ow">in</span> <span class="n">sc_vec</span><span class="p">:</span>  <span class="c1"># go over all super-cell vectors</span>
            <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">:</span>  <span class="c1"># go over all orbitals</span>
                <span class="c1"># shift orbital and compute coordinates in</span>
                <span class="c1"># reduced coordinates of super-cell</span>
                <span class="n">sc_orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_red_sc</span><span class="p">(</span><span class="n">orb</span> <span class="o">+</span> <span class="n">cur_sc_vec</span><span class="p">))</span>

        <span class="c1"># create super-cell TBModel object to be returned</span>
        <span class="n">sc_tb</span> <span class="o">=</span> <span class="n">TBModel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span>
            <span class="n">sc_cart_lat</span><span class="p">,</span>
            <span class="n">sc_orb</span><span class="p">,</span>
            <span class="n">per</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">,</span>
            <span class="n">nspin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># remember if came from w90</span>
        <span class="n">sc_tb</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span>
        <span class="p">)</span>

        <span class="c1"># repeat onsite energies</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sc</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
                <span class="n">sc_tb</span><span class="o">.</span><span class="n">set_onsite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>

        <span class="c1"># set hopping terms</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cur_sc_vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sc_vec</span><span class="p">):</span>  <span class="c1"># go over all super-cell vectors</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)</span>
            <span class="p">):</span>  <span class="c1"># go over all hopping terms of the original model</span>
                <span class="c1"># amplitude of the hop is the same</span>
                <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># lattice vector of the hopping</span>
                <span class="n">ind_R</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="c1"># super-cell component of hopping lattice vector</span>
                <span class="c1"># shift also by current super cell vector</span>
                <span class="n">sc_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">to_red_sc</span><span class="p">(</span><span class="n">ind_R</span> <span class="o">+</span> <span class="n">cur_sc_vec</span><span class="p">))</span>  <span class="c1"># round down!</span>
                <span class="n">sc_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sc_part</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="c1"># find remaining vector in the original reduced coordinates</span>
                <span class="n">orig_part</span> <span class="o">=</span> <span class="n">ind_R</span> <span class="o">+</span> <span class="n">cur_sc_vec</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sc_part</span><span class="p">,</span> <span class="n">use_sc_red_lat</span><span class="p">)</span>
                <span class="c1"># remaining vector must equal one of the super-cell vectors</span>
                <span class="n">pair_ind</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">pair_sc_vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sc_vec</span><span class="p">):</span>
                    <span class="k">if</span> <span class="kc">False</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">pair_sc_vec</span> <span class="o">==</span> <span class="n">orig_part</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">pair_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Found duplicate super cell vector!&quot;</span><span class="p">)</span>
                        <span class="n">pair_ind</span> <span class="o">=</span> <span class="n">p</span>
                <span class="k">if</span> <span class="n">pair_ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Did not find super cell vector!&quot;</span><span class="p">)</span>

                <span class="c1"># index of &quot;from&quot; and &quot;to&quot; hopping indices</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>
                <span class="n">hj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pair_ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span>

                <span class="c1"># add hopping term</span>
                <span class="n">sc_tb</span><span class="o">.</span><span class="n">set_hop</span><span class="p">(</span>
                    <span class="n">amp</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">hj</span><span class="p">,</span> <span class="n">sc_part</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">allow_conjugate_pair</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

        <span class="c1"># put orbitals to home cell if asked for</span>
        <span class="k">if</span> <span class="n">to_home</span><span class="p">:</span>
            <span class="n">sc_tb</span><span class="o">.</span><span class="n">_shift_to_home</span><span class="p">(</span><span class="n">to_home_warning</span><span class="p">)</span>

        <span class="c1"># return new tb model and vectors if needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_sc_vectors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sc_tb</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sc_tb</span><span class="p">,</span> <span class="n">sc_vec</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_shift_to_home</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_home_warning</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shifts orbital coordinates (along periodic directions) to the home</span>
<span class="sd">        unit cell. </span>
<span class="sd">        </span>
<span class="sd">        After this function is called reduced coordinates</span>
<span class="sd">        (along periodic directions) of orbitals will be between 0 and</span>
<span class="sd">        1.</span>

<span class="sd">        Version of pythtb 1.7.2 (and earlier) was shifting orbitals to</span>
<span class="sd">        home along even nonperiodic directions. In the later versions</span>
<span class="sd">        of the code (this present version, and future versions) we</span>
<span class="sd">        don&#39;t allow this anymore, as this feature might produce</span>
<span class="sd">        counterintuitive results.  Shifting orbitals along nonperiodic</span>
<span class="sd">        directions changes physical nature of the tight-binding model.</span>
<span class="sd">        This behavior might be especially non-intuitive for</span>
<span class="sd">        tight-binding models that came from the *cut_piece* function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_home_warning: bool, optional</span>
<span class="sd">            Default value is ``True``. If ``True`` prints warning messages</span>
<span class="sd">            about orbitals being outside the home cell (reduced coordinate larger</span>
<span class="sd">            than 1 or smaller than 0 along non-periodic direction). </span>

<span class="sd">            Note that setting this parameter to *True* or *False* has no effect on </span>
<span class="sd">            resulting coordinates of the model. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create list of emty lists (one for each real-space direction)</span>
        <span class="n">warning_list</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span>
        <span class="c1"># go over all orbitals</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">):</span>
            <span class="c1"># find displacement vector needed to bring back to home cell</span>
            <span class="n">disp_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># shift only in periodic directions</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0e-6</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
                    <span class="n">disp_vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># check for shift in non-periodic directions</span>
                    <span class="k">if</span> <span class="n">shift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">warning_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">warning_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># print warning message if needed</span>
        <span class="k">if</span> <span class="n">to_home_warning</span><span class="p">:</span>
            <span class="n">warn_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">):</span>
                <span class="n">orbs</span> <span class="o">=</span> <span class="n">warning_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">orbs</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">orb_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">)</span>
                    <span class="n">warn_str</span> <span class="o">+=</span> <span class="s2">&quot;  * Direction </span><span class="si">%1d</span><span class="s2"> : Orbitals &quot;</span> <span class="o">%</span> <span class="n">k</span> <span class="o">+</span> <span class="n">orb_str</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">warn_str</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;  &quot;</span>
                    <span class="o">+</span> <span class="mi">69</span> <span class="o">*</span> <span class="s2">&quot;-&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">  WARNING from &#39;_shift_to_home&#39; (called by &#39;change_nonperiodic_vector&#39;</span>
<span class="s2">  or &#39;make_supercell&#39;): Orbitals are not &quot;shifted to home&quot; along</span>
<span class="s2">  non-periodic directions.  Older versions of PythTb (1.7.2 and older)</span>
<span class="s2">  allowed this, but it changes the physical nature of the tight-binding</span>
<span class="s2">  model.  PythTB 1.7.3 and newer versions of PythTb no longer shift</span>
<span class="s2">  orbitals along non-periodic directions.</span>
<span class="s2">  *</span>
<span class="s2">  In the present case, the following orbitals would have been assigned</span>
<span class="s2">  different coordinates in PythTb 1.7.2 and older:</span>
<span class="s2">  *</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
                    <span class="o">+</span> <span class="n">warn_str</span>
                    <span class="o">+</span> <span class="s2">&quot;&quot;&quot;  *</span>
<span class="s2">  To prevent printing this warning, call &#39;change_nonperiodic_vector&#39;</span>
<span class="s2">  or &#39;make_supercell&#39; with &#39;to_home_warning=False&#39;.</span>
<span class="s2">  *</span>
<span class="s2">  This warning message will be removed in future versions of PythTb.</span>
<span class="s2">&quot;&quot;&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;  &quot;</span>
                    <span class="o">+</span> <span class="mi">69</span> <span class="o">*</span> <span class="s2">&quot;-&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># shift orbitals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">disp_vec</span>
            <span class="c1"># shift hoppings</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">disp_vec</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">disp_vec</span>

<div class="viewcode-block" id="TBModel.add_orb">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.add_orb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_orb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a new orbital to the model with the specified coordinates.</span>
<span class="sd">        </span>
<span class="sd">        The orbital coordinate must be given in reduced</span>
<span class="sd">        coordinates, i.e. in units of the real-space lattice vectors</span>
<span class="sd">        of the model. The new orbital is added at the end of the list</span>
<span class="sd">        of orbitals, and the orbital index is set to the next available</span>
<span class="sd">        index.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord : array_like, float</span>
<span class="sd">            The reduced coordinates of the new orbital of length `dim_r`. If</span>
<span class="sd">            `coord` is a single float or int, it will be converted to a 1D array </span>
<span class="sd">            (`dim_r` must be 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coord</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected array_like or float, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">,</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Orbital coordinate must be a list of length </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        
        <span class="c1"># Append orbital coordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">,</span> <span class="n">coord</span><span class="p">])</span>
        <span class="c1"># Update number of orbitals and states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="c1"># Append default site energy and specified flag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">,</span> <span class="n">new_block</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

        <span class="c1"># No hoppings are added by default</span>

<div class="viewcode-block" id="TBModel.remove_orb">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.remove_orb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_orb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Removes specified orbitals from the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_remove : array-like or int</span>
<span class="sd">            List of orbital indices to be removed, or index of single orbital to be removed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        del_tb : class:`pythtb.TBModel`</span>
<span class="sd">            Model with removed orbitals.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Removing orbitals will reindex the orbitals with indices higher</span>
<span class="sd">        than those that are removed. For example, if model has 6 orbitals</span>
<span class="sd">        and you remove the 2nd orbital, then the orbitals 3-6 will be</span>
<span class="sd">        reindexed to 1-4 (Python counting). Indices of first two orbitals (0 and 1) </span>
<span class="sd">        are unaffected.</span>
<span class="sd">         </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        If original_model has say 10 orbitals then returned small_model will </span>
<span class="sd">        have only 8 orbitals.</span>

<span class="sd">        &gt;&gt;&gt; small_model = original_model.remove_orb([2,5])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if a single integer is given, convert to a list with one element</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">to_remove</span><span class="p">):</span>
            <span class="n">orb_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_remove</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orb_index</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>

        <span class="c1"># check range of indices</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">orb_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orb_index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">orb_ind</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">orb_ind</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">orb_ind</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Specified wrong orbitals to remove!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orb_index</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">orb_index</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]:</span>
                <span class="k">if</span> <span class="n">ind1</span> <span class="o">==</span> <span class="n">ind2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Specified duplicate orbitals to remove!&quot;</span><span class="p">)</span>

        <span class="c1"># put the orbitals to be removed in desceding order</span>
        <span class="n">orb_index</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">orb_index</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># make copy of a model</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># adjust some variables in the new model</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_norb</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orb_index</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_nstate</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orb_index</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="c1"># remove indices one by one</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">orb_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orb_index</span><span class="p">):</span>
            <span class="c1"># adjust variables</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_orb</span><span class="p">,</span> <span class="n">orb_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_site_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_site_energies</span><span class="p">,</span> <span class="n">orb_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_site_energies_specified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">_site_energies_specified</span><span class="p">,</span> <span class="n">orb_ind</span>
            <span class="p">)</span>
            <span class="c1"># adjust hopping terms (in reverse)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1"># remove all terms that involve this orbital</span>
                <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">orb_ind</span> <span class="ow">or</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">orb_ind</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise modify term</span>
                    <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">orb_ind</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">orb_ind</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">_hoppings</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="c1"># return new model</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="TBModel.k_uniform_mesh">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.k_uniform_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">k_uniform_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uniform grid of k-points in reduced coordinates.</span>

<span class="sd">        The mesh along each direction is defined from [0, 1). </span>
<span class="sd">        The mesh always contains the origin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh_size : array_like</span>
<span class="sd">            Number of k-points in the mesh in each periodic direction of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k_vec : np.ndarray</span>
<span class="sd">          Array of k-vectors on the mesh that can be directly passed to function </span>
<span class="sd">          :func:`pythtb.TBModel.solve_all`. The shape of the array is </span>
<span class="sd">          (nk1, nk2, ..., dim_k) where nk1, nk2, ... are the number of k-points</span>
<span class="sd">          in each direction defined by `mesh_size`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The uniform grid of k-points that can be passed to</span>
<span class="sd">        function :func:`pythtb.TBModel.solve_all`. </span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Returns a 10x20x30 mesh of a tight binding model </span>
<span class="sd">        with three periodic directions</span>

<span class="sd">        &gt;&gt;&gt; k_vec = my_model.k_uniform_mesh([10,20,30])</span>
<span class="sd">        &gt;&gt;&gt; print(k_vec.shape)</span>
<span class="sd">        (10, 20, 30, 3)</span>

<span class="sd">        Solve model on the uniform mesh</span>

<span class="sd">        &gt;&gt;&gt; my_model.solve_ham(k_vec)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">k_uniform_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.k_path">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.k_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">k_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">nk</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">report</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolates a path in reciprocal space.</span>

<span class="sd">        Interpolates a path in reciprocal space between specified</span>
<span class="sd">        k-points. In 2D or 3D the k-path can consist of several</span>
<span class="sd">        straight segments connecting high-symmetry points (&quot;nodes&quot;),</span>
<span class="sd">        and the results can be used to plot the bands along this path.</span>

<span class="sd">        The interpolated path that is returned contains as</span>
<span class="sd">        equidistant k-points as possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        kpts : array-like, str</span>
<span class="sd">          Array of k-vectors in reciprocal space between</span>
<span class="sd">          which interpolated path should be constructed. These</span>
<span class="sd">          k-vectors must be given in reduced coordinates.  As a</span>
<span class="sd">          special case, in 1D k-space kpts may be a string:</span>

<span class="sd">          - `&quot;full&quot;`: Implies  ``[0.0, 0.5, 1.0]`` (full BZ)</span>
<span class="sd">          - `&quot;fullc&quot;`: Implies  ``[-0.5, 0.0, 0.5]`` (full BZ, centered)</span>
<span class="sd">          - `&quot;half&quot;`: Implies  ``[ 0.0, 0.5]``  (half BZ)</span>

<span class="sd">        nk : int</span>
<span class="sd">            Total number of k-points to be used in making the plot.</span>

<span class="sd">        report : bool, optional</span>
<span class="sd">            Optional parameter specifying whether printout</span>
<span class="sd">            is desired (default is True).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k_vec : np.ndarray</span>
<span class="sd">            Array of (nearly) equidistant interpolated k-points. </span>

<span class="sd">        k_dist : np.ndarray</span>
<span class="sd">            Array giving accumulated k-distance to each</span>
<span class="sd">            k-point in the path. This array can be used to plot path in</span>
<span class="sd">            the k-space so that the distances between the k-points in</span>
<span class="sd">            the plot are exact.</span>

<span class="sd">        k_node : np.ndarray</span>
<span class="sd">            Array giving accumulated k-distance to each</span>
<span class="sd">            node on the path in Cartesian coordinates. This array is</span>
<span class="sd">            typically used to plot nodes (typically special points) on</span>
<span class="sd">            the path in k-space.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The distance between the points is calculated in the Cartesian frame,</span>
<span class="sd">          however coordinates themselves are given in dimensionless reduced coordinates!  </span>
<span class="sd">          This is done so that this array can be directly passed to function</span>
<span class="sd">          :func:`pythtb.TBModel.solve_ham`.</span>
<span class="sd">        - Unlike array `k_vec`, `k_dist` has dimensions! Units are defined here</span>
<span class="sd">          so that for a one-dimensional crystal with lattice constant equal to </span>
<span class="sd">          for example `10` the length of the Brillouin zone would equal</span>
<span class="sd">          `1/10=0.1`. In other words factors of :math:`2\pi` are</span>
<span class="sd">          absorbed into `kpts`.</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        Construct a path connecting four nodal points in k-space</span>
<span class="sd">        Path will contain 401 k-points, roughly equally spaced</span>

<span class="sd">        &gt;&gt;&gt; path = [[0.0, 0.0], [0.0, 0.5], [0.5, 0.5], [0.0, 0.0]]</span>
<span class="sd">        &gt;&gt;&gt; (k_vec, k_dist, k_node) = my_model.k_path(path,401)</span>
<span class="sd">        </span>
<span class="sd">        Solve for eigenvalues on that path</span>

<span class="sd">        &gt;&gt;&gt; evals = tb.solve_all(k_vec)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">k_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">report</span><span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.ignore_position_operator_offdiagonal">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.ignore_position_operator_offdiagonal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ignore_position_operator_offdiagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set flag to ignore off-diagonal elements of the position operator.</span>

<span class="sd">        Call to this function enables one to approximately compute</span>
<span class="sd">        Berry-like objects from tight-binding models that were</span>
<span class="sd">        obtained from Wannier90.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="TBModel.position_matrix">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.position_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dir</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Position operator matrix elements</span>

<span class="sd">        Returns matrix elements of the position operator along</span>
<span class="sd">        direction `dir` for eigenvectors `evec` at a single k-point.</span>
<span class="sd">        Position operator is defined in reduced coordinates.</span>

<span class="sd">        The returned object :math:`X` is</span>

<span class="sd">        .. math::</span>

<span class="sd">          X_{m n {\bf k}}^{\alpha} = \langle u_{m {\bf k}} \vert</span>
<span class="sd">          r^{\alpha} \vert u_{n {\bf k}} \rangle</span>

<span class="sd">        Here :math:`r^{\alpha}` is the position operator along direction</span>
<span class="sd">        :math:`\alpha` that is selected by `dir`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        evec : np.ndarray</span>
<span class="sd">            Eigenvectors for which we are computing matrix</span>
<span class="sd">            elements of the position operator.  The shape of this array</span>
<span class="sd">            is ``evec[band, orbital]`` if `nspin` = 1 and</span>
<span class="sd">            ``evec[band, orbital, spin]`` if `nspin` = 2.</span>

<span class="sd">        dir : int</span>
<span class="sd">            Direction along which we are computing the center.</span>
<span class="sd">            This integer must not be one of the periodic directions</span>
<span class="sd">            since position operator matrix element in that case is not</span>
<span class="sd">            well defined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos_mat : np.ndarray</span>
<span class="sd">            Position operator matrix :math:`X_{m n}` as defined above. </span>
<span class="sd">            This is a square matrix with size determined by number of bands</span>
<span class="sd">            given in `evec` input array.  First index of `pos_mat` corresponds to</span>
<span class="sd">            bra vector (:math:`m`) and second index to ket (:math:`n`).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`haldane-hwf-nb` : For an example.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Diagonalizes Hamiltonian at some k-points</span>

<span class="sd">        &gt;&gt;&gt; (evals, evecs) = my_model.solve_ham(k_vec, return_eigvecs=True)</span>

<span class="sd">        Computes position operator matrix elements for 3-rd kpoint</span>
<span class="sd">        and bottom five bands along first coordinate</span>

<span class="sd">        &gt;&gt;&gt; pos_mat = my_model.position_matrix(evecs[2, :5], 0)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure specified direction is not periodic!</span>
        <span class="k">if</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Can not compute position matrix elements along periodic direction!&quot;</span>
            <span class="p">)</span>
        <span class="c1"># make sure direction is not out of range</span>
        <span class="k">if</span> <span class="nb">dir</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_r</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Direction out of range!&quot;</span><span class="p">)</span>

        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="c1"># check shape of evec</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;evec must be a numpy array.&quot;</span><span class="p">)</span>
        <span class="c1"># check number of dimensions of evec</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">evec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;evec must be a 2D array with shape (band, orbital) for spinless models.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">evec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;evec must be a 3D array with shape (band, orbital, spin) for spinful models.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># get coordinates of orbitals along the specified direction</span>
        <span class="n">pos_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">[:,</span> <span class="nb">dir</span><span class="p">]</span>
        <span class="c1"># reshape arrays in the case of spinfull calculation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># tile along spin direction if needed</span>
            <span class="n">pos_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">pos_tmp</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">evec_use</span> <span class="o">=</span> <span class="n">evec</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">evec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">evec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">evec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_use</span> <span class="o">=</span> <span class="n">pos_tmp</span>
            <span class="n">evec_use</span> <span class="o">=</span> <span class="n">evec</span>

        <span class="c1"># position matrix elements</span>
        <span class="n">pos_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">evec_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">evec_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="c1"># go over all bands</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">evec_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">evec_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">pos_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evec_use</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">pos_use</span> <span class="o">*</span> <span class="n">evec_use</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="c1"># make sure matrix is Hermitian</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">pos_mat</span><span class="p">,</span> <span class="n">pos_mat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position matrix is not Hermitian.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pos_mat</span></div>


<div class="viewcode-block" id="TBModel.position_expectation">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.position_expectation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_expectation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dir</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns diagonal matrix elements of the position operator.</span>
<span class="sd">        </span>
<span class="sd">        These elements :math:`X_{n n}` can be interpreted as an</span>
<span class="sd">        average position of n-th Bloch state ``evec[n]`` along</span>
<span class="sd">        direction `dir`. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        evec : np.ndarray</span>
<span class="sd">            Eigenvectors for which we are computing matrix</span>
<span class="sd">            elements of the position operator. The shape of this array</span>
<span class="sd">            is ``evec[band, orbital]`` if ``nspin=1`` and</span>
<span class="sd">            ``evec[band, orbital, spin]`` if ``nspin=2``.</span>

<span class="sd">        dir : int</span>
<span class="sd">            Direction along which we are computing matrix</span>
<span class="sd">            elements. This integer must not be one of the periodic</span>
<span class="sd">            directions since position operator matrix element in that</span>
<span class="sd">            case is not well defined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos_exp : np.ndarray</span>
<span class="sd">            Diagonal elements of the position operator matrix :math:`X`.</span>
<span class="sd">            Length of this vector is determined by number of bands given in *evec* input</span>
<span class="sd">            array.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`haldane-hwf-nb` : For an example.</span>
<span class="sd">        position_matrix : For definition of matrix :math:`X`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Generally speaking these centers are _not_</span>
<span class="sd">        hybrid Wannier function centers (which are instead</span>
<span class="sd">        returned by :func:`TBModel.position_hwf`).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Diagonalizes Hamiltonian at some k-points</span>
<span class="sd">          </span>
<span class="sd">        &gt;&gt;&gt; (evals, evecs) = my_model.solve_ham(k_vec, return_eigvecs=True)</span>
<span class="sd">        </span>
<span class="sd">        Computes average position for 3-rd kpoint</span>
<span class="sd">        and bottom five bands along first coordinate</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; pos_exp = my_model.position_expectation(evecs[2, :5], 0)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="n">pos_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pos_exp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.position_hwf">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.position_hwf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_hwf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evec</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">hwf_evec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;orbital&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Eigenvalues and eigenvectors of the position operator</span>

<span class="sd">        Returns eigenvalues and optionally eigenvectors of the</span>
<span class="sd">        position operator matrix :math:`X` in basis of the orbitals</span>
<span class="sd">        or, optionally, of the input wave functions (typically Bloch</span>
<span class="sd">        functions). The returned eigenvectors can be interpreted as</span>
<span class="sd">        linear combinations of the input states ``evec`` that have</span>
<span class="sd">        minimal extent (or spread :math:`\Omega` in the sense of</span>
<span class="sd">        maximally localized Wannier functions) along direction</span>
<span class="sd">        ``dir``. The eigenvalues are average positions of these</span>
<span class="sd">        localized states.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        evec : np.ndarray</span>
<span class="sd">            Eigenvectors for which we are computing matrix</span>
<span class="sd">            elements of the position operator. The shape of this array</span>
<span class="sd">            is ``evec[band, orbital]`` if ``nspin=1`` and</span>
<span class="sd">            ``evec[band, orbital, spin]`` if ``nspin=2``.</span>

<span class="sd">        dir : int</span>
<span class="sd">            Direction along which we are computing matrix</span>
<span class="sd">            elements. This integer must not be one of the periodic</span>
<span class="sd">            directions since position operator matrix element in that</span>
<span class="sd">            case is not well defined.</span>

<span class="sd">        hwf_evec : bool, optional</span>
<span class="sd">            Default is ``False``. If set to ``True`` this function will</span>
<span class="sd">            return not only eigenvalues but also eigenvectors of :math:`X`. </span>

<span class="sd">        basis : {&quot;orbital&quot;, &quot;wavefunction&quot;, &quot;bloch&quot;}, optional</span>
<span class="sd">            Default is &quot;orbital&quot;. If ``basis=&quot;wavefunction&quot;`` or ``basis=&quot;bloch&quot;``, the hybrid</span>
<span class="sd">            Wannier function `hwf` is returned in the basis of the input</span>
<span class="sd">            wave functions. That is, the elements of ``hwf[i, j]`` give the amplitudes</span>
<span class="sd">            of the i-th hybrid Wannier function on the j-th input state.</span>
<span class="sd">            If ``basis=&quot;orbital&quot;``, the elements of ``hwf[i, orb]`` (or ``hwf[i, orb, spin]``</span>
<span class="sd">            if ``nspin=2``) give the amplitudes of the i-th hybrid Wannier function on</span>
<span class="sd">            the specified basis function. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hwfc : np.ndarray</span>
<span class="sd">            Eigenvalues of the position operator matrix :math:`X`</span>
<span class="sd">            (also called hybrid Wannier function centers).</span>
<span class="sd">            Length of this vector equals number of bands given in ``evec``</span>
<span class="sd">            input array. Hybrid Wannier function centers are ordered in ascending order.</span>
<span class="sd">            Note that in general `n`-th hwfc does not correspond to `n`-th</span>
<span class="sd">            state in ``evec``.</span>

<span class="sd">        hwf : np.ndarray</span>
<span class="sd">            Eigenvectors of the position operator matrix :math:`X`.</span>
<span class="sd">            (also called hybrid Wannier functions).  These are returned only if</span>
<span class="sd">            parameter ``hwf_evec = True``.</span>

<span class="sd">            The shape of this array is ``[h,x]`` or ``[h,x,s]`` depending on value of</span>
<span class="sd">            ``basis`` and ``nspin``.</span>

<span class="sd">            - If ``basis`` is &quot;bloch&quot; then ``x`` refers to indices of</span>
<span class="sd">              Bloch states.</span>
<span class="sd">            - If ``basis`` is &quot;orbital&quot; then ``x`` (or ``x`` and ``s``)</span>
<span class="sd">              correspond to orbital index (or orbital and spin index if ``nspin=2``).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`haldane-hwf-nb` : For an example.</span>
<span class="sd">        position_matrix : For the definition of the matrix :math:`X`.</span>
<span class="sd">        position_expectation : For the position expectation value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Note that these eigenvectors are not maximally localized</span>
<span class="sd">        Wannier functions in the usual sense because they are</span>
<span class="sd">        localized only along one direction. They are also not the</span>
<span class="sd">        average positions of the Bloch states `evec`, which are</span>
<span class="sd">        instead computed by :func:`position_expectation`.</span>

<span class="sd">        See Fig. 3 in [1]_ for a discussion of the hybrid Wannier function centers in the</span>
<span class="sd">        context of a Chern insulator.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1]  S. Coh, D. Vanderbilt, Phys. Rev. Lett. 102, 107603 (2009).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Diagonalizes Hamiltonian at some k-points</span>

<span class="sd">        &gt;&gt;&gt; evals, evecs = my_model.solve_ham(k_vec, return_eigvecs=True)</span>

<span class="sd">        Computes hybrid Wannier centers (and functions) for 3-rd kpoint</span>
<span class="sd">        and bottom five bands along first coordinate</span>

<span class="sd">        &gt;&gt;&gt; hwfc, hwf = my_model.position_hwf(evecs[2, :5], 0, hwf_evec=True, basis=&quot;orbital&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if model came from w90</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_position_operator_diagonal</span><span class="p">:</span>
            <span class="n">_offdiag_approximation_warning_and_stop</span><span class="p">()</span>

        <span class="c1"># get position matrix</span>
        <span class="n">pos_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">evec</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>

        <span class="c1"># diagonalize</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hwf_evec</span><span class="p">:</span>
            <span class="n">hwfc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">pos_mat</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">hwfc</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># find eigenvalues and eigenvectors</span>
            <span class="p">(</span><span class="n">hwfc</span><span class="p">,</span> <span class="n">hwf</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">pos_mat</span><span class="p">)</span>
            <span class="c1"># transpose matrix eig since otherwise it is confusing</span>
            <span class="c1"># now eig[i,:] is eigenvector for eval[i]-th eigenvalue</span>
            <span class="n">hwf</span> <span class="o">=</span> <span class="n">hwf</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># convert to right basis</span>
            <span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;wavefunction&quot;</span><span class="p">,</span> <span class="s2">&quot;bloch&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">hwfc</span><span class="p">,</span> <span class="n">hwf</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;orbital&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ret_hwf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="c1"># sum over bloch states to get hwf in orbital basis</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ret_hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">ret_hwf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hwf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">evec</span><span class="p">)</span>
                    <span class="n">hwf</span> <span class="o">=</span> <span class="n">ret_hwf</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret_hwf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="c1"># get rid of spin indices</span>
                    <span class="n">evec_use</span> <span class="o">=</span> <span class="n">evec</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>
                    <span class="c1"># sum over states</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ret_hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">ret_hwf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hwf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">evec_use</span><span class="p">)</span>
                    <span class="c1"># restore spin indices</span>
                    <span class="n">hwf</span> <span class="o">=</span> <span class="n">ret_hwf</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">hwf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norb</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">hwfc</span><span class="p">,</span> <span class="n">hwf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Basis must be either &#39;wavefunction&#39;, &#39;bloch&#39;, or &#39;orbital&#39;&quot;</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.berry_curvature">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.berry_curvature">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">berry_curvature</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k_pts</span><span class="p">,</span>
        <span class="n">evals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">evecs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">occ_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dirs</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">cartesian</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">abelian</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the Berry curvature at a list of k-points.</span>

<span class="sd">        The Berry curvature is computed from the velocity operator</span>
<span class="sd">        :math:`v_k = i \partial_k H_k`. Specifically, for :math:`(m,n) \in \text{occ}`,</span>

<span class="sd">        .. math::</span>

<span class="sd">            \Omega_{\mu \nu;\ mn}(k) =  \sum_{l \notin \text{occ}}</span>
<span class="sd">            \frac{</span>
<span class="sd">                \langle u_{mk} | v^{\mu}_k | u_{lk} \rangle</span>
<span class="sd">                \langle u_{lk} | v_k^{\nu} | u_{nk} \rangle</span>
<span class="sd">                -</span>
<span class="sd">                \langle u_{mk} | v_k^{\nu} | u_{lk} \rangle</span>
<span class="sd">                \langle u_{lk} | v_k^{\mu} | u_{nk} \rangle</span>
<span class="sd">            }{</span>
<span class="sd">                (E_{nk} - E_{lk})(E_{mk} - E_{lk})</span>
<span class="sd">            }</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_pts : (Nk, dim_k) array-like</span>
<span class="sd">            Array of k-points with shape (Nk, dim_k), where Nk is the number of points</span>
<span class="sd">            and dim_k is the dimensionality of the k-space.</span>
<span class="sd">        evals : (Nk, n_states) array, optional</span>
<span class="sd">            Eigenvalues of the Hamiltonian at the k-points. If not provided, they will be computed.</span>
<span class="sd">        evecs : (Nk, n_states, n_orb) array, optional</span>
<span class="sd">            Eigenvectors of the Hamiltonian. If not provided, they will be computed.</span>
<span class="sd">        occ_idxs : 1D array, optional</span>
<span class="sd">            Indices of the occupied bands. Defaults to the first half of the states.</span>
<span class="sd">        dirs : str or tuple of int, optional</span>
<span class="sd">            Directions in k-space for which to compute the curvature.</span>
<span class="sd">            If &quot;all&quot;, computes all components. If a tuple, restricts to specified indices.</span>
<span class="sd">        cartesian : bool, optional</span>
<span class="sd">            If True, computes the velocity operator in Cartesian coordinates.</span>
<span class="sd">            Default is False (reduced coordinates).</span>
<span class="sd">        abelian : bool, optional</span>
<span class="sd">            If True, returns the trace of the Berry curvature tensor (abelian case).</span>
<span class="sd">            If False, returns the full tensor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b_curv : np.ndarray</span>
<span class="sd">            Berry curvature tensor. If ``dirs`` is &quot;all&quot;, shape is (dim_k, dim_k, Nk, n_orb, n_orb).</span>
<span class="sd">            If ``dirs`` is a tuple, shape is (Nk, n_orb, n_orb) and the returned tensor is restricted </span>
<span class="sd">            to the specified directions.</span>
<span class="sd">            If ``abelian`` is True, returns the band-trace of the Berry curvature tensor and the last</span>
<span class="sd">            two dimensions are not present.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This quantity is an anti-symmetric under :math:`\mu \leftrightarrow \nu`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_k</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Berry curvature in this context is only computed for k-space dimensions. </span>
<span class="sd">                Must have dim_k &gt;= 2.</span>
<span class="sd">                &quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="n">v_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_velocity</span><span class="p">(</span><span class="n">k_pts</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="n">cartesian</span><span class="p">)</span>  <span class="c1"># (Nk, dim_k, n_orb, n_orb)</span>
        <span class="c1"># flatten spin axis if present</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nstate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nstate</span><span class="p">)</span>
        <span class="n">v_k</span> <span class="o">=</span> <span class="n">v_k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">new_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">evals</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">evecs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_ham</span><span class="p">(</span>
                <span class="n">k_pts</span><span class="p">,</span> <span class="n">return_eigvecs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keep_spin_ax</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="n">n_eigs</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Identify occupied bands</span>
        <span class="k">if</span> <span class="n">occ_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">occ_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_eigs</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">occ_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">occ_idxs</span><span class="p">)</span>

        <span class="c1"># Identify conduction bands as remainder of band indices (assumes gapped)</span>
        <span class="n">cond_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_eigs</span><span class="p">),</span> <span class="n">occ_idxs</span><span class="p">)</span>

        <span class="c1"># All pairs of energy differences</span>
        <span class="n">delta_E</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># shape (Nk, n_states, n_states)</span>
        <span class="c1"># Divide by energy differences, diagonals are ignored</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span>
            <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span>
        <span class="p">):</span>  <span class="c1"># Suppress divide by zero warnings</span>
            <span class="n">inv_delta_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">delta_E</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">delta_E</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># newaxis for Cartesian direction broadcasting</span>
        <span class="n">evecs_conj</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">conj</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c1"># transpose</span>
        <span class="n">evecs_T</span> <span class="o">=</span> <span class="n">evecs</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c1"># project vk into energy eignvector basis</span>
        <span class="n">vk_evecT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">v_k</span><span class="p">,</span> <span class="n">evecs_T</span><span class="p">)</span>  <span class="c1"># intermediate array</span>
        <span class="n">v_k_rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">evecs_conj</span><span class="p">,</span> <span class="n">vk_evecT</span><span class="p">)</span>  <span class="c1"># (dim_k, n_kpts, n_orb, n_orb)</span>

        <span class="c1"># Extract relevant submatrices</span>
        <span class="c1"># top right</span>
        <span class="n">v_occ_cond</span> <span class="o">=</span> <span class="n">v_k_rot</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">occ_idxs</span><span class="p">,</span> <span class="p">:][</span>
            <span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="n">cond_idxs</span>
        <span class="p">]</span>  <span class="c1"># shape (dim_k, Nk, n_occ, n_con)</span>
        <span class="c1"># bottom left</span>
        <span class="n">v_cond_occ</span> <span class="o">=</span> <span class="n">v_k_rot</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cond_idxs</span><span class="p">,</span> <span class="p">:][</span>
            <span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="n">occ_idxs</span>
        <span class="p">]</span>  <span class="c1"># shape (dim_k, Nk, n_con, n_occ)</span>
        <span class="c1"># top right (bottom left uneeded in Kubo formula)</span>
        <span class="n">delta_E_occ_cond</span> <span class="o">=</span> <span class="n">inv_delta_E</span><span class="p">[:,</span> <span class="n">occ_idxs</span><span class="p">,</span> <span class="p">:][</span>
            <span class="p">:,</span> <span class="p">:,</span> <span class="n">cond_idxs</span>
        <span class="p">]</span>  <span class="c1"># shape (Nk, n_con, n_occ)</span>

        <span class="c1"># premultiply by energy denominators</span>
        <span class="n">v_occ_cond</span> <span class="o">=</span> <span class="n">v_occ_cond</span> <span class="o">*</span> <span class="n">delta_E_occ_cond</span>
        <span class="n">v_cond_occ</span> <span class="o">=</span> <span class="n">v_cond_occ</span> <span class="o">*</span> <span class="n">delta_E_occ_cond</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Berry curvature shape: (dim_k, dim_k, n_kpts, n_orb, n_orb)</span>
        <span class="c1"># Where m is conduction indices, and n,l are occupied indices</span>
        <span class="c1"># &lt;unk|v_mu|umk&gt; &lt;umk|v_nu|ulk&gt; - &lt;unk|v_nu|umk&gt; &lt;umk|v_mu|ulk&gt; / (Enk - Emk)(Elk - Emk)</span>
        <span class="n">b_curv</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">v_occ_cond</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">v_cond_occ</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">v_occ_cond</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">v_cond_occ</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">abelian</span><span class="p">:</span>
            <span class="n">b_curv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">b_curv</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dirs</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b_curv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b_curv</span><span class="p">[</span><span class="n">dirs</span><span class="p">]</span></div>


<div class="viewcode-block" id="TBModel.chern">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.chern">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">chern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">occ_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dirs</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">nk</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes Chern number for occupied manifold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        occ_idxs : array-like, optional</span>
<span class="sd">            Occupied band indices. If none are provided, </span>
<span class="sd">            the lower half bands are considered occupied.</span>

<span class="sd">        dirs : tuple</span>
<span class="sd">            Indices for reciprocal space directions defining</span>
<span class="sd">            2d surface to integrate Berry flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Chern number for the occupied manifold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.mesh2</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mesh</span>

        <span class="n">nks</span> <span class="o">=</span> <span class="p">(</span><span class="n">nk</span><span class="p">,)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_k</span>
        <span class="n">k_mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">nks</span><span class="p">)</span>
        <span class="n">flat_mesh</span> <span class="o">=</span> <span class="n">k_mesh</span><span class="o">.</span><span class="n">flat_mesh</span>

        <span class="n">Omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">berry_curvature</span><span class="p">(</span><span class="n">flat_mesh</span><span class="p">,</span> <span class="n">occ_idxs</span><span class="o">=</span><span class="n">occ_idxs</span><span class="p">)</span>

        <span class="n">Nk</span> <span class="o">=</span> <span class="n">Omega</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">dk_sq</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">Nk</span>
        <span class="n">Chern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="n">dirs</span><span class="p">])</span> <span class="o">*</span> <span class="n">dk_sq</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Chern</span><span class="o">.</span><span class="n">real</span></div>


    <span class="c1">##### Plotting functions #####</span>
    <span class="c1"># These plotting functions are wrappers to the functions in plotting.py</span>
<div class="viewcode-block" id="TBModel.visualize">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.visualize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visualize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">proj_plane</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">eig_dr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">draw_hoppings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">annotate_onsite_en</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ph_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Visualizes the tight-binding model geometry.</span>

<span class="sd">        Plots the tight-binding orbitals, hopping between tight-binding orbitals, </span>
<span class="sd">        and optionally the electron eigenstates.</span>

<span class="sd">        If eigenvector is not drawn, then orbitals in home cell are drawn</span>
<span class="sd">        as red circles, and those in neighboring cells are drawn with</span>
<span class="sd">        a lighter shade of red. Hopping term directions are drawn with</span>
<span class="sd">        green lines connecting two orbitals. Origin of unit cell is</span>
<span class="sd">        indicated with blue dot, while real space unit vectors are drawn</span>
<span class="sd">        with blue lines.</span>

<span class="sd">        If eigenvector is drawn, then electron eigenstate on each orbital</span>
<span class="sd">        is drawn with a circle whose size is proportional to wavefunction</span>
<span class="sd">        amplitude while its color depends on the phase. There are various</span>
<span class="sd">        coloring schemes for the phase factor; see more details under</span>
<span class="sd">        `ph_color` parameter. If eigenvector is drawn and coloring scheme</span>
<span class="sd">        is &quot;red-blue&quot; or &quot;wheel&quot;, all other elements of the picture are</span>
<span class="sd">        drawn in gray or black.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        proj_plane : tuple or list of two integers</span>
<span class="sd">            Cartesian coordinates to be used for plotting. For example,</span>
<span class="sd">            if ``proj_plane=(0,1)`` then x-y projection of the model is</span>
<span class="sd">            drawn. This only should be specified if `dim_r` &gt; 2.</span>

<span class="sd">        eig_dr : Optional parameter specifying eigenstate to</span>
<span class="sd">          plot. If specified, this should be one-dimensional array of</span>
<span class="sd">          complex numbers specifying wavefunction at each orbital in</span>
<span class="sd">          the tight-binding basis. If not specified, eigenstate is not</span>
<span class="sd">          drawn.</span>

<span class="sd">        draw_hoppings : Optional parameter specifying whether to</span>
<span class="sd">          draw all allowed hopping terms in the tight-binding</span>
<span class="sd">          model. Default value is True.</span>

<span class="sd">        ph_color : {&quot;black&quot;, &quot;red-blue&quot;, &quot;wheel&quot;}, optional</span>
<span class="sd">            Determines the way the eigenvector phase factors are </span>
<span class="sd">            translated into color. Default value is &quot;black&quot;.</span>

<span class="sd">            - &quot;black&quot; -- phase of eigenvectors are ignored and wavefunction</span>
<span class="sd">              is always colored in black.</span>

<span class="sd">            - &quot;red-blue&quot; -- zero phase is drawn red, while phases or :math:`\pi` or</span>
<span class="sd">              :math:`-\pi` are drawn blue. Phases in between are interpolated between</span>
<span class="sd">              red and blue. Some phase information is lost in this coloring</span>
<span class="sd">              because phase of :math:`\pm \pi` have the same color.</span>

<span class="sd">            - &quot;wheel&quot; -- each phase is given unique color. In steps of :math:`\pi/3`</span>
<span class="sd">              starting from 0, colors are assigned (in increasing hue) as:</span>
<span class="sd">              red, yellow, green, cyan, blue, magenta, red.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            fig : matplotlib.figure.Figure</span>
<span class="sd">                Figure object from matplotlib.pyplot module</span>
<span class="sd">            ax : matplotlib.axes.Axes</span>
<span class="sd">                Axes object from matplotlib.pyplot module</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This function is intended for visualizing tight-binding models</span>
<span class="sd">          in two dimensions. For three-dimensional visualizations, consider using</span>
<span class="sd">          the :func:`visualize_3d` method.</span>
<span class="sd">        - Convention of the wavefunction phase is as</span>
<span class="sd">          in convention 1 in section 3.1 of :download:`notes on</span>
<span class="sd">          tight-binding formalism  &lt;/misc/pythtb-formalism.pdf&gt;`. In</span>
<span class="sd">          other words, these wavefunction phases are in correspondence</span>
<span class="sd">          with cell-periodic functions :math:`u_{n {\bf k}} ({\bf r})`</span>
<span class="sd">          not :math:`\Psi_{n {\bf k}} ({\bf r})`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Draws x-y projection of tight-binding model</span>
<span class="sd">        tweaks figure and saves it as a PDF.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; fig, ax = tb.visualize(0, 1)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        - :ref:`haldane-edge-nb`,</span>
<span class="sd">        - :ref:`visualize-nb`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot_tb_model</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">proj_plane</span><span class="p">,</span> <span class="n">eig_dr</span><span class="p">,</span> <span class="n">draw_hoppings</span><span class="p">,</span> <span class="n">annotate_onsite_en</span><span class="p">,</span> <span class="n">ph_color</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.visualize_3d">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.visualize_3d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visualize_3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">eig_dr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">draw_hoppings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">site_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">site_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_model_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ph_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Visualize a 3D tight-binding model using ``Plotly``.</span>

<span class="sd">        This function creates an interactive 3D plot of your tight-binding model,</span>
<span class="sd">        showing the unit-cell origin, lattice vectors (with arrowheads), orbitals,</span>
<span class="sd">        hopping lines, and (optionally) an eigenstate overlay with marker sizes</span>
<span class="sd">        proportional to amplitude and colors reflecting the phase.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eig_dr : </span>
<span class="sd">            Optional eigenstate (1D array of complex numbers) to display.</span>
<span class="sd">        draw_hoppings : bool, optional</span>
<span class="sd">            Whether to draw hopping lines between orbitals.</span>
<span class="sd">        annotate_onsite_en: bool, optional</span>
<span class="sd">            Whether to annotate orbitals with onsite energies.</span>
<span class="sd">        ph_color: str, optional</span>
<span class="sd">            Coloring scheme for eigenstate phases (e.g. &quot;black&quot;, &quot;red-blue&quot;, &quot;wheel&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        plotly.graph_objs.Figure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot_tb_model_3d</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">eig_dr</span><span class="o">=</span><span class="n">eig_dr</span><span class="p">,</span>
            <span class="n">draw_hoppings</span><span class="o">=</span><span class="n">draw_hoppings</span><span class="p">,</span>
            <span class="n">show_model_info</span><span class="o">=</span><span class="n">show_model_info</span><span class="p">,</span>
            <span class="n">ph_color</span><span class="o">=</span><span class="n">ph_color</span><span class="p">,</span>
            <span class="n">site_colors</span><span class="o">=</span><span class="n">site_colors</span><span class="p">,</span>
            <span class="n">site_names</span><span class="o">=</span><span class="n">site_names</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TBModel.plot_bands">
<a class="viewcode-back" href="../../generated/pythtb.TBModel.html#pythtb.TBModel.plot_bands">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_bands</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k_path</span><span class="p">,</span>
        <span class="n">nk</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span>
        <span class="n">k_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">proj_orb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">proj_spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scat_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">lc</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
        <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
        <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;plasma&quot;</span><span class="p">,</span>
        <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the band structure along a specified path in k-space.</span>

<span class="sd">        This function allows for customization of the plot, including projection of orbitals,</span>
<span class="sd">        spin projection, figure and axis objects, title, scatter size, line width,</span>
<span class="sd">        line color, line style, colormap, and whether to show a color bar.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k_path : list</span>
<span class="sd">            List of high symmetry points to plot bands through</span>
<span class="sd">        nk : int, optional</span>
<span class="sd">            Number of k-points to sample along the path. Defaults to 101.</span>
<span class="sd">        k_label : list[str], optional</span>
<span class="sd">            Labels of high symmetry points. Defaults to None.</span>
<span class="sd">        proj_orb_idx : list[int], optional</span>
<span class="sd">            List of orbital indices to project onto. Defaults to None.</span>
<span class="sd">            This will give the bands a colorscale indicating the weight of </span>
<span class="sd">            the Bloch states onto the list of orbitals.</span>
<span class="sd">        proj_spin : bool, optional</span>
<span class="sd">            Whether to project the spin components. Defaults to ``False``.</span>
<span class="sd">            If ``True``, the bands will be colored according to their spin character.</span>
<span class="sd">        fig : matplotlib.figure.Figure, optional</span>
<span class="sd">            Figure object to plot on. Defaults to None.</span>
<span class="sd">        ax : matplotlib.axes.Axes, optional</span>
<span class="sd">            Axes object to plot on. Defaults to None.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Title of the plot. Defaults to None.</span>
<span class="sd">        scat_size : float, optional</span>
<span class="sd">            Size of the scatter points. Defaults to 3.</span>
<span class="sd">        lw : float, optional</span>
<span class="sd">            Line width of the band lines. Defaults to 2.</span>
<span class="sd">        lc : str, optional</span>
<span class="sd">            Line color of the band lines. Defaults to &quot;b&quot;. Irrelevant</span>
<span class="sd">            if `proj_spin` is True or `proj_orb_idx` is not None.</span>
<span class="sd">        ls : str, optional</span>
<span class="sd">            Line style of the band lines. Defaults to &quot;solid&quot;.</span>
<span class="sd">            Irrelevant if `proj_spin` is True or `proj_orb_idx` is not None.</span>
<span class="sd">        cmap : str, optional</span>
<span class="sd">            Colormap for the band plot. Defaults to &quot;plasma&quot;. Only relevant if</span>
<span class="sd">            `proj_spin` is True or `proj_orb_idx` is not None.</span>
<span class="sd">        show : bool, optional</span>
<span class="sd">            Whether to show the plot. Defaults to False.</span>
<span class="sd">        cbar : bool, optional</span>
<span class="sd">            Whether to show a color bar. Defaults to True.</span>
<span class="sd">            Only relevant if `proj_spin` is True or `proj_orb_idx` is not None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig : matplotlib.figure.Figure</span>
<span class="sd">            ax: matplotlib.axes.Axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot_bands</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">k_path</span><span class="p">,</span>
            <span class="n">nk</span><span class="o">=</span><span class="n">nk</span><span class="p">,</span>
            <span class="n">k_label</span><span class="o">=</span><span class="n">k_label</span><span class="p">,</span>
            <span class="n">proj_orb_idx</span><span class="o">=</span><span class="n">proj_orb_idx</span><span class="p">,</span>
            <span class="n">proj_spin</span><span class="o">=</span><span class="n">proj_spin</span><span class="p">,</span>
            <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">scat_size</span><span class="o">=</span><span class="n">scat_size</span><span class="p">,</span>
            <span class="n">lw</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span>
            <span class="n">lc</span><span class="o">=</span><span class="n">lc</span><span class="p">,</span>
            <span class="n">ls</span><span class="o">=</span><span class="n">ls</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span>
            <span class="n">cbar</span><span class="o">=</span><span class="n">cbar</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2025, Trey Cole, Sinisa Coh, and David Vanderbilt.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>